"6:58:05 PM, Wednesday, March 30, 2016: Compressed sources"!

DevelopmentSessionManager installNew!

SessionManager current defaultResourceLibrary loadFlags: 0.
SessionManager current stashBootInfo!

"Ensure all structures have calculated size to avoid recompilation messages later"
ExternalStructure allSubclasses do: [:e | e byteSize]!

"Mark all the booted packages as base"
Package manager markAllPackagesAsBase!

SessionManager current saveImage!

"6:59:05 PM, Wednesday, March 30, 2016: Image saved"!

"Remove rogue .img and unnecessary .chg files"
File delete: (File default: SessionManager current imagePath extension: 'img').
File delete: 'DBOOT.chg'!

SessionManager current quit!

"16:25:16, 17 czerwca 2017: Dolphin Smalltalk Professional started"!

"16:50:07, 17 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\first.img7'"!

"16:50:54, 17 czerwca 2017: Dolphin Smalltalk Professional started"!

 1000 factorial!

7 negated!

7 negated!

7 negated!

7 negated!

Smalltalk allClasses size!

Smalltalk allClasses size!

Smalltalk allClasses!

 Object allSubinstances size!

 Object allSubinstances!

x := 111111.0. Float allInstances!

x := 'ala ma kota'!

Float allInstances!

t := SmalltalkWorkspaceDocument show!

t caption: 'To moj edytor tekstu'!

 t yourAddress!

t exit!

t := View active!

r := Random new!

t presenter workspace view backcolor: (Color fromInteger: (2 ** 24 * r next) truncated)!

t presenter workspace view backcolor: (Color fromInteger: (2 ** 24 * r next) truncated)!

Object subclass: #Osoba
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Osoba guid: (GUID fromString: '{BF7C4C9C-15FD-4F16-A289-24C77D7EA8E7}')!
Osoba comment: ''!
!Osoba categoriesForClass!Kernel-Objects! !
Object subclass: #Osoba
	instanceVariableNames: 'jan kowalski'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Osoba
	instanceVariableNames: 'imie nazwisko'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!Osoba methodsFor!
imie: a nazwisko: b
        imie := a.
        nazwisko := b! !
!Osoba categoriesFor: #imie:nazwisko:!public! !

!Osoba class methodsFor!
imie: a nazwisko: b
        ^super new imie: a nazwisko: b! !
!Osoba class categoriesFor: #imie:nazwisko:!public! !

!Osoba methodsFor!
imie
        ^imie! !
!Osoba categoriesFor: #imie!public! !

!Osoba methodsFor!
nazwisko
        ^nazwisko! !
!Osoba categoriesFor: #nazwisko!public! !

x := Osoba imie: 'Jan' nazwisko: 'Kowalski'!

x!

'Piotr'!

x!

'Hello ' * 5!

 10 factorial!

 10 factorial!

 10 factorial negated!

 10 factorial + 10!

2 raisedTo: 4!

x := 'aBdDdc'!

x!

x select: [:x | x isUpperCase]!

x select: [:y | y isUpperCase]!

x select: [:y | y isUpperCase]!

arr := Array new: 10!

tab := #(3 2 1)!

tab!



tab!

para := 1,2!

1, 2!

Object subclass: #Term
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Term guid: (GUID fromString: '{62967B75-F9E6-4D62-AEE9-C59E8C2C7F33}')!
Term comment: ''!
!Term categoriesForClass!Kernel-Objects! !
Object subclass: #Term
	instanceVariableNames: 'type'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Term
	instanceVariableNames: 'type'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #C
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
C guid: (GUID fromString: '{3BB1F32C-EAB4-4DDF-8F08-09CFABFCC20F}')!
C comment: ''!
!C categoriesForClass!Kernel-Objects! !
Term subclass: #V
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
V guid: (GUID fromString: '{EC35F5AE-BF19-4449-9C3C-2A256F6C6D53}')!
V comment: ''!
!V categoriesForClass!Kernel-Objects! !
Term subclass: #Pair
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Pair guid: (GUID fromString: '{45D4D19E-B9BE-49FC-9732-6116750CDA47}')!
Pair comment: ''!
!Pair categoriesForClass!Kernel-Objects! !
!C class methodsFor!
% value
	^super new type! !
!C class categoriesFor: #%!public! !

Object subclass: #Term
	instanceVariableNames: 'type value'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!C methodsFor!
type: a value: b
	type := a.
	value := b! !
!C categoriesFor: #type:value:!public! !

!C methodsFor!
type: a value: b
	type := a.
	value := b! !
!C categoriesFor: #type:value:!public! !

!C class methodsFor!
% value
	^super new type: 'const' value: value! !
!C class categoriesFor: #%!public! !

!C class methodsFor!
% value
	^super new type: 'const' value: value! !
!C class categoriesFor: #%!public! !

x := C % 7!

x := C % 7a C!

x := C % 7!

!Term methodsFor!
% value! !
!Term categoriesFor: #%!public! !

Term subclass: #Pair
	instanceVariableNames: 'fst snd'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!Pair methodsFor!
car: a cdr: b
	! !
!Pair categoriesFor: #car:cdr:!public! !

!Pair methodsFor!
car: a cdr: b
	fst  := a.
	snd := b! !
!Pair categoriesFor: #car:cdr:!public! !

!Pair methodsFor!
car: a cdr: b
	fst  := a.
	snd := b! !
!Pair categoriesFor: #car:cdr:!public! !

!Pair methodsFor!
car: a cdr: b
	fst  := a.
	snd := b! !
!Pair categoriesFor: #car:cdr:!public! !

!Pair methodsFor!
car: a cdr: b
	fst  := a.
	snd := b! !
!Pair categoriesFor: #car:cdr:!public! !

!Pair methodsFor!
car: a cdr: b
	fst  := a.
	snd := b! !
!Pair categoriesFor: #car:cdr:!public! !

!Pair methodsFor!
car: a cdr: b
	fst  := a.
	snd := b! !
!Pair categoriesFor: #car:cdr:!public! !

!Pair methodsFor!
car: a cdr: b
	fst  := a.
	snd := b! !
!Pair categoriesFor: #car:cdr:!public! !

!Pair methodsFor!
car: a cdr: b
	fst  := a.
	snd := b! !
!Pair categoriesFor: #car:cdr:!public! !

!Pair methodsFor!
car: a cdr: b
	fst  := a.
	snd := b! !
!Pair categoriesFor: #car:cdr:!public! !

!Pair methodsFor!
car: a cdr: b
	fst  := a.
	snd := b! !
!Pair categoriesFor: #car:cdr:!public! !

!Pair methodsFor!
car: a cdr: b
	fst  := a.
	snd := b! !
!Pair categoriesFor: #car:cdr:!public! !

!Pair methodsFor!
car: a cdr: b
	fst  := a.
	snd := b! !
!Pair categoriesFor: #car:cdr:!public! !

!Pair methodsFor!
car: a cdr: b
	fst  := a.
	snd := b! !
!Pair categoriesFor: #car:cdr:!public! !

!Pair methodsFor!
car: a cdr: b
	fst  := a.
	snd := b! !
!Pair categoriesFor: #car:cdr:!public! !

!Pair methodsFor!
car: a cdr: b
	fst  := a.
	snd := b! !
!Pair categoriesFor: #car:cdr:!public! !

!Pair methodsFor!
car: a cdr: b
	fst  := a.
	snd := b! !
!Pair categoriesFor: #car:cdr:!public! !

!Pair methodsFor!
car: a cdr: b
	fst  := a.
	snd := b! !
!Pair categoriesFor: #car:cdr:!public! !

!Term methodsFor!
% value
	^Pair new car: self cdr: (C % value)! !
!Term categoriesFor: #%!public! !

!Term methodsFor!
% value
	^Pair new car: self cdr: (C % value)! !
!Term categoriesFor: #%!public! !

"20:47:33, 17 czerwca 2017: Image saved"!

"20:47:52, 17 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\1\first.img7'"!

x := 7!

y := x.!

c := x!

x := 9!

y!

c!

Term subclass: #V
	instanceVariableNames: 'set'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: 'set'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: 'set'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: 'set'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: 'set'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: 'set'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: 'set'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: 'set'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: 'set'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: 'set'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: 'set'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: 'set'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: 'set'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: ''
	classVariableNames: 'set'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: ''
	classVariableNames: 'Set'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: ''
	classVariableNames: 'Set'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!V class methodsFor!
put: a
	! !
!V class categoriesFor: #put:!public! !

Term subclass: #V
	instanceVariableNames: ''
	classVariableNames: 'Bag'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: ''
	classVariableNames: 'Bag'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: ''
	classVariableNames: 'VarsBag'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: ''
	classVariableNames: 'VarsBag'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!V class methodsFor!
put: a
	VarsBag! !
!V class categoriesFor: #put:!public! !

!V class methodsFor!
at: i put: v
	VarsBag at: i put: v! !
!V class categoriesFor: #at:put:!public! !

!V class methodsFor!
at: i put: v
	VarsBag at: i put: v! !
!V class categoriesFor: #at:put:!public! !

!V class methodsFor!
at: i put: v
	VarsBag at: i put: v! !
!V class categoriesFor: #at:put:!public! !

V class removeSelector: #put: ifAbsent: []!

!V class methodsFor!
@ name
	self at: name put: ''! !
!V class categoriesFor: #@!public! !

Object subclass: #UninitializedVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
UninitializedVar guid: (GUID fromString: '{52206C87-CA57-47A3-B2FF-EBEF8A8D264D}')!
UninitializedVar comment: ''!
!UninitializedVar categoriesForClass!Kernel-Objects! !
!V class methodsFor!
@ name
	self at: name put: (UninitializedVar new)! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	self at: var put: (UninitializedVar new)! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	self at: var put: (UninitializedVar new)! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	self at: var put: (UninitializedVar new)! !
!V class categoriesFor: #@!public! !

"21:16:37, 17 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\2\first.img7'"!

"21:17:06, 17 czerwca 2017: Image saved"!

"21:17:27, 17 czerwca 2017: Dolphin Smalltalk Professional started"!

!V class methodsFor!
@ var
	| tmp |
	tmp := super new 
	self at: var put: (UninitializedVar new)! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar 
	self at: var put: tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar 
	self at: var put: tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

V @ 'aa'!

V @ 7!

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

V at: 7 put: 9!

V at: 7 put: 9!

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	V at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	V at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	V at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	V at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	V at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	V at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	V at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	V at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	V at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	V at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

V @ 7!

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

V @ 7!

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

V at: 1 put: 2!

x := Set new!

x add: 7!

x add: 7!

x find: 7!

7!

7!

7!

7!

x := Bag new!

x add:7!

x add:7!

x occurrencesOf: 7!

x := Dictionary new !

x at: 0 put: #(1,2,3)!

x!

x at: 'a' put: #(1,2)!

x!

x at: #a put: #(1)!

x!

Term subclass: #V
	instanceVariableNames: ''
	classVariableNames: 'VarsDicr'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: ''
	classVariableNames: 'VarsDict'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: ''
	classVariableNames: 'VarsDict'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: ''
	classVariableNames: 'VarsDict'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: ''
	classVariableNames: 'VarsDict'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!V class methodsFor!
at: i put: v
	VarsDict at: i put: v! !
!V class categoriesFor: #at:put:!public! !

!V class methodsFor!
at: i put: v
	VarsDict at: i put: v! !
!V class categoriesFor: #at:put:!public! !

!V class methodsFor!
na: i co: v
	VarsDict at: i put: v! !
!V class categoriesFor: #na:co:!public! !

!V class methodsFor!
na: i co: v
	VarsDict at: i put: v! !
!V class categoriesFor: #na:co:!public! !

V class removeSelector: #at:put: ifAbsent: []!

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self na: var co: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self na: var co: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self na: var co: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self na: var co: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self na: var co: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self na: var co: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

C na: 0 co: 7!

V na: 0 co: 7!

V na: 0 co: 7!

Term subclass: #V
	instanceVariableNames: ''
	classVariableNames: 'VarsDict Count'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: ''
	classVariableNames: 'Count VarsDict'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: ''
	classVariableNames: 'Count VarsDict'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: ''
	classVariableNames: 'Count VarsDict'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!V class methodsFor!
na: i co: v
	(Count == 0) ifTrue: [VarsDict  := Dictionary  new].
	VarsDict at: i put: v! !
!V class categoriesFor: #na:co:!public! !

!V class methodsFor!
na: i co: v
	(Count == 0) ifTrue: [VarsDict  := Dictionary  new].
	VarsDict at: i put: v! !
!V class categoriesFor: #na:co:!public! !

!V class methodsFor!
na: i co: v
	(Count == 0) ifTrue: [VarsDict  := Dictionary  new].
	VarsDict at: i put: v! !
!V class categoriesFor: #na:co:!public! !

!V class methodsFor!
na: i co: v
	(Count == 0) ifTrue: [VarsDict  := Dictionary  new].
	VarsDict at: i put: v! !
!V class categoriesFor: #na:co:!public! !

!V class methodsFor!
na: i co: v
	(Count == 0) ifTrue: [VarsDict  := Dictionary  new].
	VarsDict at: i put: v! !
!V class categoriesFor: #na:co:!public! !

V na: 0 co: 7!

!V class methodsFor!
na: i co: v
	^Count! !
!V class categoriesFor: #na:co:!public! !

V na: 0 co: 7!

!V class methodsFor!
at: i put: v
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	VarsDict at: i put: v! !
!V class categoriesFor: #at:put:!public! !

V class removeSelector: #na:co: ifAbsent: []!

V na: 0 co: 7!

V at: 0 put: 7!

V!

x :=V at: 0 put: 7!

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new type: 'var' value: UninitializedVar.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

x := V @ 'a'!

x := V @ #a!

V @ 'a'!

!V class methodsFor!
@ var
	| tmp |
	tmp := super new.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

V @ 'a'!

x :=V @ 'a'!

x!

!V class methodsFor!
@ var
	| tmp |
	tmp := super new.
	tmp type: 'var' value: UninitializedVar.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new.
	tmp type: 'var' value: UninitializedVar.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new.
	tmp type: 'var' value: UninitializedVar.
	self at: var put: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

x :=V @ 'a'!

Term subclass: #V
	instanceVariableNames: ''
	classVariableNames: 'VarsDict'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: ''
	classVariableNames: 'VarsDict'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!V methodsFor!
type: a value: b
	type := a.
	value := b! !
!V categoriesFor: #type:value:!public! !

!V methodsFor!
type: a value: b
	type := a.
	value := b! !
!V categoriesFor: #type:value:!public! !

!V methodsFor!
type: a value: b
	type := a.
	value := b! !
!V categoriesFor: #type:value:!public! !

!V methodsFor!
type: a value: b
	type := a.
	value := b! !
!V categoriesFor: #type:value:!public! !

!V methodsFor!
type: a value: b
	type := a.
	value := b! !
!V categoriesFor: #type:value:!public! !

!V methodsFor!
type: a value: b
	type := a.
	value := b! !
!V categoriesFor: #type:value:!public! !

!V methodsFor!
type: a value: b
	type := a.
	value := b! !
!V categoriesFor: #type:value:!public! !

!V methodsFor!
type: a value: b
	type := a.
	value := b! !
!V categoriesFor: #type:value:!public! !

!V methodsFor!
type: a value: b
	type := a.
	value := b! !
!V categoriesFor: #type:value:!public! !

x :=V @ 'a'!

x!

!V methodsFor!
isUninitialized
	^(value == UninitializedVar) ifTrue: [true] ifFalse: [false]! !
!V categoriesFor: #isUninitialized!public! !

!V methodsFor!
isUninitialized
	^(value == UninitializedVar) ifTrue: [true] ifFalse: [false]! !
!V categoriesFor: #isUninitialized!public! !

x isUninitialized!

!V class methodsFor!
at: i put: v
	| tmp |
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict 
	VarsDict at: i put: v! !
!V class categoriesFor: #at:put:!public! !

!V class methodsFor!
getVar: var
	^VarsDict at: var! !
!V class categoriesFor: #getVar:!public! !

!V class methodsFor!
getVar: var
	^VarsDict at: var! !
!V class categoriesFor: #getVar:!public! !

x getVar: 'a'!

x := Dictionary new!

x at: 0!

x :=V @ 'a'!

x :=V @ 'a'!

!V class methodsFor!
at: i put: v
	| tmp |
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict at: i
	VarsDict at: i put: v! !
!V class categoriesFor: #at:put:!public! !

"22:14:59, 17 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\3\first.img7'"!

 !

x := Sound new!

x beep!

x := Sound new beep!

x := Sound new beep:10!

"10:05:36, 18 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\niedziela_1\first.img7'"!

!V class methodsFor!
at: i put: v
	| tmp |
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict at: i
	! !
!V class categoriesFor: #at:put:!public! !

!V class methodsFor!
at: i put: v
	| tmp |
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict at: i
	! !
!V class categoriesFor: #at:put:!public! !

x :=V @ 'a'!

x at: 7 put: 9!

!V class methodsFor!
var: i val: v
	| tmp |
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict at: i
	! !
!V class categoriesFor: #var:val:!public! !

V class removeSelector: #at:put: ifAbsent: []!

!V class methodsFor!
@ var
	| tmp |
	tmp := super new.
	tmp type: 'var' value: UninitializedVar.
	self var: var val: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new.
	tmp type: 'var' value: UninitializedVar.
	self var: var val: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

x :=V @ 'a'!

x!

V!

!V class methodsFor!
getVar: var
	^VarsDict! !
!V class categoriesFor: #getVar:!public! !

!V class methodsFor!
getVar: var
	^VarsDict! !
!V class categoriesFor: #getVar:!public! !

!V class methodsFor!
getVar: var
	^VarsDict! !
!V class categoriesFor: #getVar:!public! !

!V class methodsFor!
getVar: var
	^VarsDict! !
!V class categoriesFor: #getVar:!public! !

V getVar: 9!

V var: 9 val: 12!

!V class methodsFor!
var: i val: v
	| tmp |
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict occurrencesOf: i
	! !
!V class categoriesFor: #var:val:!public! !

!V class methodsFor!
var: i val: v
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict occurrencesOf: i.
	(tmp > 0 ) ifTrue: 
			[arr := VarsDict  at: i.
			 ]
			ifFalse:
			[]
	! !
!V class categoriesFor: #var:val:!public! !

!Array class categoriesFor: #odbDeserialize:!OmniBase!private! !

x:= Array new!

x add: 0!

x size!

x resize: 10!

x size0!

x size!

!V class methodsFor!
var: i val: v
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict occurrencesOf: i.
	(tmp > 0 ) ifTrue: 
			[arr := VarsDict  at: i.
			 arr resize: (arr size + 1).
			 arr at: (arr size - 1) put: v
			 ]
			ifFalse:
			[]
	! !
!V class categoriesFor: #var:val:!public! !

x := (1)!

x size!

x := #(1)!

x size!

!V class methodsFor!
var: i val: v
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict occurrencesOf: i.
	(tmp > 0 ) ifTrue: 
			[arr := VarsDict  at: i.
			 arr resize: (arr size + 1).
			 arr at: (arr size - 1) put: v.
			 VarsDict at: i put: arr
			 ]
			ifFalse:
			[]
	! !
!V class categoriesFor: #var:val:!public! !

!V class methodsFor!
var: i val: v
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict occurrencesOf: i.
	(tmp > 0 ) ifTrue: 
			[arr := VarsDict  at: i.
			 arr resize: (arr size + 1).
			 arr at: (arr size - 1) put: v.
			 VarsDict at: i put: arr
			 ]
			ifFalse:
			[VarsDict at: i put: (Array new)]
	! !
!V class categoriesFor: #var:val:!public! !

!V class methodsFor!
var: i val: v
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict occurrencesOf: i.
	(tmp > 0 ) ifTrue: 
			[arr := VarsDict  at: i.
			 arr resize: (arr size + 1).
			 arr at: (arr size - 1) put: v.
			 VarsDict at: i put: arr
			 ]
			ifFalse:
			[VarsDict at: i put: (Array new)]
	! !
!V class categoriesFor: #var:val:!public! !

x := V var: 0 val: 7!

V getVar: 0!

!V class methodsFor!
var: i val: v
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict occurrencesOf: i.
	(tmp > 0 ) ifTrue: 
			[arr := VarsDict  at: i.
			 arr resize: (arr size + 1).
			 arr at: (arr size - 1) put: v.
			 VarsDict at: i put: arr
			 ]
			ifFalse:
			[VarsDict at: i put: (Array new at:0 put: v)]
	! !
!V class categoriesFor: #var:val:!public! !

x := V var: 7 val: 9!

a := Array new!

a at:0 put:1!

!V class methodsFor!
var: i val: v
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict occurrencesOf: i.
	(tmp > 0 ) ifTrue: 
			[arr := VarsDict  at: i.
			 arr resize: (arr size + 1).
			 arr at: (arr size - 1) put: v.
			 VarsDict at: i put: arr
			 ]
			ifFalse:
			[VarsDict at: i put: (Array new:1 at:0 put: v)]
	! !
!V class categoriesFor: #var:val:!public! !

x := V var: 7 val: 9!

!V class methodsFor!
var: i val: v
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict occurrencesOf: i.
	(tmp > 0 ) ifTrue: 
			[arr := VarsDict  at: i.
			 arr resize: (arr size + 1).
			 arr at: (arr size - 1) put: v.
			 VarsDict at: i put: arr
			 ]
			ifFalse:
			[VarsDict at: i put: (Array new:1 at:0 put: v)]
	! !
!V class categoriesFor: #var:val:!public! !

!V class methodsFor!
var: i val: v
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict occurrencesOf: i.
	(tmp > 0 ) ifTrue: 
			[arr := VarsDict  at: i.
			 arr resize: (arr size + 1).
			 arr at: (arr size - 1) put: v.
			 VarsDict at: i put: arr
			 ]
			ifFalse:
			[arr:= Array new:1.
			 VarsDict at: i put: (arr at:0 put: v)
			]
	! !
!V class categoriesFor: #var:val:!public! !

!V class methodsFor!
var: i val: v
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict occurrencesOf: i.
	(tmp > 0 ) ifTrue: 
			[arr := VarsDict  at: i.
			 arr resize: (arr size + 1).
			 arr at: (arr size - 1) put: v.
			 VarsDict at: i put: arr
			 ]
			ifFalse:
			[arr:= Array new:1.
			 VarsDict at: i put: (arr at:0 put: v)
			]
	! !
!V class categoriesFor: #var:val:!public! !

!V class methodsFor!
var: i val: v
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict occurrencesOf: i.
	(tmp > 0 ) ifTrue: 
			[arr := VarsDict  at: i.
			 arr resize: (arr size + 1).
			 arr at: (arr size - 1) put: v.
			 VarsDict at: i put: arr
			 ]
			ifFalse:
			[arr:= Array new:1.
			 VarsDict at: i put: (arr at:0 put: v)
			]
	! !
!V class categoriesFor: #var:val:!public! !

x := V var: 7 val: 9!

arr:= Array new:1!

arr at: 0 put: 1!

arr size!

arr:= Array new:2!

arr size!

arr at: 0 put: 1!

arr at: 1 put: 1!

!V class methodsFor!
var: i val: v
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict occurrencesOf: i.
	(tmp > 0 ) ifTrue: 
			[arr := VarsDict  at: i.
			 arr resize: (arr size + 1).
			 arr at: (arr size - 1) put: v.
			 VarsDict at: i put: arr
			 ]
			ifFalse:
			[arr:= Array new:1.
			 VarsDict at: i put: (arr at:1 put: v)
			]
	! !
!V class categoriesFor: #var:val:!public! !

x := V var: 7 val: 9!

V getVar:0!

x := V var: 7 val: 11!

V getVar:0!

!V class methodsFor!
var: i val: v
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict occurrencesOf: i.
	(tmp > 0 ) ifTrue: 
			[arr := VarsDict  at: i.
			 arr resize: (arr size + 1).
			 arr at: (arr size - 1) put: v.
			 VarsDict at: i put: arr
			 ]
			ifFalse:
			[arr:= Array new:1.
			 VarsDict at: i put: (arr at:1 put: v)].
		^tmp
	! !
!V class categoriesFor: #var:val:!public! !

x := V var: 7 val: 12!

V getVar:0!

x := V var: 7 val: 120!

V getVar:0!

!V class methodsFor!
var: i val: v
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict includesKey: i.
	(tmp > 0 ) ifTrue: 
			[arr := VarsDict  at: i.
			 arr resize: (arr size + 1).
			 arr at: (arr size - 1) put: v.
			 VarsDict at: i put: arr
			 ]
			ifFalse:
			[arr:= Array new:1.
			 VarsDict at: i put: (arr at:1 put: v)].
		^tmp
	! !
!V class categoriesFor: #var:val:!public! !

!V class methodsFor!
var: i val: v
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict includesKey: i.
	(tmp) ifTrue: 
			[arr := VarsDict  at: i.
			 arr resize: (arr size + 1).
			 arr at: (arr size - 1) put: v.
			 VarsDict at: i put: arr
			 ]
			ifFalse:
			[arr:= Array new:1.
			 VarsDict at: i put: (arr at:1 put: v)].
		^tmp
	! !
!V class categoriesFor: #var:val:!public! !

!V class methodsFor!
var: i val: v
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict includesKey: i.
	(tmp) ifTrue: 
			[arr := VarsDict  at: i.
			 arr resize: (arr size + 1).
			 arr at: (arr size - 1) put: v.
			 VarsDict at: i put: arr
			 ]
			ifFalse:
			[arr:= Array new:1.
			 VarsDict at: i put: (arr at:1 put: v)].
		^tmp
	! !
!V class categoriesFor: #var:val:!public! !

x := V var: 7 val: 12!

!V class methodsFor!
reset
	VarsDict new! !
!V class categoriesFor: #reset!public! !

!V class methodsFor!
reset
	VarsDict new! !
!V class categoriesFor: #reset!public! !

V reset!

!V class methodsFor!
reset
	VarsDict:= Dictionary new! !
!V class categoriesFor: #reset!public! !

!V class methodsFor!
reset
	VarsDict:= Dictionary new! !
!V class categoriesFor: #reset!public! !

V reset!

V getVar: 0!

x := V var: 7 val: 12!

V getVar: 0!

x := V var: 7 val: 122!

V reset!

x := V var: 7 val: 12!

x:= Dictionary new!

x at:0 put: (Array new:10)!

x!

x at:0 put: (Array new:1)!

!

x!

x := V var: 7 val: 12!

V reset!

x := V var: 7 val: 12!

V getVar:0!

V getVar:0 at:7!

(V getVar:0) at:7!

(V getVar:0) at:7 size!

!V class methodsFor!
var: i val: v
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict includesKey: i.
	(tmp) ifTrue: 
			[arr := VarsDict  at: i.
			 arr resize: (arr size + 1).
			 arr at: (arr size - 1) put: v.
			 VarsDict at: i put: arr
			 ]
			ifFalse:
			[arr:= Array new:1.
			 (arr at:1 put: v)
			 VarsDict at: i put: arr ].
		^tmp
	! !
!V class categoriesFor: #var:val:!public! !

!V class methodsFor!
var: i val: v
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict includesKey: i.
	(tmp) ifTrue: 
			[arr := VarsDict  at: i.
			 arr resize: (arr size + 1).
			 arr at: (arr size - 1) put: v.
			 VarsDict at: i put: arr
			 ]
			ifFalse:
			[arr:= Array new:1.
			 (arr at:1 put: v).
			 VarsDict at: i put: arr ].
		^tmp
	! !
!V class categoriesFor: #var:val:!public! !

!V class methodsFor!
var: i val: v
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict includesKey: i.
	(tmp) ifTrue: 
			[arr := VarsDict  at: i.
			 arr resize: (arr size + 1).
			 arr at: (arr size - 1) put: v.
			 VarsDict at: i put: arr
			 ]
			ifFalse:
			[arr:= Array new:1.
			 (arr at:1 put: v).
			 VarsDict at: i put: arr ].
		^tmp
	! !
!V class categoriesFor: #var:val:!public! !

V reset!

x := V var: 7 val: 12!

V getVar: 0!

x := V var: 7 val: 122!

V getVar: 0!

!V class methodsFor!
var: i val: v
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict includesKey: i.
	(tmp) ifTrue: 
			[arr := VarsDict  at: i.
			 arr resize: (arr size + 1).
			 arr at: (arr size ) put: v.
			 VarsDict at: i put: arr
			 ]
			ifFalse:
			[arr:= Array new:1.
			 (arr at:1 put: v).
			 VarsDict at: i put: arr ].
		^tmp
	! !
!V class categoriesFor: #var:val:!public! !

x := V var: 7 val: 7!

V getVar: 0!

!V methodsFor!
assign: var val: v
	! !
!V categoriesFor: #assign:val:!public! !

!V methodsFor!
assign: var val: v
	! !
!V categoriesFor: #assign:val:!public! !

!V methodsFor!
assign: val
	value := val! !
!V categoriesFor: #assign:!public! !

Term subclass: #V
	instanceVariableNames: 'addr'
	classVariableNames: 'VarsDict'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: 'addr'
	classVariableNames: 'VarsDict'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!V methodsFor!
type: a value: b addr: c
	type := a.
	value := b! !
!V categoriesFor: #type:value:addr:!public! !

!V methodsFor!
type: a value: b addr: c
	type := a.
	value := b.
	addr:= c! !
!V categoriesFor: #type:value:addr:!public! !

V removeSelector: #type:value: ifAbsent: []!

!V methodsFor!
assign: var val: v
	| bag |
	bag := VarsDict at: var
	bag do: [:item| "do something to item" ]! !
!V categoriesFor: #assign:val:!public! !

!V methodsFor!
assign: var val: v
	| bag |
	bag := VarsDict at: var.
	bag do: [:item| "do something to item"]! !
!V categoriesFor: #assign:val:!public! !

!V methodsFor!
assign: var val: v
	| bag |
	bag := VarsDict at: var.
	bag do: [:item| "do something to item"]! !
!V categoriesFor: #assign:val:!public! !

!V methodsFor!
assign: var val: v
	| bag |
	bag := VarsDict at: var.
	bag do: [:item| item assign: v ]! !
!V categoriesFor: #assign:val:!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new.
	tmp type: 'var' value: UninitializedVar addr: var
	self var: var val: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	| tmp |
	tmp := super new.
	tmp type: 'var' value: UninitializedVar addr: var.
	self var: var val: tmp.
	^tmp! !
!V class categoriesFor: #@!public! !

V reset!

x := V @ 'a'!

x getVar!

V getVar!

V getVar: 0!

x!

x := V @ 'a'!

V getVar: 0!

!V methodsFor!
val
	^value! !
!V categoriesFor: #val!public! !

!V methodsFor!
val
	^value! !
!V categoriesFor: #val!public! !

!V methodsFor!
val
	^value! !
!V categoriesFor: #val!public! !

!V methodsFor!
assignment: v
	| bag |
	bag := VarsDict at: addr.
	bag do: [:item| item assign: v ]! !
!V categoriesFor: #assignment:!public! !

!V methodsFor!
assignment: v
	| bag |
	bag := VarsDict at: addr.
	bag do: [:item| item assign: v ]! !
!V categoriesFor: #assignment:!public! !

!V methodsFor!
assignment: v
	| bag |
	bag := VarsDict at: addr.
	bag do: [:item| item assign: v ]! !
!V categoriesFor: #assignment:!public! !

!V methodsFor!
= v
	| bag |
	bag := VarsDict at: addr.
	bag do: [:item| item assign: v ]! !
!V categoriesFor: #=!public! !

!V methodsFor!
= v
	| bag |
	bag := VarsDict at: addr.
	bag do: [:item| item assign: v ]! !
!V categoriesFor: #=!public! !

V reset!

x := V @ #a!

y := V @ #a!

x val!

y val!

x = 7!

x val!

y val!

"10:56:33, 18 czerwca 2017: Image saved"!

"10:56:36, 18 czerwca 2017: Image saved"!

"10:56:39, 18 czerwca 2017: Image saved"!

"10:56:50, 18 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\niedziela_@\first.img7'"!

Term subclass: #Pair
	instanceVariableNames: 'car cdr'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #Pair
	instanceVariableNames: 'car cdr'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!Pair methodsFor!
car: a cdr: b
	car  := a.
	cdr := b! !
!Pair categoriesFor: #car:cdr:!public! !

!Pair methodsFor!
car: a cdr: b
	car  := a.
	cdr := b! !
!Pair categoriesFor: #car:cdr:!public! !

!Term methodsFor!
@ value
	^Pair new car: self cdr: (C % value)! !
!Term categoriesFor: #@!public! !

!Term methodsFor!
@ value
	^Pair new car: self cdr: (C % value)! !
!Term categoriesFor: #@!public! !

!Term methodsFor!
@ var
	^Pair new car: self cdr: (V % var)! !
!Term categoriesFor: #@!public! !

!Term methodsFor!
@ var
	^Pair new car: self cdr: (V % var)! !
!Term categoriesFor: #@!public! !

!Term methodsFor!
@ var
	^Pair new car: self cdr: (V @ var)! !
!Term categoriesFor: #@!public! !

!Term methodsFor!
, term
	^ Pair new car: self cdr: term! !
!Term categoriesFor: #,!public! !

!Term methodsFor!
, term
	^ Pair new car: self cdr: term! !
!Term categoriesFor: #,!public! !

!Term methodsFor!
, term
	^ Pair new car: self cdr: term! !
!Term categoriesFor: #,!public! !

c1 := C % 1!

x := Dictionary new!

x := Dictionary new!

x!

x!

!Term methodsFor!
print
	^ value! !
!Term categoriesFor: #print!public! !

!Term methodsFor!
print
	^ value! !
!Term categoriesFor: #print!public! !

!Term methodsFor!
print
	^ value! !
!Term categoriesFor: #print!public! !

!Term methodsFor!
print
	^ value! !
!Term categoriesFor: #print!public! !

!Term methodsFor!
print
	^ value! !
!Term categoriesFor: #print!public! !

c1 := C % 1!

c1!

c1 print!

c2 := C % 1!

c2 print!

c1 print!

t := c1 , c2!

t!

t := c1 % 2!

t!

t := c1 @ #a!

t!

Smalltalk at: #L put: (C % nil)!

L!

!Term methodsFor!
value
	^ value! !
!Term categoriesFor: #value!public! !

!Term methodsFor!
value
	^ value! !
!Term categoriesFor: #value!public! !

!Pair methodsFor!
value
	^Pair new! !
!Pair categoriesFor: #value!public! !

!Pair methodsFor!
car
	^car! !
!Pair categoriesFor: #car!public! !

!Pair methodsFor!
cdr
	^cdr! !
!Pair categoriesFor: #cdr!public! !

!Pair methodsFor!
cdr
	^cdr! !
!Pair categoriesFor: #cdr!public! !

!Pair methodsFor!
value
	^Pair new car: self car value cdr: self cdr value! !
!Pair categoriesFor: #value!public! !

!Pair methodsFor!
value
	^Pair new car: self car value cdr: self cdr value! !
!Pair categoriesFor: #value!public! !

!Pair methodsFor!
value
	^Pair new car: self car value cdr: self cdr value! !
!Pair categoriesFor: #value!public! !

!V methodsFor!
val
	^value! !
!V categoriesFor: #val!public! !

!V methodsFor!
value
	(self isUninitialized) ifTrue: [] ifFalse: []! !
!V categoriesFor: #value!public! !

!V methodsFor!
value
	(self isUninitialized) ifTrue: [^self error] ifFalse: []! !
!V categoriesFor: #value!public! !

!V methodsFor!
value
	(self isUninitialized) ifTrue: [^self error] ifFalse: []! !
!V categoriesFor: #value!public! !

!V methodsFor!
value
	(self isUninitialized) ifTrue: [^Error] ifFalse: []! !
!V categoriesFor: #value!public! !

!V methodsFor!
value
	(self isUninitialized) ifTrue: [^Error] ifFalse: [^value]! !
!V categoriesFor: #value!public! !

!V methodsFor!
value
	(self isUninitialized) ifTrue: [^Error] ifFalse: [^value]! !
!V categoriesFor: #value!public! !

!V methodsFor!
value
	(self isUninitialized) ifTrue: [^Error] ifFalse: [^value]! !
!V categoriesFor: #value!public! !

!V methodsFor!
value
	(self isUninitialized) ifTrue: [^Error] ifFalse: [^value]! !
!V categoriesFor: #value!public! !

!V methodsFor!
value
	(self isUninitialized) ifTrue: [^Error] ifFalse: [^value]! !
!V categoriesFor: #value!public! !

v1 := V @ #a!

v1 value!

v1 = 7!

v1 value!

t := L % 1, (V @ 2 % 3).!

t!

self assert: [t car car value isNil].!

self assert: [t car cdr value = 1].!

self assert: [t car cdr value = 1].!

self assert: [t car car value isNil].!

self assert: [t car value car isNil].!

self assert: [t car value cdr = 1].!

self assert: [t cdr cdr value = 3].!

self assert: [t cdr cdr value = 7].nil!

"11:21:57, 18 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\niedziela_3\niedziela_3.img7'"!

a := V @ 1.!

b := V @ 2.!

c := V @ 1.!

self assert: [a ~= b].!

a := V @ 1.!

b := V @ 2.!

c := V @ 1.!

self assert: [a ~= b].!

b!

self assert: [a == c].!

self assert: [a ~= b].!

a!

b!

a!

c!

b := V @ 2.!

b!

self assert: [a ~= b].!

c1!


c1 == c2!

c1 == c1!

c2 = c1!

c2 := c1!

c2 == c1!

c1!

c2!

c2
!

c1 = C % 7!

c1 := C % 7!

c1!

c1 == c2!

!Term methodsFor!
== t
	^ self value == t value! !
!Term categoriesFor: #==!public! !

!Term methodsFor!
== t
	^ self value == t value! !
!Term categoriesFor: #==!public! !

!Term methodsFor!
== t
	^ self value == t value! !
!Term categoriesFor: #==!public! !

Term removeSelector: #== ifAbsent: []!

Object subclass: #Term
	instanceVariableNames: 'type value'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

x := 7!

y := x!

z := x!

x == y!

7 == y!

x == y!

x = y!

y = 7!

y := 9!

y = 7!

y = x!

y == x!

x := 7!

y := x deepCopy!

x := 9!

y!

y := x veryDeepCopy!

y := x veryDeepCopy!

c1 := C % 1!

c2:= C % 1!

c3 := c2!

c2!

a := V @ 1.!

b := V @ 2.!

c := V @ 1.!

V getVar!

V getVar: 0!

V reset!

a := V @ 1.!

b := V @ 2.!

c := V @ 1.!

V getVar: 0!

a == b!

a == c!

a = c!

a = c!

a == c!

a!

a value!

a type!

a!

a := V @ 1!

a  yourAddress!

b:= a!

!

b  yourAddress!

b assign: 7!

b  yourAddress!

b value!

a value!

"12:08:33, 18 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\zmiana\zmiana.img7'"!

!V class methodsFor!
var: i
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict includesKey: i.
	(tmp) ifTrue: 
			[VarsDict at:i]
			ifFalse:
			[VarsDict at: i put: UninitializedVar ].
		^tmp
	! !
!V class categoriesFor: #var:!public! !

!V class methodsFor!
var: i
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict includesKey: i.
	(tmp) ifTrue: 
			[VarsDict at:i]
			ifFalse:
			[VarsDict at: i put: UninitializedVar ].
		^tmp
	! !
!V class categoriesFor: #var:!public! !

!V class methodsFor!
var: i
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict includesKey: i.
	(tmp) ifTrue: 
			[VarsDict at:i]
			ifFalse:
			[VarsDict at: i put: UninitializedVar ].
	! !
!V class categoriesFor: #var:!public! !

!V class methodsFor!
var: i
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict includesKey: i.
	(tmp) ifTrue: 
			[arr := VarsDict at:i]
			ifFalse:
			[arr :=VarsDict at: i put: UninitializedVar ].
	^arr
	! !
!V class categoriesFor: #var:!public! !

!V class methodsFor!
var: i
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict includesKey: i.
	(tmp) ifTrue: 
			[arr := VarsDict at:i]
			ifFalse:
			[arr :=VarsDict at: i put: UninitializedVar ].
	^arr
	! !
!V class categoriesFor: #var:!public! !

!V class methodsFor!
var: i
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict includesKey: i.
	(tmp) ifTrue: 
			[arr := VarsDict at:i]
			ifFalse:
			[arr :=VarsDict at: i put: UninitializedVar].
	^arr
	! !
!V class categoriesFor: #var:!public! !

!V class methodsFor!
@ var
	^self var: var! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	^self var: var! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	^self var: var! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	^self var: var! !
!V class categoriesFor: #@!public! !

!V class methodsFor!
@ var
	^self var: var! !
!V class categoriesFor: #@!public! !

v1 := V @ 1!

V reset!

v1 := V @ 1!

v2 := V @ 1!

v1 == v2!

v1 value!

v1 value!

!V class methodsFor!
var: i
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict includesKey: i.
	(tmp) ifTrue: 
			[arr := VarsDict at:i]
			ifFalse:
			[arr :=VarsDict at: i put: (V new)].
	^arr
	! !
!V class categoriesFor: #var:!public! !

!V class methodsFor!
var: i
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict includesKey: i.
	(tmp) ifTrue: 
			[arr := VarsDict at:i]
			ifFalse:
			[arr :=VarsDict at: i put: (V new type: 'var' value: UninitializedVar addr: i )].
	^arr
	! !
!V class categoriesFor: #var:!public! !

!V class methodsFor!
var: i
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict includesKey: i.
	(tmp) ifTrue: 
			[arr := VarsDict at:i]
			ifFalse:
			[arr :=VarsDict at: i put: (V new type: 'var' value: UninitializedVar addr: i )].
	^arr
	! !
!V class categoriesFor: #var:!public! !

!V class methodsFor!
var: i
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict includesKey: i.
	(tmp) ifTrue: 
			[arr := VarsDict at:i]
			ifFalse:
			[arr :=VarsDict at: i put: (V new type: 'var' value: UninitializedVar addr: i )].
	^arr
	! !
!V class categoriesFor: #var:!public! !

!V class methodsFor!
var: i
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict includesKey: i.
	(tmp) ifTrue: 
			[arr := VarsDict at:i]
			ifFalse:
			[arr :=VarsDict at: i put: (V new type: 'var' value: UninitializedVar addr: i )].
	^arr
	! !
!V class categoriesFor: #var:!public! !

!V class methodsFor!
var: i
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict includesKey: i.
	(tmp) ifTrue: 
			[arr := VarsDict at:i]
			ifFalse:
			[arr :=VarsDict at: i put: (V new type: 'var' value: UninitializedVar addr: i )].
	^arr
	! !
!V class categoriesFor: #var:!public! !

V reset!

v1 := V @ 1!

v2 := V @ 1!

v1 == v2!

v1 assignment: 7!

v1 assignment: 7!

v1!

!V methodsFor!
assignment: v
	value := v! !
!V categoriesFor: #assignment:!public! !

v1 assignment: 7!

v1 value!

v2 value!

!V methodsFor!
= v
	value := v! !
!V categoriesFor: #=!public! !

V removeSelector: #assignment: ifAbsent: []!

V removeSelector: #assign:val: ifAbsent: []!

V removeSelector: #assign: ifAbsent: []!

!V methodsFor!
value: b addr: c
	type := 'var'.
	value := b.
	addr:= c! !
!V categoriesFor: #value:addr:!public! !

!V class methodsFor!
var: i
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict includesKey: i.
	(tmp) ifTrue: 
			[arr := VarsDict at:i]
			ifFalse:
			[arr :=VarsDict at: i put: (V new value: UninitializedVar addr: i )].
	^arr
	! !
!V class categoriesFor: #var:!public! !

V class removeSelector: #var:val: ifAbsent: []!

V reset!

t := L % 1, (V @ 2 % 3).!

self assert: [t car car value isNil].!

self assert: [t car cdr value = 1].!

self assert: [t car value car isNil].!

self assert: [t car value cdr = 1].!

self assert: [t cdr cdr value = 3].!

a := V @ 1.!

b := V @ 2.!

c := V @ 1.!

self assert: [a ~= b].!

a := V @ 1.!

b := V @ 2.!

c := V @ 1.!

self assert: [a ~= b].!

a := V @ 1.!

a value!

self assert: [a value ~= b value].!

a yourAddress!

b yourAddress!

c yourAddress!

a == c!

self assert: [a == c].!

a ~= b!

self assert: [a ~= b].!

b yourAddress62003840!

a == c!

self assert: [a == c].!

self assert: [a ~= b].!

a value!

a value value!

a == c!

a == b!

a ~= b!

a = b!

a V!

a == b!

!V methodsFor!
is: v
	value := v! !
!V categoriesFor: #is:!public! !

V removeSelector: #= ifAbsent: []!

a := V @ 1.!

b := V @ 2.!

c := V @ 1.!

self assert: [a ~= b].!

self assert: [a == c].!

t := L % 1, (V @ 2 % 3).!

self assert: [t car car value isNil].!

self assert: [t car car value isNil].nil
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].!

self assert: [t car cdr value = 1].!

self assert: [t car value car isNil].!

self assert: [t car value car isNil].!

self assert: [t cdr cdr value = 3].!

self assert: [t car value cdr = 1].!

t car!

!Pair methodsFor!
printString
	^ self car ! !
!Pair categoriesFor: #printString!public! !

!Pair methodsFor!
asString
	^ self car ! !
!Pair categoriesFor: #asString!public! !

!Pair methodsFor!
asString
	^ self car asString! !
!Pair categoriesFor: #asString!public! !

!Pair methodsFor!
asString
	^ self car asString! !
!Pair categoriesFor: #asString!public! !

t!

t!

t!

!C methodsFor!
asString
	^ self value! !
!C categoriesFor: #asString!public! !

!C methodsFor!
asString
	^ self value! !
!C categoriesFor: #asString!public! !

!C methodsFor!
asString
	^ self value asString! !
!C categoriesFor: #asString!public! !

!V methodsFor!
asString
	^ self value asString! !
!V categoriesFor: #asString!public! !

!V methodsFor!
asString
	^ self value asString! !
!V categoriesFor: #asString!public! !

t!

v1 := V @ 1!

v1 is: 7!

v1!

!V methodsFor!
printString
	^ self asString! !
!V categoriesFor: #printString!public! !

!V methodsFor!
printString
	^ self asString! !
!V categoriesFor: #printString!public! !

v1!

7 asString!

!V methodsFor!
printString
	^ value! !
!V categoriesFor: #printString!public! !

v1!

!V methodsFor!
printString
	^ 7! !
!V categoriesFor: #printString!public! !

v1
!

v1!

v1 basicPrintNl!

V removeSelector: #printString ifAbsent: []!

Pair removeSelector: #printString ifAbsent: []!

Pair removeSelector: #asString ifAbsent: []!

V removeSelector: #asString ifAbsent: []!

C removeSelector: #asString ifAbsent: []!

!Term methodsFor!
print
	^ value! !
!Term categoriesFor: #print!public! !

v1 basicPrintNl!

t := L % 1, (V @ 2 % 3).a Pair!

t := L % 1, (V @ 2 % 3).!

self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].!

self assert: [t car value cdr = 1].!

self assert: [t car value car isNil].!

self assert: [t car cdr value = 1].!

self assert: [t car car value isNil].!

v1 := V @ 1!

v1 value!

v2 := V @ 2!

v2 value!

V reset!

a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].
!

t := C % 1 @ #z.
self assert: [t car value = 1].!

t!

w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].!

t value!

t value!

t value!

t value!

a Pair!

p := t value!

p!

w := 0.!

[t value] on: Error do: [:ex | w := w + 1].!

[t value]!

!Pair methodsFor!
value
	| tmp fst snd |
	fst := self car value.
	Pair new car: self car value cdr: self cdr value! !
!Pair categoriesFor: #value!public! !

!V methodsFor!
value
	(self isUninitialized) ifTrue: [self error] ifFalse: [^value]! !
!V categoriesFor: #value!public! !

!V methodsFor!
value
	(self isUninitialized) ifTrue: [self error] ifFalse: [^value]! !
!V categoriesFor: #value!public! !

a value!

!V methodsFor!
addr: c
	type := 'var'.
	addr:= c! !
!V categoriesFor: #addr:!public! !

!V methodsFor!
addr: c
	type := 'var'.
	addr:= c! !
!V categoriesFor: #addr:!public! !

!V class methodsFor!
var: i
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict includesKey: i.
	(tmp) ifTrue: 
			[arr := VarsDict at:i]
			ifFalse:
			[arr :=VarsDict at: i put: (V new addr: i )].
	^arr
	! !
!V class categoriesFor: #var:!public! !

!V class methodsFor!
var: i
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new].
	tmp := VarsDict includesKey: i.
	(tmp) ifTrue: 
			[arr := VarsDict at:i]
			ifFalse:
			[arr :=VarsDict at: i put: (V new addr: i )].
	^arr
	! !
!V class categoriesFor: #var:!public! !

!V methodsFor!
isUninitialized
	^(value == nil) ifTrue: [true] ifFalse: [false]! !
!V categoriesFor: #isUninitialized!public! !

!V methodsFor!
isUninitialized
	^(value == nil) ifTrue: [true] ifFalse: [false]! !
!V categoriesFor: #isUninitialized!public! !

!V methodsFor!
isUninitialized
	^(value == nil) ifTrue: [true] ifFalse: [false]! !
!V categoriesFor: #isUninitialized!public! !

V reset!

v1 := V @ 1!

v1!

v1 value!

!V methodsFor!
value
	^value value! !
!V categoriesFor: #value!public! !

!V methodsFor!
value
	^value value! !
!V categoriesFor: #value!public! !

!V methodsFor!
value
	^value value! !
!V categoriesFor: #value!public! !

v1 value!

!V methodsFor!
value
	^value! !
!V categoriesFor: #value!public! !

v1 value!

V reset!

t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].!

t := L % 1, (V @ 2 % 3).!

self assert: [t car car value isNil].!

self assert: [t car cdr value = 1].!

self assert: [t car value car isNil].!

t!

V removeSelector: #value ifAbsent: []!

V removeSelector: #value:addr: ifAbsent: []!

V removeSelector: #type:value:addr: ifAbsent: []!

V reset!

t := L % 1, (V @ 2 % 3).!

self assert: [t car car value isNil].nil!

self assert: [t car car value isNil].!

self assert: [t car cdr value = 1].!

self assert: [t car value car isNil].!

t!

t := L % 1!

!Pair methodsFor!
value
	^Pair new car: self car value cdr: self cdr value! !
!Pair categoriesFor: #value!public! !

V reset!

t := L % 1, (V @ 2 % 3).a Pair!

V reset!

t := L % 1, (V @ 2 % 3)!

V reset!

t := L % 1, (V @ 2 % 3)!

self assert: [t car car value isNil].!

self assert: [t car cdr value = 1].!

self assert: [t car value car isNil].!

self assert: [t car value cdr = 1].!

self assert: [t cdr cdr value = 3].!

v1 := V @ 7!

v1 value!

!V methodsFor!
value
	^ value value! !
!V categoriesFor: #value!public! !

v1 value!

t := C % 1 @ #z.!

self assert: [t car value = 1].!

w := 0.!

[t value] on: Error do: [:ex | w := w + 1].!

self assert: [w = 1].!

a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].!

!Term methodsFor!
go: t do: action! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
go: t do: action
	! !
!Term categoriesFor: #go:do:!public! !

anArray := #(1 2 3 4).
anotherArray := #(5 6 7).
anArray, anotherArray!

!Pair methodsFor!
getVarsList
	^self car getVarsList, self cdr getVarsList! !
!Pair categoriesFor: #getVarsList!public! !

!C methodsFor!
getVarsList
	^nil! !
!C categoriesFor: #getVarsList!public! !

!C methodsFor!
getVarsList
	^nil! !
!C categoriesFor: #getVarsList!public! !

anArray, nil!

anArray, #()!

!C methodsFor!
getVarsList
	^#()! !
!C categoriesFor: #getVarsList!public! !

!V methodsFor!
getVarsList
	^self! !
!V categoriesFor: #getVarsList!public! !

!V methodsFor!
getVarsList
	^self! !
!V categoriesFor: #getVarsList!public! !

comp := V @ #x, ((V @ #z, V @ #y), (V @ #q))!

comp!

comp getVarsList!

comp getVarsList!

comp!

!Pair methodsFor!
car: a cdr: b
	type := 'pair'.
	car  := a.
	cdr := b! !
!Pair categoriesFor: #car:cdr:!public! !

V reset!

comp := V @ #x, ((V @ #z, V @ #y), (V @ #q))!

comp!

V reset!

comp := V @ #x, ((V @ #z @ #y), (V @ #q))!

comp!

V reset!

comp := V @ #x, (((V @ #z), (V @ #y)), (V @ #q))!

comp!

comp getVarsList!

co := comp getVarsList!

co!

!V methodsFor!
getVarsList
	^#(self)! !
!V categoriesFor: #getVarsList!public! !

co := comp getVarsLista Pair!

co := comp getVarsLista!

co := comp getVarsList!

co!

!V methodsFor!
getVarsList
	| tmp |
	tmp := self.
	^#(self)! !
!V categoriesFor: #getVarsList!public! !

!V methodsFor!
getVarsList
	| tmp |
	tmp := self.
	^#(tmp)! !
!V categoriesFor: #getVarsList!public! !

!V methodsFor!
getVarsList
	| tmp |
	tmp := self.
	^#(tmp)! !
!V categoriesFor: #getVarsList!public! !

co := comp getVarsList!

!V methodsFor!
getVarsList
	^ Array new: 1 at:1 put: self! !
!V categoriesFor: #getVarsList!public! !

!V methodsFor!
getVarsList
	| tmp |
	^ Array new: 1 at:1 put: self! !
!V categoriesFor: #getVarsList!public! !

!V methodsFor!
getVarsList
	| tmp |
	tmp := Array new: 1.
	^ tmp at:1 put: self! !
!V categoriesFor: #getVarsList!public! !

!V methodsFor!
getVarsList
	| tmp |
	tmp := Array new: 1.
	^ tmp at:1 put: self! !
!V categoriesFor: #getVarsList!public! !

!V methodsFor!
getVarsList
	| tmp |
	tmp := Array new: 1.
	^ tmp at:1 put: self! !
!V categoriesFor: #getVarsList!public! !

co := comp getVarsList!

!C methodsFor!
getVarsList
	^ Array new! !
!C categoriesFor: #getVarsList!public! !

comp!

co := comp getVarsList!

co!

!V methodsFor!
getVarsList
	| tmp |
	tmp := Array new: 1.
	tmp at:1 put: self.
	^ tmp! !
!V categoriesFor: #getVarsList!public! !

!V methodsFor!
getVarsList
	| tmp |
	tmp := Array new: 1.
	tmp at:1 put: self.
	^ tmp! !
!V categoriesFor: #getVarsList!public! !

co := comp getVarsList!

co!

co!

co indexOf: (V @ #x)!

co indexOf: (V @ #y)!

co indexOf: (V @ #t)!

!Pair methodsFor!
asList
	| tmp |
	tmp := Array new: 2.
	tmp at:1 put: (self car).
	tmp at:2 put: (self cdr)
	! !
!Pair categoriesFor: #asList!public! !

!Pair methodsFor!
asList
	| tmp |
	tmp := Array new: 2.
	tmp at:1 put: (self car).
	tmp at:2 put: (self cdr).
	^ tmp
	! !
!Pair categoriesFor: #asList!public! !

!Pair methodsFor!
asList
	| tmp |
	tmp := Array new: 2.
	tmp at:1 put: (self car).
	tmp at:2 put: (self cdr).
	^ tmp
	! !
!Pair categoriesFor: #asList!public! !

!Pair methodsFor!
asList
	| tmp |
	tmp := Array new: 2.
	tmp at:1 put: (self car).
	tmp at:2 put: (self cdr).
	^ tmp
	! !
!Pair categoriesFor: #asList!public! !

Object subclass: #Matcher
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Matcher guid: (GUID fromString: '{D4EF1C87-914A-43CC-9C1B-317AE6A08EA4}')!
Matcher comment: ''!
!Matcher categoriesForClass!Kernel-Objects! !
"16:51:52, 18 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\matcher\zmiana.img7'"!

Object subclass: #Matcher
	instanceVariableNames: 'Container'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

s := Set new!

s add: t!

s!

s add: comp!

s!

s!

s!

s anyOne!

s!

s remove: t!

s!

s add:t!

s!

[s remove: (s anyOne)] whileFalse: [s isEmpty]!

s isEmpty!

true not!

[s isEmpty not] whileTrue:  [s remove: (s anyOne)] !

s!

self assert: [t car value cdr = 1].nil!

1!

s add: comp!

s add: t!

i :=0!

[s isEmpty not. i:= i + 1.i] whileTrue:  [s remove: (s anyOne)]!

[s isEmpty not] whileTrue:  [s remove: (s anyOne). i:= i + 1.i]!

Transcript show: ((i*2) asString)!

Transcript show: (0)!

Transcript show: 0!

i:=5.!

Transcript show: ((i*2) asString) ; cr.!

Transcript show: ((i*2) printString)!

i :=7!

Transcript show: ((i*2) printString)a TranscriptShell!

Transcript show: ((i*2) printString)!

[s isEmpty not] whileTrue:  [s remove: (s anyOne). i:= i + 1.i]!

s add:t!

s add:comp!

[s isEmpty not] whileTrue:  [s remove: (s anyOne). i:= i + 1.Transcript show: ((i) printString)]!

i:=0!

s add:t!

s add:comp!

[s isEmpty not] whileTrue:  [s remove: (s anyOne). i:= i + 1.Transcript show: ((i) printString)]!

!Matcher methodsFor!
iterate
	[Container isEmpty not] whileTrue:  
		[
			|tmp addition|
			tmp := Container anyOne.
			addition :=  self chooseAction tmp.
			
		]! !
!Matcher categoriesFor: #iterate!public! !

!Matcher methodsFor!
iterate
	[Container isEmpty not] whileTrue:  
		[
			|tmp addition|
			tmp := Container anyOne.
			addition :=  self chooseAction tmp.
			Container addAll: addition
		]! !
!Matcher categoriesFor: #iterate!public! !

!Matcher methodsFor!
chooseAction
	^Array new! !
!Matcher categoriesFor: #chooseAction!public! !

!Matcher methodsFor!
chooseAction
	^Array new! !
!Matcher categoriesFor: #chooseAction!public! !

!Matcher methodsFor!
iterate
	[Container isEmpty not] whileTrue:  
		[
			|tmp addition|
			tmp := Container anyOne.
			addition :=  self chooseAction tmp.
			Container addAll: addition
		]! !
!Matcher categoriesFor: #iterate!public! !

!Matcher methodsFor!
iterate
	[Container isEmpty not] whileTrue:  
		[
			|tmp addition|
			tmp := Container anyOne.
			addition :=  self chooseAction tmp.
			Container addAll: addition
		]! !
!Matcher categoriesFor: #iterate!public! !

!Matcher methodsFor!
iterate
	[Container isEmpty not] whileTrue:  
		[
			|tmp addition|
			tmp := Container anyOne.
			addition :=  self chooseAction: tmp.
			Container addAll: addition
		]! !
!Matcher categoriesFor: #iterate!public! !

!Matcher methodsFor!
chooseAction: bag
	^Array new! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: bag
	^Array new! !
!Matcher categoriesFor: #chooseAction:!public! !

Matcher removeSelector: #chooseAction ifAbsent: []!

!Matcher methodsFor!
iterate
	[Container isEmpty not] whileTrue:  
		[
			|tmp addition|
			tmp := Container anyOne.
			addition :=  self chooseAction: tmp.
			Container addAll: addition
		]! !
!Matcher categoriesFor: #iterate!public! !

test := Matcher new!

!Matcher methodsFor!
iterate: what
	Container := Set new.
	Container add: what.
	[Container isEmpty not] whileTrue:  
		[
			|tmp addition|
			tmp := Container anyOne.
			addition :=  self chooseAction: tmp.
			Container addAll: addition
		]! !
!Matcher categoriesFor: #iterate:!public! !

co:= Set new!

co add:  t!

test iterate: t!

"17:22:42, 18 czerwca 2017: Dolphin Smalltalk Professional started"!

"17:23:24, 18 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\matcher2\matcher2.img7'"!

Object subclass: #Matcher
	instanceVariableNames: 'container'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Matcher
	instanceVariableNames: 'container'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Matcher
	instanceVariableNames: 'container'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!Matcher methodsFor!
iterate: what
	container := Set new.
	container add: what.
	[container isEmpty not] whileTrue: 
		[
			| tmp addition |
			tmp := container anyOne.
			addition := self chooseAction: tmp
		]! !
!Matcher categoriesFor: #iterate:!public! !

!Matcher methodsFor!
iterate: what
	container := Set new.
	container add: what.
	[container isEmpty not] whileTrue: 
		[
			| tmp addition |
			tmp := container anyOne.
			addition := self chooseAction: tmp.
			container remove: tmp.
			container addAll: addition
		]! !
!Matcher categoriesFor: #iterate:!public! !

!Matcher methodsFor!
chooseAction: term
	^Set new! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: term
	^Set new! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
iterate: what
	container := Set new.
	container add: what.
	[container isEmpty not] whileTrue: 
		[
			| tmp addition |
			tmp := container anyOne.
			addition := self chooseAction: tmp.
			container remove: tmp.
			container addAll: addition
		]! !
!Matcher categoriesFor: #iterate:!public! !

"17:27:10, 18 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\matcher3\matcher3.img7'"!

Smalltalk at: #L put: (C % nil)!

t := L % 1, (V @ 2 % 3).!

x := C % 1 @ #z.!

test := Matcher new!

s := Set new!

s add: t!

test iterate: s!

!Matcher methodsFor!
iterate: what
	container := Set new.
	container add: what.
	[container isEmpty not] whileTrue: 
		[
			| tmp addition |
			tmp := container anyOne.
			addition := self chooseAction: tmp.
			container remove: tmp.
			container addAll: addition
		].
	^container! !
!Matcher categoriesFor: #iterate:!public! !

test iterate: s!

s!

z := Set new!

a := V @ 1.!

z add: a!

z!

s addAll: z!

s!

!Matcher methodsFor!
chooseAction: terms
	^Set new! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst == snd) ifTrue: [^Set new]! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst == snd) ifTrue: [^Set new]! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst == snd) ifTrue: [^Set new].
	^7! !
!Matcher categoriesFor: #chooseAction:!public! !

terms := Pair new!

b := V @ 2.!

terms car: a cdr: b!

test chooseAction: terms!

c := V @ 1.!

p := Pair new!

p car: a cdr: c!

test chooseAction: p!

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst == snd) ifTrue: [^Set new].
	((fst == Pair) & (snd ~= Pair)) ifTrue: [^7].! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst == snd) ifTrue: [^Set new].
	((fst == Pair) & (snd ~= Pair)) ifTrue: [^Error].! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst == snd) ifTrue: [^Set new].
	((fst == Pair) & (snd ~= Pair)) ifTrue: [^Error].
	((snd == Pair) & (fst ~= Pair)) ifTrue: [^Error].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst == snd) ifTrue: [^Set new].
	((fst == Pair) & (snd ~= Pair)) ifTrue: [^Error].
	((snd == Pair) & (fst ~= Pair)) ifTrue: [^Error].
	((fst == Pair) & (snd == Pair)) ifTrue: [^self makePairs: (fst asList) snd:(snd asList)].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
makePairs: t1 snd: t2
	! !
!Matcher categoriesFor: #makePairs:snd:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst == snd) ifTrue: [^Set new].
	((fst == Pair) & (snd ~= Pair)) ifTrue: [^Error].
	((snd == Pair) & (fst ~= Pair)) ifTrue: [^Error].
	((fst == Pair) & (snd == Pair)) ifTrue: [^self makePairs: (fst asList) snd:(snd asList)].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
makePairs: t1 snd: t2
	| fst1 fst2 snd1 snd2 |
	fst1 := t1 car.
	fst2 := t2 car.
	snd1 := t1 cdr.
	snd2 := t2 cdr.! !
!Matcher categoriesFor: #makePairs:snd:!public! !

!Matcher methodsFor!
makePairs: t1 snd: t2
	| fst1 fst2 snd1 snd2 p1 p2  s|
	fst1 := t1 car.
	fst2 := t2 car.
	snd1 := t1 cdr.
	snd2 := t2 cdr.
	p1 := Pair new car: fst1 cdr: fst2.
	p2 := Pair new car: snd1 cdr: snd2.
	s := Set new.
	s add: p1.
	s add: p2.
	^ s
	
	! !
!Matcher categoriesFor: #makePairs:snd:!public! !

"17:49:05, 18 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\matche_ok\matcher.img7'"!

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst == snd) ifTrue: [^Set new].
	((fst == Pair) & (snd ~= Pair)) ifTrue: [^Error].
	((snd == Pair) & (fst ~= Pair)) ifTrue: [^Error].
	((fst == Pair) & (snd == Pair)) ifTrue: [^self makePairs: fst snd: snd].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst == snd) ifTrue: [^Set new].
	((fst == Pair) & (snd ~= Pair)) ifTrue: [^Error].
	((snd == Pair) & (fst ~= Pair)) ifTrue: [^Error].
	((fst == Pair) & (snd == Pair)) ifTrue: [^self makePairs: fst snd: snd].
	((fst ~= V) & (snd == V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is fst]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst == snd) ifTrue: [^Set new].
	((fst == Pair) & (snd ~= Pair)) ifTrue: [^Error].
	((snd == Pair) & (fst ~= Pair)) ifTrue: [^Error].
	((fst == Pair) & (snd == Pair)) ifTrue: [^self makePairs: fst snd: snd].
	((fst ~= V) & (snd == V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is fst]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst == snd) ifTrue: [^Set new].
	((fst == Pair) & (snd ~= Pair)) ifTrue: [^Error].
	((snd == Pair) & (fst ~= Pair)) ifTrue: [^Error].
	((fst == Pair) & (snd == Pair)) ifTrue: [^self makePairs: fst snd: snd].
	((fst ~= V) & (snd == V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst == snd) ifTrue: [^Set new].
	((fst == Pair) & (snd ~= Pair)) ifTrue: [^Error].
	((snd == Pair) & (fst ~= Pair)) ifTrue: [^Error].
	((fst == Pair) & (snd == Pair)) ifTrue: [^self makePairs: fst snd: snd].
	((fst ~= V) & (snd == V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst == snd) ifTrue: [^Set new].
	((fst == Pair) & (snd ~= Pair)) ifTrue: [^Error].
	((snd == Pair) & (fst ~= Pair)) ifTrue: [^Error].
	((fst == Pair) & (snd == Pair)) ifTrue: [^self makePairs: fst snd: snd].
	((fst ~= V) & (snd == V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!V methodsFor!
is: v
	| list |
	list := v getVarsList.
	value := v! !
!V categoriesFor: #is:!public! !

!V methodsFor!
is: v
	| list |
	list := v getVarsList.
	((list indexOf: self) > 0) ifTrue: [ ^Error].
	value := v! !
!V categoriesFor: #is:!public! !

"17:57:45, 18 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\better\matcher.img7'"!

!V methodsFor!
is: v
	| list |
	list := v getVarsList.
	((list indexOf: self) > 0) ifTrue: [ ^Error].
	value := v! !
!V categoriesFor: #is:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst == snd) ifTrue: [^Set new].
	((fst == Pair) & (snd ~= Pair)) ifTrue: [^Error].
	((snd == Pair) & (fst ~= Pair)) ifTrue: [^Error].
	((fst == Pair) & (snd == Pair)) ifTrue: [^self makePairs: fst snd: snd].
	((fst ~= V) & (snd == V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst == snd) ifTrue: [^Set new].
	((fst == Pair) & (snd ~= Pair)) ifTrue: [^Error].
	((snd == Pair) & (fst ~= Pair)) ifTrue: [^Error].
	((fst == Pair) & (snd == Pair)) ifTrue: [^self makePairs: fst snd: snd].
	((fst ~= V) & (snd == V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst == snd) ifTrue: [^Set new].
	((fst == Pair) & (snd ~= Pair)) ifTrue: [^Error].
	((snd == Pair) & (fst ~= Pair)) ifTrue: [^Error].
	((fst == Pair) & (snd == Pair)) ifTrue: [^self makePairs: fst snd: snd].
	((fst ~= V) & (snd == V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst == snd) ifTrue: [^Set new].
	((fst == Pair) & (snd ~= Pair)) ifTrue: [^Error].
	((snd == Pair) & (fst ~= Pair)) ifTrue: [^Error].
	((fst == Pair) & (snd == Pair)) ifTrue: [^self makePairs: fst snd: snd].
	((fst ~= V) & (snd == V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

t!

x!

t := C % 1 @ #x!


t1 := C % 1 @ #xa Pair!

t1 := C % 1 @ #x!

t2 := C % 1 % 2!

t1!

t2!

m := Matcher new!

s := Set new!

s add: (Pair new cdr: t1 car:t2)!

p := Pair new!

p car: t1 cdr: t2!

s add: p!

s!

s!

m iterate: s!

m iterate: p!

m iterate: p!

p car!

p car == Pair!

p car!

p car = Pair!

p car isMemberOf: Pair!

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst == snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & (snd ~= Pair)) ifTrue: [^Error].
	((snd == Pair) & (fst ~= Pair)) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	((fst ~= V) & (snd == V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

p car isMemberOf: Pair not!

(p car isMemberOf: Pair) not!

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst == snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: Pair) not)) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: Pair) not)) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst == snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: Pair) not)) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: Pair) not)) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst == snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: Pair) not)) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: Pair) not)) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst == snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: Pair) not)) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: Pair) not)) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

m iterate: p!

!C methodsFor!
== t
	^ value == t value! !
!C categoriesFor: #==!public! !

!C methodsFor!
== t
	^ value == t value! !
!C categoriesFor: #==!public! !

!C methodsFor!
== t
	^ value == t value! !
!C categoriesFor: #==!public! !

!C methodsFor!
== t
	^ value == t value! !
!C categoriesFor: #==!public! !

!C methodsFor!
== t
	^ value == t value! !
!C categoriesFor: #==!public! !

!C methodsFor!
== t
	^ value == t value! !
!C categoriesFor: #==!public! !

!C methodsFor!
== t
	^ value == t value! !
!C categoriesFor: #==!public! !

!C methodsFor!
== t
	^ value == t value! !
!C categoriesFor: #==!public! !

!C methodsFor!
== t
	^ value == t value! !
!C categoriesFor: #==!public! !

!C methodsFor!
== t
	^ value == t value! !
!C categoriesFor: #==!public! !

!C methodsFor!
== t
	^ value == t value! !
!C categoriesFor: #==!public! !

!C methodsFor!
== t
	^ value == t value! !
!C categoriesFor: #==!public! !

!C methodsFor!
== t
	^ value == t value! !
!C categoriesFor: #==!public! !

!C methodsFor!
== t
	^ value == t value! !
!C categoriesFor: #==!public! !

!C methodsFor!
cmp: t
	^ value == t value! !
!C categoriesFor: #cmp:!public! !

!C methodsFor!
cmp: t
	(t isMemberOf: C) ifFalse: [^false].
	^ value == t value! !
!C categoriesFor: #cmp:!public! !

!C methodsFor!
cmp: t
	(t isMemberOf: C) ifFalse: [^false].
	^ value == t value! !
!C categoriesFor: #cmp:!public! !

!C methodsFor!
cmp: t
	(t isMemberOf: C) ifFalse: [^false].
	^ value == t value! !
!C categoriesFor: #cmp:!public! !

!C methodsFor!
cmp: t
	(t isMemberOf: C) ifFalse: [^false].
	^ value == t value! !
!C categoriesFor: #cmp:!public! !

!C methodsFor!
cmp: t
	(t isMemberOf: C) ifFalse: [^false].
	^ value == t value! !
!C categoriesFor: #cmp:!public! !

!C methodsFor!
value
	! !
!C categoriesFor: #value!public! !

!C methodsFor!
value
	! !
!C categoriesFor: #value!public! !

!C methodsFor!
value
	! !
!C categoriesFor: #value!public! !

!C methodsFor!
value
	! !
!C categoriesFor: #value!public! !

C removeSelector: #value ifAbsent: []!

!Term methodsFor!
cmp: t
	^ self == t! !
!Term categoriesFor: #cmp:!public! !

!Term methodsFor!
cmp: t
	^ self == t! !
!Term categoriesFor: #cmp:!public! !

!Term methodsFor!
cmp: t
	^ self == t! !
!Term categoriesFor: #cmp:!public! !

!Term methodsFor!
cmp: t
	^ self == t! !
!Term categoriesFor: #cmp:!public! !

!Term methodsFor!
cmp: t
	^ self == t! !
!Term categoriesFor: #cmp:!public! !

!Term methodsFor!
cmp: t
	^ self == t! !
!Term categoriesFor: #cmp:!public! !

!Term methodsFor!
cmp: t
	^ self == t! !
!Term categoriesFor: #cmp:!public! !

!Term methodsFor!
cmp: t
	^ self == t! !
!Term categoriesFor: #cmp:!public! !

!Term methodsFor!
cmp: t
	^ self == t! !
!Term categoriesFor: #cmp:!public! !

!Term methodsFor!
cmp: t
	^ self == t! !
!Term categoriesFor: #cmp:!public! !

t1 := C % 1 % 2a Pair!

t1 := C % 1 % 2!

t2 := C % 1 % 2!

t1 == t2!

!Pair methodsFor!
cmp: t
	! !
!Pair categoriesFor: #cmp:!public! !

!Pair methodsFor!
cmp: t
	(t isMemberOf: Pair) ifFalse: [^false].
	^ value == t value
	! !
!Pair categoriesFor: #cmp:!public! !

!Pair methodsFor!
cmp: t
	(t isMemberOf: Pair) ifFalse: [^false].
	^ (self cdr cmp t cdr) & (self car cmp t car)
	! !
!Pair categoriesFor: #cmp:!public! !

!Pair methodsFor!
cmp: t
	(t isMemberOf: Pair) ifFalse: [^false].
	^ (self cdr cmp t cdr) & (self car cmp t car)
	! !
!Pair categoriesFor: #cmp:!public! !

!Pair methodsFor!
cmp: t
	(t isMemberOf: Pair) ifFalse: [^false].
	^ (self cdr cmp t cdr) & (self car cmp t car)
	! !
!Pair categoriesFor: #cmp:!public! !

!Pair methodsFor!
cmp: t
	(t isMemberOf: Pair) ifFalse: [^false].
	^ (self cdr cmp: t cdr) & (self car cmp: t car)
	! !
!Pair categoriesFor: #cmp:!public! !

t1 cmp: t2!

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: Pair) not)) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: Pair) not)) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: Pair) not)) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: Pair) not)) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

m iterate: p!

m iterate: p!

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: Pair) not)) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: Pair) not)) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			(fst isUninitialized) ifFalse: [^Error] ifTrue: [fst is: snd. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: Pair) not)) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: Pair) not)) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			(fst isUninitialized) ifFalse: [^Error] ifTrue: [fst is: snd. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: Pair) not)) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: Pair) not)) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			(fst isUninitialized) ifFalse: [^Error] ifTrue: [fst is: snd. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

m iterate: p!

m iterate: p!

p!

x := V @ #x!

x value!

t1 := C % 1 % 2!

t2 := C % 1 % 3!

p := Pair new!

p car: t1 cdr: t2!

"18:36:50, 18 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\frejt\matcher.img7'"!

m iterate: p!

p car: t1 cdr: t2!

m := Matcher new!

m iterate: p!

m iterate: p!

!Matcher methodsFor!
iterate: what
	container := Set new.
	container add: what.
	[container isEmpty not] whileTrue: 
		[
			| tmp addition |
			tmp := container anyOne.
			addition := self chooseAction: tmp.
			container remove: tmp.
			(addition ifMemberOf: Matcher) ifTrue: [^Error].
			container addAll: addition
		].
	^container! !
!Matcher categoriesFor: #iterate:!public! !

!Matcher methodsFor!
iterate: what
	container := Set new.
	container add: what.
	[container isEmpty not] whileTrue: 
		[
			| tmp addition |
			tmp := container anyOne.
			addition := self chooseAction: tmp.
			container remove: tmp.
			(addition isMemberOf: Matcher) ifTrue: [^Error].
			container addAll: addition
		].
	^container! !
!Matcher categoriesFor: #iterate:!public! !

m iterate: p!

t2 := C % 1 % 2!

p car: t1 cdr: t2!

m iterate: p!

t2 := C % 1 % 3!

p car: t1 cdr: t2!

(m iterate: p) == Error!

!Term methodsFor!
go: t do: action
	| m p|
	m := Matcher new.
	p := Pair new.
	p car: self cdr: t.
	m iterate: p
	! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
go: t do: action
	| m p ans|
	m := Matcher new.
	p := Pair new.
	p car: self cdr: t.
	m iterate: p
	! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
go: t do: action
	| m p ans|
	m := Matcher new.
	p := Pair new.
	p car: self cdr: t.
	ans := m iterate: p
	! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
go: t do: action
	| m p ans|
	m := Matcher new.
	p := Pair new.
	p car: self cdr: t.
	ans := m iterate: p.
	(ans == Error) ifFalse:
		action
	
	! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
go: t do: action
	| m p ans|
	m := Matcher new.
	p := Pair new.
	p car: self cdr: t.
	ans := m iterate: p.
	(ans == Error) ifFalse:
		[action]
	
	! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
go: t do: action
	| m p ans|
	m := Matcher new.
	p := Pair new.
	p car: self cdr: t.
	ans := m iterate: p.
	(ans == Error) ifFalse:
		[action]
	
	! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
go: t do: action
	| m p ans|
	m := Matcher new.
	p := Pair new.
	p car: self cdr: t.
	ans := m iterate: p.
	(ans == Error) ifFalse:
		[action]
	
	! !
!Term categoriesFor: #go:do:!public! !

w := 0!

t1 go: t2 do: [w:=1]!

w!

t2 := C % 1 % 2!

w := 0!

t1 go: t2 do: [w:=1]!

w!

t1 go: t2 do: [w:=1]!

!Term methodsFor!
go: t do: action
	| m p ans|
	m := Matcher new.
	p := Pair new.
	p car: self cdr: t.
	ans := m iterate: p.
	(ans == Error) ifFalse:
		[action value]
	
	! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
go: t do: action
	| m p ans|
	m := Matcher new.
	p := Pair new.
	p car: self cdr: t.
	ans := m iterate: p.
	(ans == Error) ifFalse:
		[action value]
	
	! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
go: t do: action
	| m p ans|
	m := Matcher new.
	p := Pair new.
	p car: self cdr: t.
	ans := m iterate: p.
	(ans == Error) ifFalse:
		[action value]
	
	! !
!Term categoriesFor: #go:do:!public! !

t1 go: t2 do: [w:=1]!

w!

C % 1 go: C % 2 do: [self assert: [false]].!

C % 1 go: C % 1 do: [self assert: [false]].!

w := 0.
C % 1 go: C % 1 do: [w := w + 1].
self assert: [w = 1].
!

w := 0.
C % 2 go: C % 1 do: [w := w + 1].
self assert: [w = 1].
nil!

"18:47:45, 18 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\s\matcher.img7'"!

t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].

a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].

t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].

C % 1 go: C % 2 do: [self assert: [false]].

w := 0.
C % 1 go: C % 1 do: [w := w + 1].
self assert: [w = 1].

x := V @ #x.
y := V @ #y.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].

w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].

x go: L, x do: [self assert: [false]].!

V reset!

t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].!

a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].!

t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].
!

C % 1 go: C % 2 do: [self assert: [false]].!

w := 0.
C % 1 go: C % 1 do: [w := w + 1].
self assert: [w = 1].!

x := V @ #x.
y := V @ #y.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].!

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].
!

proba := C % 1 % 2!

proba!

proba!

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].!

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1].
self assert: [w = 1].!

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].!

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1]
!

!Matcher methodsFor!
iterate: what
	container := Set new.
	container add: what.
	[container isEmpty not] whileTrue: 
		[
			| tmp addition |
			tmp := container anyOne.
			addition := self chooseAction: tmp.
			container remove: tmp.
			(addition isMemberOf: Matcher | addition == Error ) ifTrue: [^Error].
			container addAll: addition
		].
	^container! !
!Matcher categoriesFor: #iterate:!public! !

!Matcher methodsFor!
iterate: what
	container := Set new.
	container add: what.
	[container isEmpty not] whileTrue: 
		[
			| tmp addition |
			tmp := container anyOne.
			addition := self chooseAction: tmp.
			container remove: tmp.
			((addition isMemberOf: Matcher) | (addition == Error) ) ifTrue: [^Error].
			container addAll: addition
		].
	^container! !
!Matcher categoriesFor: #iterate:!public! !

!Matcher methodsFor!
iterate: what
	container := Set new.
	container add: what.
	[container isEmpty not] whileTrue: 
		[
			| tmp addition |
			tmp := container anyOne.
			addition := self chooseAction: tmp.
			container remove: tmp.
			((addition isMemberOf: Matcher) | (addition == Error) ) ifTrue: [^Error].
			container addAll: addition
		].
	^container! !
!Matcher categoriesFor: #iterate:!public! !

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1]
!

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].!

x := V @ #x.
y := V @ #y.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].nil
!

V reset!

t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].nil
!

a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].nil!

t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].!

C % 1 go: C % 2 do: [self assert: [false]].!

w := 0.
C % 1 go: C % 1 do: [w := w + 1].
self assert: [w = 1].!

x := V @ #x.
y := V @ #y.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].!

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].!

V reset!

!Term methodsFor!
go: t do: action
	| m p ans recover|
	m := Matcher new.
	p := Pair new.
	p car: self cdr: t.
	ans := m iterate: p.
	(ans == Error) ifFalse:
		[action value].
	recover := self getVarsList , t getVarsList
	
	! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
getVarsList! !
!Term categoriesFor: #getVarsList!public! !

!Term methodsFor!
go: t do: action
	| m p ans recover|
	m := Matcher new.
	p := Pair new.
	p car: self cdr: t.
	ans := m iterate: p.
	(ans == Error) ifFalse:
		[action value].
	recover := self getVarsList , t getVarsList
	
	! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
go: t do: action
	| m p ans recover|
	m := Matcher new.
	p := Pair new.
	p car: self cdr: t.
	ans := m iterate: p.
	(ans == Error) ifFalse:
		[action value].
	recover := self getVarsList , t getVarsList.
	recover select: [ :x | x ]
	
	! !
!Term categoriesFor: #go:do:!public! !

!V methodsFor!
zeros
	value := nil! !
!V categoriesFor: #zeros!public! !

!V methodsFor!
zeros
	value := nil! !
!V categoriesFor: #zeros!public! !

!Term methodsFor!
go: t do: action
	| m p ans recover|
	m := Matcher new.
	p := Pair new.
	p car: self cdr: t.
	ans := m iterate: p.
	(ans == Error) ifFalse:
		[action value].
	recover := self getVarsList , t getVarsList.
	recover select: [ :x | x  zeros]
	
	! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
go: t do: action
	| m p ans recover|
	m := Matcher new.
	p := Pair new.
	p car: self cdr: t.
	ans := m iterate: p.
	(ans == Error) ifFalse:
		[action value].
	recover := self getVarsList , t getVarsList.
	recover select: [ :x | x  zeros]
	
	! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
go: t do: action
	| m p ans recover|
	m := Matcher new.
	p := Pair new.
	p car: self cdr: t.
	ans := m iterate: p.
	(ans == Error) ifFalse:
		[action value].
	recover := self getVarsList , t getVarsList.
	recover select: [ :x | x  zeros]
	
	! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
go: t do: action
	| m p ans recover|
	m := Matcher new.
	p := Pair new.
	p car: self cdr: t.
	ans := m iterate: p.
	(ans == Error) ifFalse:
		[action value].
	recover := self getVarsList , t getVarsList.
	recover select: [ :x | x  zeros]
	
	! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
go: t do: action
	| m p ans recover|
	m := Matcher new.
	p := Pair new.
	p car: self cdr: t.
	ans := m iterate: p.
	(ans == Error) ifFalse:
		[action value].
	recover := self getVarsList , t getVarsList.
	recover select: [ :x | x  zeros]
	
	! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
go: t do: action
	| m p ans recover|
	m := Matcher new.
	p := Pair new.
	p car: self cdr: t.
	ans := m iterate: p.
	(ans == Error) ifFalse:
		[action value].
	recover := self getVarsList , t getVarsList.
	recover select: [ :x | x  zeros]
	
	! !
!Term categoriesFor: #go:do:!public! !

V reset!

t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].!

a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].!

t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].!

C % 1 go: C % 2 do: [self assert: [false]].!

w := 0.
C % 1 go: C % 1 do: [w := w + 1].
self assert: [w = 1].!

x := V @ #x.
y := V @ #y.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].!

!Term methodsFor!
go: t do: action
	| m p ans recover|
	m := Matcher new.
	p := Pair new.
	p car: self cdr: t.
	ans := m iterate: p.
	(ans == Error) ifFalse:
		[action value].
	recover := self getVarsList , t getVarsList.
	recover do: [ :x | x  zeros]
	
	! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
go: t do: action
	| m p ans recover|
	m := Matcher new.
	p := Pair new.
	p car: self cdr: t.
	ans := m iterate: p.
	(ans == Error) ifFalse:
		[action value].
	recover := self getVarsList , t getVarsList.
	recover do: [ :x | x  zeros]
	
	! !
!Term categoriesFor: #go:do:!public! !

V reset.
t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].!

a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].nil
!

t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].nil

C % 1 go: C % 2 do: [self assert: [false]].!

t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].!

C % 1 go: C % 2 do: [self assert: [false]].!

w := 0.
C % 1 go: C % 1 do: [w := w + 1].
self assert: [w = 1].!

x := V @ #x.
y := V @ #y.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].!

x!

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].!

V reset!

x := V @ #x.
y := V @ #y.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].!

x value!

x value!

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].!

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			(fst isUninitialized) ifFalse: [^Error] ifTrue: [fst is: snd. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			(fst isUninitialized) ifFalse: [^Error] ifTrue: [fst is: snd. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

V reset.
x := V @ #x.
y := V @ #y.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].!

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].!

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].!

V reset.
x := V @ #x.
y := V @ #y.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].!

x!

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].!

V reset.
x := V @ #x.
y := V @ #y.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].!

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].
!

!Pair methodsFor!
value
	| tmp |
	tmp := Pair new.
	tmp car: self car value cdr: self cdr value! !
!Pair categoriesFor: #value!public! !

!Pair methodsFor!
value
	| tmp |
	tmp := Pair new.
	tmp car: self car value cdr: self cdr value! !
!Pair categoriesFor: #value!public! !

!Pair methodsFor!
value
	| tmp |
	tmp := Pair new.
	tmp car: car value cdr: cdr value! !
!Pair categoriesFor: #value!public! !

!Pair methodsFor!
value
	| tmp |
	tmp := Pair new.
	tmp car: car value cdr: cdr value! !
!Pair categoriesFor: #value!public! !

!Pair methodsFor!
value
	| tmp |
	tmp := Pair new.
	tmp car: car value cdr: cdr value! !
!Pair categoriesFor: #value!public! !

!Pair methodsFor!
value
	| tmp |
	tmp := Pair new.
	tmp car: car value cdr: cdr value! !
!Pair categoriesFor: #value!public! !

!Pair methodsFor!
value
	| tmp |
	tmp := Pair new.
	tmp car: car value cdr: cdr value.
	^ tmp! !
!Pair categoriesFor: #value!public! !

V reset.
x := V @ #x.
y := V @ #y.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].!

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].
!

!V methodsFor!
car
	^value vcar! !
!V categoriesFor: #car!public! !

!V methodsFor!
cdr
	^value cdr! !
!V categoriesFor: #cdr!public! !

!V methodsFor!
car
	^value car! !
!V categoriesFor: #car!public! !

V reset.
x := V @ #x.
y := V @ #y.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].nil!

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].!

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].!

w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].
!

V reset!

x := V @ #x.
y := V @ #y.!

w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].!

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	((fst isMemberOf: V) & ((snd isMemberOf: V))) ifTrue: [fst is snd. snd is fst.].
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			(fst isUninitialized) ifFalse: [^Error] ifTrue: [fst is: snd. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	((fst isMemberOf: V) & ((snd isMemberOf: V))) ifTrue: [fst is: snd. snd is: fst.].
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			(fst isUninitialized) ifFalse: [^Error] ifTrue: [fst is: snd. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	((fst isMemberOf: V) & ((snd isMemberOf: V))) ifTrue: [fst is: snd. snd is: fst.].
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			(fst isUninitialized) ifFalse: [^Error] ifTrue: [fst is: snd. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

x := V @ #x.
y := V @ #y.!

w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].!

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	((fst isMemberOf: V) & ((snd isMemberOf: V))) ifTrue: [fst is: snd. snd is: fst. ^Set new].
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			(fst isUninitialized) ifFalse: [^Error] ifTrue: [fst is: snd. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

"19:28:49, 18 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\to\matcher.img7'"!

x := V @ #x.
y := V @ #y.!

w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].!

x := V @ #x.
y := V @ #y.!


w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].!

!V methodsFor!
isUninitialized
	^(value == nil) ifTrue: [true] ifFalse: 
		[ (value isMemberOf: V) ifTrue: [^true] ]! !
!V categoriesFor: #isUninitialized!public! !

!V methodsFor!
isUninitialized
	^(value == nil) ifTrue: [true] ifFalse: 
		[ (value isMemberOf: V) ifTrue: [^true] ]! !
!V categoriesFor: #isUninitialized!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	((fst isMemberOf: V) & ((snd isMemberOf: V))) ifTrue: [((fst canBind) & (snd canBind)) ifTrue: [ fst is: snd. snd is: fst. ^Set new] ifFalse: [^Error]].
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			(fst isUninitialized) ifFalse: [^Error] ifTrue: [fst is: snd. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	((fst isMemberOf: V) & ((snd isMemberOf: V))) ifTrue: [((fst canBind) & (snd canBind)) ifTrue: [ fst is: snd. snd is: fst. ^Set new] ifFalse: [^Error]].
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			(fst isUninitialized) ifFalse: [^Error] ifTrue: [fst is: snd. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	((fst isMemberOf: V) & ((snd isMemberOf: V))) ifTrue: [((fst canBind) & (snd canBind)) ifTrue: [ fst is: snd. snd is: fst. ^Set new] ifFalse: [^Error]].
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			(fst isUninitialized) ifFalse: [^Error] ifTrue: [fst is: snd. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!V methodsFor!
canBind
	(self isUninitialized) ifTrue: [^true] ifFalse: []! !
!V categoriesFor: #canBind!public! !

!V methodsFor!
isUninitialized
	^(value == nil) ifTrue: [true] ifFalse: [false]! !
!V categoriesFor: #isUninitialized!public! !

!V methodsFor!
canBind
	(value == nil) ifTrue: [^true] ifFalse: [false]! !
!V categoriesFor: #canBind!public! !

!V methodsFor!
isUninitialized
	^(value == nil) ifTrue: [true] ifFalse: 
		[
			(value isMemberOf: V) ifTrue: [true] ifFalse: [false]
		]! !
!V categoriesFor: #isUninitialized!public! !

!V methodsFor!
isUninitialized
	^(value == nil) ifTrue: [true] ifFalse: 
		[
			(value isMemberOf: V) ifTrue: [true] ifFalse: [false]
		]! !
!V categoriesFor: #isUninitialized!public! !

!V methodsFor!
isUninitialized
	^(value == nil) ifTrue: [true] ifFalse: 
		[
			(value isMemberOf: V) ifTrue: [true] ifFalse: [false]
		]! !
!V categoriesFor: #isUninitialized!public! !

!V methodsFor!
isUninitialized
	^(value == nil) ifTrue: [true] ifFalse: 
		[
			(value isMemberOf: V) ifTrue: [true] ifFalse: [false]
		]! !
!V categoriesFor: #isUninitialized!public! !

!V methodsFor!
isUninitialized
	^(value == nil) ifTrue: [true] ifFalse: 
		[
			(value isMemberOf: V) ifTrue: [true] ifFalse: [false]
		]! !
!V categoriesFor: #isUninitialized!public! !

!Matcher methodsFor!
chooseAction: terms
	| fst snd |
	fst := terms car.
	snd := terms cdr.
	((fst isMemberOf: V) & ((snd isMemberOf: V))) ifTrue: [((fst canBind) & (snd canBind)) ifTrue: [ fst is: snd. snd is: fst. ^Set new] ifFalse: [^Error]].
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			(fst isUninitialized) ifFalse: [^Error] ifTrue: [fst is: snd. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

x := V @ #x.
y := V @ #y.!

w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].!

"20:18:07, 18 czerwca 2017: Image saved"!

"20:18:16, 18 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\testy\matcher.img7'"!

Term subclass: #V
	instanceVariableNames: 'addr refers'
	classVariableNames: 'VarsDict'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!V methodsFor!
addr: c
	type := 'var'.
	addr:= c
	! !
!V categoriesFor: #addr:!public! !

!V methodsFor!
addr: c
	type := 'var'.
	addr:= c.
	refers := Set new! !
!V categoriesFor: #addr:!public! !

!V methodsFor!
addr: c
	type := 'var'.
	addr:= c.
	refers := Set new! !
!V categoriesFor: #addr:!public! !

!Matcher methodsFor!
transformTerms: t1 snd:t2
	| term1 term2 |
	term1 := t1.
	term2 := t2.
	(t1 isMemberOf: V & (t1 isUninitialized not)) ifTrue: []! !
!Matcher categoriesFor: #transformTerms:snd:!public! !

!Matcher methodsFor!
transformTerms: terms
	| term1 term2 |
	term1 := terms car .
	term2 := terms cdr.
	(term1 isMemberOf: V & (term1 isUninitialized not)) ifTrue: [ term1 := term1 value].
	! !
!Matcher categoriesFor: #transformTerms:!public! !

!Matcher methodsFor!
transformTerms: terms
	| term1 term2 t1 t2|
	term1 := terms car .
	term2 := terms cdr.
	(term1 isMemberOf: V & (term1 isUninitialized not)) ifTrue: [ t1 := term1 value].
	! !
!Matcher categoriesFor: #transformTerms:!public! !

!Matcher methodsFor!
transformTerms: terms
	| term1 term2 t1 t2 tmp |
	term1 := terms car .
	term2 := terms cdr.
	t1 := term1.
	t2 := term2.
	(term1 isMemberOf: V & (term1 isUninitialized not)) ifTrue: [ t1 := term1 value].
	(term2 isMemberOf: V & (term1 isUninitialized not)) ifTrue: [ t2 := term2 value].
	tmp := Pair new.
	tmp car: t1 cdr: t2! !
!Matcher categoriesFor: #transformTerms:!public! !

!Matcher methodsFor!
transformTerms: terms
	| term1 term2 t1 t2 tmp |
	term1 := terms car .
	term2 := terms cdr.
	t1 := term1.
	t2 := term2.
	(term1 isMemberOf: V & (term1 isUninitialized not)) ifTrue: [ t1 := term1 value].
	(term2 isMemberOf: V & (term1 isUninitialized not)) ifTrue: [ t2 := term2 value].
	tmp := Pair new.
	tmp car: t1 cdr: t2.
	^tmp! !
!Matcher categoriesFor: #transformTerms:!public! !

!Matcher methodsFor!
transformTerms: terms
	| term1 term2 t1 t2 tmp |
	term1 := terms car .
	term2 := terms cdr.
	t1 := term1.
	t2 := term2.
	(term1 isMemberOf: V & ((term1 isUninitialized) not)) ifTrue: [ t1 := term1 value].
	(term2 isMemberOf: V & ((term1 isUninitialized) not)) ifTrue: [ t2 := term2 value].
	tmp := Pair new.
	tmp car: t1 cdr: t2.
	^tmp! !
!Matcher categoriesFor: #transformTerms:!public! !

Matcher removeSelector: #transformTerms:snd: ifAbsent: []!

!Matcher methodsFor!
transformTerms: terms
	| term1 term2 t1 t2 tmp |
	term1 := terms car .
	term2 := terms cdr.
	t1 := term1.
	t2 := term2.
	(term1 isMemberOf: V & ((term1 isUninitialized) not)) ifTrue: [ t1 := term1 value].
	(term2 isMemberOf: V & ((term1 isUninitialized) not)) ifTrue: [ t2 := term2 value].
	tmp := Pair new.
	tmp car: t1 cdr: t2.
	^tmp! !
!Matcher categoriesFor: #transformTerms:!public! !

!Matcher methodsFor!
chooseAction: terms
	| tmp fst snd |
	tmp := self transformTerms: terms.
	fst := tmp car.
	snd := tmp cdr.
	((fst isMemberOf: V) & ((snd isMemberOf: V))) ifTrue: [((fst canBind) & (snd canBind)) ifTrue: [ fst is: snd. snd is: fst. ^Set new] ifFalse: [^Error]].
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			(fst isUninitialized) ifFalse: [^Error] ifTrue: [fst is: snd. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| tmp fst snd |
	tmp := self transformTerms: terms.
	fst := tmp car.
	snd := tmp cdr.
	((fst isMemberOf: V) & ((snd isMemberOf: V))) ifTrue: [fst is: snd. snd is: fst. ^Set new].
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			(fst isUninitialized) ifFalse: [^Error] ifTrue: [fst is: snd. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| tmp fst snd |
	tmp := self transformTerms: terms.
	fst := tmp car.
	snd := tmp cdr.
	((fst isMemberOf: V) & ((snd isMemberOf: V))) ifTrue: [fst is: snd. snd is: fst. ^Set new].
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			(fst isUninitialized) ifFalse: [^Error] ifTrue: [fst is: snd. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!V methodsFor!
isUninitialized
	^(value == nil) ifTrue: [true] ifFalse: [false]! !
!V categoriesFor: #isUninitialized!public! !

!V methodsFor!
isUninitialized
	^(value == nil) ifTrue: [true] ifFalse: [false]! !
!V categoriesFor: #isUninitialized!public! !

!V methodsFor!
is: v
	| list |
	(v isMemberOf: V) ifTrue: [^refers add: v].
	list := v getVarsList.
	((list indexOf: self) > 0) ifTrue: [ ^Error].
	value := v! !
!V categoriesFor: #is:!public! !

!V methodsFor!
is: v
	| list |
	(v isMemberOf: V) ifTrue: [^refers add: v].
	list := v getVarsList.
	((list indexOf: self) > 0) ifTrue: [ ^Error].
	value := v! !
!V categoriesFor: #is:!public! !

!V methodsFor!
is: v
	| list |
	(v isMemberOf: V) ifTrue: [^refers add: v].
	(((value == nil) not) & ((value cmp: v) not)) ifTrue: [].
	list := v getVarsList.
	((list indexOf: self) > 0) ifTrue: [ ^Error].
	value := v
	refers do: [:el | el is v]! !
!V categoriesFor: #is:!public! !

!V methodsFor!
is: v
	| list |
	(v isMemberOf: V) ifTrue: [^refers add: v].
	(((value == nil) not) & ((value cmp: v) not)) ifTrue: [^Error].
	list := v getVarsList.
	((list indexOf: self) > 0) ifTrue: [^Error].
	value := v
	refers do: [:el | el is v]! !
!V categoriesFor: #is:!public! !

!V methodsFor!
is: v
	| list |
	(v isMemberOf: V) ifTrue: [^refers add: v].
	(((value == nil) not) & ((value cmp: v) not)) ifTrue: [^Error].
	list := v getVarsList.
	((list indexOf: self) > 0) ifTrue: [^Error].
	value := v.
	refers do: [:el | el is v]! !
!V categoriesFor: #is:!public! !

!V methodsFor!
is: v
	| list |
	(v isMemberOf: V) ifTrue: [^refers add: v].
	(((value == nil) not) & ((value cmp: v) not)) ifTrue: [^Error].
	list := v getVarsList.
	((list indexOf: self) > 0) ifTrue: [^Error].
	value := v.
	refers do: [:el | el is: v]! !
!V categoriesFor: #is:!public! !

!V methodsFor!
is: v
	| list |
	(v isMemberOf: V) ifTrue: [^refers add: v].
	(((value == nil) not) & ((value cmp: v) not)) ifTrue: [^Error] ifFalse: [^self].
	list := v getVarsList.
	((list indexOf: self) > 0) ifTrue: [^Error].
	value := v.
	refers do: [:el | el is: v]! !
!V categoriesFor: #is:!public! !

!V methodsFor!
is: v
	| list |
	(v isMemberOf: V) ifTrue: [^refers add: v].
	(((value == nil) not) & ((value cmp: v) not)) ifTrue: [^Error] ifFalse: [^self].
	list := v getVarsList.
	((list indexOf: self) > 0) ifTrue: [^Error].
	value := v.
	refers do: [:el | el is: v]! !
!V categoriesFor: #is:!public! !

!Matcher methodsFor!
chooseAction: terms
	| tmp fst snd err1 err2|
	tmp := self transformTerms: terms.
	fst := tmp car.
	snd := tmp cdr.
	((fst isMemberOf: V) & ((snd isMemberOf: V))) ifTrue: [err1 := fst is: snd. err2:= snd is: fst.  ((err1 == Error) | (err2 == Error)) ifTrue: [^Error]. ^Set new].
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			(snd isUninitialized) ifFalse: [^Error] ifTrue: [snd is: fst. ^Set new]
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			(fst isUninitialized) ifFalse: [^Error] ifTrue: [fst is: snd. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| tmp fst snd err1 err2|
	tmp := self transformTerms: terms.
	fst := tmp car.
	snd := tmp cdr.
	((fst isMemberOf: V) & ((snd isMemberOf: V))) ifTrue: [err1 := fst is: snd. err2:= snd is: fst.  ((err1 == Error) | (err2 == Error)) ifTrue: [^Error]. ^Set new].
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			err1:= snd is: fst. (err1 == Error) ifTrue: [^Error]. ^Set new
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			(fst isUninitialized) ifFalse: [^Error] ifTrue: [fst is: snd. ^Set new]
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| tmp fst snd err1 err2|
	tmp := self transformTerms: terms.
	fst := tmp car.
	snd := tmp cdr.
	((fst isMemberOf: V) & ((snd isMemberOf: V))) ifTrue: [err1 := fst is: snd. err2:= snd is: fst.  ((err1 == Error) | (err2 == Error)) ifTrue: [^Error]. ^Set new].
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			err1:= snd is: fst. (err1 == Error) ifTrue: [^Error]. ^Set new
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			err1:= fst is: snd. (err1 == Error) ifTrue: [^Error]. ^Set new
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

V reset.
x := V @ #x.
y := V @ #y.!

w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].!

"09:53:55, 19 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\pon\matcher.img7'"!

V reset.
x := V @ #x.
y := V @ #y.!

w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].!

!Matcher methodsFor!
transformTerms: terms
	| term1 term2 t1 t2 tmp |
	term1 := terms car .
	term2 := terms cdr.
	t1 := term1.
	t2 := term2.
	((term1 isMemberOf: V) & ((term1 isUninitialized) not)) ifTrue: [ t1 := term1 value].
	((term2 isMemberOf: V) & ((term1 isUninitialized) not)) ifTrue: [ t2 := term2 value].
	tmp := Pair new.
	tmp car: t1 cdr: t2.
	^tmp! !
!Matcher categoriesFor: #transformTerms:!public! !

!Matcher methodsFor!
transformTerms: terms
	| term1 term2 t1 t2 tmp |
	term1 := terms car .
	term2 := terms cdr.
	t1 := term1.
	t2 := term2.
	((term1 isMemberOf: V) & ((term1 isUninitialized) not)) ifTrue: [ t1 := term1 value].
	((term2 isMemberOf: V) & ((term1 isUninitialized) not)) ifTrue: [ t2 := term2 value].
	tmp := Pair new.
	tmp car: t1 cdr: t2.
	^tmp! !
!Matcher categoriesFor: #transformTerms:!public! !

w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].!

V reset.
x := V @ #x.
y := V @ #y.!


w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].
!

!Matcher methodsFor!
transformTerms: terms
	| term1 term2 t1 t2 tmp |
	term1 := terms car .
	term2 := terms cdr.
	t1 := term1.
	t2 := term2.
	(term1 isMemberOf: V) ifTrue:  [((term1 isUninitialized) not) ifTrue: [ t1 := term1 value]].
	(term2 isMemberOf: V) ifTrue:  [((term2 isUninitialized) not) ifTrue: [ t2 := term2 value]].
	tmp := Pair new.
	tmp car: t1 cdr: t2.
	^tmp! !
!Matcher categoriesFor: #transformTerms:!public! !

!Matcher methodsFor!
transformTerms: terms
	| term1 term2 t1 t2 tmp |
	term1 := terms car .
	term2 := terms cdr.
	t1 := term1.
	t2 := term2.
	(term1 isMemberOf: V) ifTrue:  [((term1 isUninitialized) not) ifTrue: [ t1 := term1 value]].
	(term2 isMemberOf: V) ifTrue:  [((term2 isUninitialized) not) ifTrue: [ t2 := term2 value]].
	tmp := Pair new.
	tmp car: t1 cdr: t2.
	^tmp! !
!Matcher categoriesFor: #transformTerms:!public! !

V reset.
x := V @ #x.
y := V @ #y.!

w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].!

!V methodsFor!
is: v
	| list |
	(v isMemberOf: V) ifTrue: [^refers add: v].
	(((value == nil) not) & ((value cmp: v) not)) ifTrue: [^Error] ifFalse: [^self].
	list := v getVarsList.
	((list indexOf: self) > 0) ifTrue: [^Error].
	value := v.
	refers do: [:el | el is: v].
	refers := Set new.


! !
!V categoriesFor: #is:!public! !

!V methodsFor!
is: v
	| list |
	(v isMemberOf: V) ifTrue: [^refers add: v].
	((value == nil) not) ifTrue:[ ((value cmp: v) not) ifTrue: [^Error] ifFalse: [^self]].
	list := v getVarsList.
	((list indexOf: self) > 0) ifTrue: [^Error].
	value := v.
	refers do: [:el | el is: v].
	refers := Set new.


! !
!V categoriesFor: #is:!public! !

V reset.
x := V @ #x.
y := V @ #y.!


w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].!

"10:03:53, 19 czerwca 2017: Image saved"!

"10:04:06, 19 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\grejt\ok.img7'"!

V reset.
t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].!

a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].!

t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].!

C % 1 go: C % 2 do: [self assert: [false]].!

w := 0.
C % 1 go: C % 1 do: [w := w + 1].
self assert: [w = 1].!

x := V @ #x.
y := V @ #y.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].!

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].!

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].!

w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].!

V reset.
t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].nil!

a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].nil!


t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].nil

C % 1 go: C % 2 do: [self assert: [false]].a C!

V reset.
t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].!

a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].!

t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].!

C % 1 go: C % 2 do: [self assert: [false]].!

w := 0.
C % 1 go: C % 1 do: [w := w + 1].
self assert: [w = 1].!

x := V @ #x.
y := V @ #y.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].

!

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].!

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].!

x := V @ #x.
y := V @ #y.!

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].
!


x := V @ #x.
y := V @ #y.!

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].!

V reset.
x := V @ #x.
y := V @ #y.!

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].!

!Matcher methodsFor!
transformTerms: terms
	| term1 term2 t1 t2 tmp |
	term1 := terms car .
	term2 := terms cdr.
	t1 := term1.
	t2 := term2.
	(term1 isMemberOf: V) ifTrue:  [((term1 isUninitialized) not) ifTrue: [ t1 := term1 val]].
	(term2 isMemberOf: V) ifTrue:  [((term2 isUninitialized) not) ifTrue: [ t2 := term2 val]].
	tmp := Pair new.
	tmp car: t1 cdr: t2.
	^tmp! !
!Matcher categoriesFor: #transformTerms:!public! !

V reset.
x := V @ #x.
y := V @ #y.!

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].!

V reset.
x := V @ #x.
y := V @ #y.!

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].!

w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].!

x go: L, x do: [self assert: [false]].!

V reset.
t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].
a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].

t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].

C % 1 go: C % 2 do: [self assert: [false]].

w := 0.
C % 1 go: C % 1 do: [w := w + 1].
self assert: [w = 1].
V reset.
x := V @ #x.
y := V @ #y.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].

w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].

x go: L, x do: [self assert: [false]].!

"10:18:48, 19 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\gotowe\mj.img7'"!

term :=(V@ #x , ((V @ #x), (V @ #y)))!

term2 := (V@ #y , ((C % 1), (C % 2)))!

w :=0.!

term go: term2 do: [w:=w+1]!

w!

term2 := (V@ #y , ((C % 1), (C % 1)))!

w :=0
term go: term2 do: [w:=w+1]!

term!

term!

w :=0!

term go: term2 do: [w:=w+1]!

V reset.
w :=0!

term :=(V@ #x , ((V @ #x), (V @ #y))).
term2 := (V@ #y , ((C % 1), (C % 1))).!

term go: term2 do: [w:=w+1]!

w!

Object subclass: #Database
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Database guid: (GUID fromString: '{4443FA00-4D98-4D9B-8059-C971BC97C6FD}')!
Database comment: ''!
!Database categoriesForClass!Kernel-Objects! !
Object subclass: #Database
	instanceVariableNames: 'facts rules'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Prolog
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Prolog guid: (GUID fromString: '{17422F08-6F55-4B27-A11D-480379BE9DC8}')!
Prolog comment: ''!
!Prolog categoriesForClass!Kernel-Objects! !
Object subclass: #Prolog
	instanceVariableNames: 'database'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!Prolog class methodsFor!
new
	| tmp |
	tmp := super new.
	tmp init.
	^ tmp! !
!Prolog class categoriesFor: #new!public! !

!Prolog methodsFor!
init
	database := Database new! !
!Prolog categoriesFor: #init!public! !

!Database class methodsFor!
new
	| tmp |
	tmp := super new.
	tmp init.! !
!Database class categoriesFor: #new!public! !

!Database methodsFor!
init
	facts := Array new! !
!Database categoriesFor: #init!public! !

!Database methodsFor!
init
	facts := Array new.
	rules := Array new! !
!Database categoriesFor: #init!public! !

!Database methodsFor!
addRule: rule
	| len tmp |
	rules resize.
	len := rules size.
	rules at: len put: rule.! !
!Database categoriesFor: #addRule:!public! !

Object subclass: #Rule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Rule guid: (GUID fromString: '{36A9B98F-A252-4232-B04E-A56905195522}')!
Rule comment: ''!
!Rule categoriesForClass!Kernel-Objects! !
Object subclass: #Rule
	instanceVariableNames: 'head body'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!Rule methodsFor!
head: h body: b
	head := h.
	body := b! !
!Rule categoriesFor: #head:body:!public! !

Object subclass: #Fact
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Fact guid: (GUID fromString: '{8B9996D4-4FBA-4D8E-9D46-8B271CF6F141}')!
Fact comment: ''!
!Fact categoriesForClass!Kernel-Objects! !
Object subclass: #Fact
	instanceVariableNames: 'term'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!Fact methodsFor!
term: t
	term := t! !
!Fact categoriesFor: #term:!public! !

!Database methodsFor!
addRule: rule
	| len tmp |
	rules resize.
	len := rules size.
	tmp := Rule new.
	tmp head: (rule car) body: (rule cdr).
	rules at: len put: tmp! !
!Database categoriesFor: #addRule:!public! !

!Database methodsFor!
addRule: rule
	| len tmp |
	len := rules size.
	rules resize: (len + 1).
	len := len + 1.
	tmp := Rule new.
	tmp head: (rule car) body: (rule cdr).
	rules at: len put: tmp! !
!Database categoriesFor: #addRule:!public! !

!Database methodsFor!
addFact: fact
	| len tmp |
	len := facts size.
	facts resize: (len + 1).
	len := len + 1.
	tmp := Fact new.
	tmp term: fact
	rules at: len put: tmp! !
!Database categoriesFor: #addFact:!public! !

!Database methodsFor!
addFact: fact
	| len tmp |
	len := facts size.
	facts resize: (len + 1).
	len := len + 1.
	tmp := Fact new.
	tmp term: fact.
	facts at: len put: tmp! !
!Database categoriesFor: #addFact:!public! !

!Prolog methodsFor!
fact: a
	database addFact:  a! !
!Prolog categoriesFor: #fact:!public! !

!Prolog methodsFor!
fact: a
	database addFact:  a! !
!Prolog categoriesFor: #fact:!public! !

!Prolog methodsFor!
head: h body: b
	| tmp |
	tmp := Pair new.
	tmp car: h cdr: b.
	database addRule: tmp  ! !
!Prolog categoriesFor: #head:body:!public! !

!Prolog methodsFor!
head: h body: b
	| tmp |
	tmp := Pair new.
	tmp car: h cdr: b.
	database addRule: tmp  ! !
!Prolog categoriesFor: #head:body:!public! !

!Term methodsFor!
& t
	| tmp |
	tmp := Array new! !
!Term categoriesFor: #&!public! !

!Term methodsFor!
& t
	| tmp |
	tmp := Array new: 2.
	tmp at: 1 put: self.
	tmp at: 2 put: t! !
!Term categoriesFor: #&!public! !

!Term methodsFor!
& t
	| tmp |
	tmp := Array new: 2.
	tmp at: 1 put: self.
	tmp at: 2 put: t.
	^ tmp! !
!Term categoriesFor: #&!public! !

!Term methodsFor!
& t
	| tmp |
	tmp := Array new: 2.
	tmp at: 1 put: self.
	tmp at: 2 put: t.
	^ tmp! !
!Term categoriesFor: #&!public! !

!Prolog methodsFor!
go: ask do: action
	! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
fitter: clausule
	| conds dbIndex i |
	! !
!Prolog categoriesFor: #fitter:!public! !

Prolog subclass: #Fitter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Fitter guid: (GUID fromString: '{06B831D0-8C20-4EFB-A084-36FC29320179}')!
Fitter comment: ''!
!Fitter categoriesForClass!Kernel-Objects! !
Prolog subclass: #Fitter
	instanceVariableNames: 'dbIndex'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Fitter removeFromSystem!

Object subclass: #Fitter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Fitter guid: (GUID fromString: '{279709FA-986A-43DB-BE4C-8F22E0CFA193}')!
Fitter comment: ''!
!Fitter categoriesForClass!Kernel-Objects! !
Object subclass: #Fitter
	instanceVariableNames: 'dbIndex'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!Fitter methodsFor!
match: cond! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match: cond
	! !
!Fitter categoriesFor: #match:!public! !

!Database methodsFor!
find: term
	! !
!Database categoriesFor: #find:!public! !

!Database methodsFor!
find: term index: i
	! !
!Database categoriesFor: #find:index:!public! !

Database removeSelector: #find: ifAbsent: []!

!Database methodsFor!
addFact: fact
	| tmp |
	tmp := Pair new.
	tmp car: fact cdr: []! !
!Database categoriesFor: #addFact:!public! !

!Database methodsFor!
addFact: fact
	| tmp |
	tmp := Pair new.
	tmp car: fact cdr: [].
	self addRule: tmp! !
!Database categoriesFor: #addFact:!public! !

!Database methodsFor!
find: term index: i
	| len  work|
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue: []! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	| len  work i|
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[ 
			 i := i + 1.
			]! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	| len  work i t|
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[ i := i + 1.
			  t := rules at: i trans.
			]! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
trans: t! !
!Database categoriesFor: #trans:!public! !

Database removeSelector: #trans: ifAbsent: []!

Object subclass: #Rule
	instanceVariableNames: 'head body vars'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Rule
	instanceVariableNames: 'head body vars'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!Rule methodsFor!
head: h body: b
	head := h.
	body := b.
	vars := head getVarsList! !
!Rule categoriesFor: #head:body:!public! !

!Fitter methodsFor!
match: cond
	! !
!Fitter categoriesFor: #match:!public! !

!Term methodsFor!
eval
	| tmp |
	(self isMemberOf: Pair) ifTrue: [tmp := Pair new. tmp car: (self car eval) cdr: (self cdr eval) ]! !
!Term categoriesFor: #eval!public! !

!Term methodsFor!
eval
	| tmp |
	(self isMemberOf: Pair) ifTrue: [tmp := Pair new. tmp car: (self car eval) cdr: (self cdr eval) ].
	(self isMemberOf: C) ifTrue: [^self].
	((self isMemberOf: V) & ((value == nil) not)) ifTrue: [self val]! !
!Term categoriesFor: #eval!public! !

!Term methodsFor!
eval
	| tmp |
	(self isMemberOf: Pair) ifTrue: [tmp := Pair new. tmp car: (self car eval) cdr: (self cdr eval) ].
	(self isMemberOf: C) ifTrue: [^self].
	((self isMemberOf: V) & ((value == nil) not)) ifTrue: [self val]! !
!Term categoriesFor: #eval!public! !

!Term methodsFor!
eval
	| tmp |
	(self isMemberOf: Pair) ifTrue: [tmp := Pair new. tmp car: (self car eval) cdr: (self cdr eval) ].
	(self isMemberOf: C) ifTrue: [^self].
	((self isMemberOf: V) & ((value == nil) not)) ifTrue: [self val]! !
!Term categoriesFor: #eval!public! !

!Database methodsFor!
find: term index: index
	| len  work i t|
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[ i := i + 1.
			  t := (rules at: i) trans.
			]! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	| len  work i t|
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[ i := i + 1.
			  t := (rules at: i) trans.
			]! !
!Database categoriesFor: #find:index:!public! !

!Rule methodsFor!
trans
	! !
!Rule categoriesFor: #trans!public! !

Term subclass: #V
	instanceVariableNames: 'addr refers'
	classVariableNames: 'VarsDict FreeVars'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: 'addr refers'
	classVariableNames: 'FreeVars VarsDict'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!V class methodsFor!
var: i
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new.].
	tmp := VarsDict includesKey: i.
	(tmp) ifTrue: 
			[arr := VarsDict at:i]
			ifFalse:
			[arr :=VarsDict at: i put: (V new addr: i )].
	^arr
	! !
!V class categoriesFor: #var:!public! !

!V class methodsFor!
var: i
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new. FreeVars := Set new].
	tmp := VarsDict includesKey: i.
	(tmp) ifTrue: 
			[arr := VarsDict at:i]
			ifFalse:
			[arr :=VarsDict at: i put: (V new addr: i )].
	^arr
	! !
!V class categoriesFor: #var:!public! !

!V class methodsFor!
var: i
	| tmp arr s|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new. FreeVars := Set new].
	tmp := VarsDict includesKey: i.
	FreeVars := FreeVars -  
	(tmp) ifTrue: 
			[arr := VarsDict at:i]
			ifFalse:
			[arr :=VarsDict at: i put: (V new addr: i )].
	^arr
	! !
!V class categoriesFor: #var:!public! !

!V class methodsFor!
var: i
	| tmp arr s|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new. FreeVars := Set new].
	tmp := VarsDict includesKey: i.
	s := Set new.
	s add: i.
	FreeVars := FreeVars - s.  
	(tmp) ifTrue: 
			[arr := VarsDict at:i]
			ifFalse:
			[arr :=VarsDict at: i put: (V new addr: i )].
	^arr
	! !
!V class categoriesFor: #var:!public! !

!V class methodsFor!
FreeVar
	| tmp |
	tmp := FreeVars anyOne.
	! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
FreeVar
	| tmp |
	tmp := FreeVars anyOne.
	FreeVars remove: tmp! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
FreeVar
	| tmp |
	tmp := FreeVars anyOne.
	FreeVars remove: tmp.
	! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
FreeVar
	| v tmp |
	tmp := FreeVars anyOne.
	FreeVars remove: tmp.
	v := V @ tmp.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

Term subclass: #V
	instanceVariableNames: 'addr refers'
	classVariableNames: 'UsedVars VarsDict'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: 'addr refers'
	classVariableNames: 'UsedVars VarsDict'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: 'addr refers'
	classVariableNames: 'UsedVars VarsDict'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: 'addr refers'
	classVariableNames: 'UsedVars VarsDict'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: 'addr refers'
	classVariableNames: 'UsedVars VarsDict'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: 'addr refers'
	classVariableNames: 'UsedVars VarsDict'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!V class methodsFor!
var: i
	| tmp arr s|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new. UsedVars := Set new].
	tmp := VarsDict includesKey: i.
	UsedVars add: i.
	(tmp) ifTrue: 
			[arr := VarsDict at:i]
			ifFalse:
			[arr :=VarsDict at: i put: (V new addr: i )].
	^arr
	! !
!V class categoriesFor: #var:!public! !

Term subclass: #V
	instanceVariableNames: 'addr refers'
	classVariableNames: 'UsedVars VarsDict index'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: 'addr refers'
	classVariableNames: 'Index UsedVars VarsDict'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: 'addr refers'
	classVariableNames: 'Index UsedVars VarsDict'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: 'addr refers'
	classVariableNames: 'Index UsedVars VarsDict'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Term subclass: #V
	instanceVariableNames: 'addr refers'
	classVariableNames: 'Index UsedVars VarsDict'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!V class methodsFor!
FreeVar
	| v tmp |
	v := V @ tmp.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
FreeVar
	| v tmp |
	(UsedVars includes: Index) whileTrue: [Index ;= Index + 1].
	v := V @ tmp.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
FreeVar
	| v tmp |
	(UsedVars includes: Index) whileTrue: [Index := Index + 1].
	v := V @ tmp.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
FreeVar
	| v tmp |
	(UsedVars includes: Index) whileTrue: [Index := Index + 1].
	v := V @ tmp.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
FreeVar
	| v tmp |
	[UsedVars includes: Index] whileTrue: [Index := Index + 1].
	v := V @ tmp.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
FreeVar
	| v tmp |
	[UsedVars includes: Index] whileTrue: [Index := Index + 1].
	v := V @ Index.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
FreeVar
	| v |
	[UsedVars includes: Index] whileTrue: [Index := Index + 1].
	v := V @ Index.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
FreeVar
	| v |
	[UsedVars includes: Index] whileTrue: [Index := Index + 1].
	v := V @ Index.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
FreeVar
	| v |
	[UsedVars includes: Index] whileTrue: [Index := Index + 1].
	v := V @ Index.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
FreeVar
	| v |
	[UsedVars includes: Index] whileTrue: [Index := Index + 1].
	v := V @ Index.
	Index := Index + 1.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
FreeVar
	| v |
	[UsedVars includes: Index] whileTrue: [Index := Index + 1].
	v := V @ Index.
	Index := Index + 1.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

V reset.!

tmp := V FreeVar!

!V class methodsFor!
FreeVar
	| v |
	[UsedVars find: Index] whileTrue: [Index := Index + 1].
	v := V @ Index.
	Index := Index + 1.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
FreeVar
	| v |
	[UsedVars find: Index] whileTrue: [Index := Index + 1].
	v := V @ Index.
	Index := Index + 1.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
FreeVar
	| v |
	[(UsedVars indexOf: Index) > 0] whileTrue: [Index := Index + 1].
	v := V @ Index.
	Index := Index + 1.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
FreeVar
	| v |
	[(UsedVars indexOf: Index) > 0] whileTrue: [Index := Index + 1].
	v := V @ Index.
	Index := Index + 1.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
FreeVar
	| v |
	[(UsedVars indexOf: Index) > 0] whileTrue: [Index := Index + 1].
	v := V @ Index.
	Index := Index + 1.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
FreeVar
	| v |
	[(UsedVars indexOf: Index) > 0] whileTrue: [Index := Index + 1].
	v := V @ Index.
	Index := Index + 1.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
FreeVar
	| v |
	[(UsedVars indexOf: Index) > 0] whileTrue: [Index := Index + 1].
	v := V @ Index.
	Index := Index + 1.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

V reset.!

tmp := V FreeVar!

!V class methodsFor!
FreeVar
	| v |
	(UsedVars == nil) ifTrue: [UsedVars   := Dictionary  new. UsedVars := Set new].
	[(UsedVars indexOf: Index) > 0] whileTrue: [Index := Index + 1].
	v := V @ Index.
	Index := Index + 1.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
FreeVar
	| v |
	(UsedVars == nil) ifTrue: [UsedVars := Set new].
	[(UsedVars indexOf: Index) > 0] whileTrue: [Index := Index + 1].
	v := V @ Index.
	Index := Index + 1.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

V reset.!

tmp := V FreeVar!

V reset.!

tmp := V FreeVar!

!V class methodsFor!
FreeVar
	| v |
	(UsedVars == nil) ifTrue: [UsedVars := Set new].
	[(UsedVars includes: Index) ] whileTrue: [Index := Index + 1].
	v := V @ Index.
	Index := Index + 1.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
FreeVar
	| v |
	(UsedVars == nil) ifTrue: [UsedVars := Set new].
	[(UsedVars includes: Index) ] whileTrue: [Index := Index + 1].
	v := V @ Index.
	Index := Index + 1.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

V reset.!

tmp := V FreeVar!

!V class methodsFor!
FreeVar
	| v |
	(UsedVars == nil) ifTrue: [UsedVars := Set new. Index:=0].
	[(UsedVars includes: Index) ] whileTrue: [Index := Index + 1].
	v := V @ Index.
	Index := Index + 1.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
var: i
	| tmp arr s|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new. UsedVars := Set new. Index:=0].
	tmp := VarsDict includesKey: i.
	UsedVars add: i.
	(tmp) ifTrue: 
			[arr := VarsDict at:i]
			ifFalse:
			[arr :=VarsDict at: i put: (V new addr: i )].
	^arr
	! !
!V class categoriesFor: #var:!public! !

!V class methodsFor!
var: i
	| tmp arr s|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new. UsedVars := Set new. Index:=0].
	tmp := VarsDict includesKey: i.
	UsedVars add: i.
	(tmp) ifTrue: 
			[arr := VarsDict at:i]
			ifFalse:
			[arr :=VarsDict at: i put: (V new addr: i )].
	^arr
	! !
!V class categoriesFor: #var:!public! !

V reset.!

tmp := V FreeVar!

!V class methodsFor!
var: i
	| tmp arr s|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new. UsedVars := Set new. Index:=0].
	tmp := VarsDict includesKey: i.
	UsedVars add: i.
	(tmp) ifTrue: 
			[arr := VarsDict at:i]
			ifFalse:
			[arr :=VarsDict at: i put: (V new addr: i )].
	^arr
	! !
!V class categoriesFor: #var:!public! !

!V class methodsFor!
FreeVar
	| v |
	(UsedVars == nil) ifTrue: [UsedVars := Set new. Index:=0].
	[(UsedVars includes: Index) ] whileTrue: [Index := Index + 1].
	v := V @ Index.
	Index := Index + 1.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

tmp := V FreeVar!

tmp := V FreeVar!

!V class methodsFor!
reset
	VarsDict:= Dictionary new.
	UsedVars:= Set new.
	Index :=0.! !
!V class categoriesFor: #reset!public! !

tmp := V FreeVar!

V reset.!

tmp := V FreeVar!

"16:38:30, 19 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\part2\p.img7'"!

tmp!

!Rule methodsFor!
trans
	| dict |
	dict := Dictionary new.
	! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b|
	dict := Dictionary new.
	h := head getVarsList.
	! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len|
	dict := Dictionary new.
	h := head getVarsList.
	len := body size.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i). dict at: b put: (V FreeVar)]! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len|
	dict := Dictionary new.
	h := head getVarsList.
	len := body size.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1]! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len|
	dict := Dictionary new.
	h := head getVarsList.
	len := body size.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len|
	dict := Dictionary new.
	h := head getVarsList.
	len := body size.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	! !
!Rule categoriesFor: #trans!public! !

!Term methodsFor!
anonim: dict
	! !
!Term categoriesFor: #anonim:!public! !

!Term methodsFor!
anonim: dict
	| tmp |
	(self isMemberOf: Pair) ifTrue: [tmp := Pair new. tmp car: (self car eval) cdr: (self cdr eval) ].
	(self isMemberOf: C) ifTrue: [^self].
	((self isMemberOf: V) & ((value == nil) not)) ifTrue: [self val]! !
!Term categoriesFor: #anonim:!public! !

!Term methodsFor!
anonim: dict
	| tmp |
	(self isMemberOf: Pair) ifTrue: [tmp := Pair new. tmp car: (self car anonim: dict) cdr: (self cdr anonim:dict) ].
	(self isMemberOf: C) ifTrue: [^self].
	((self isMemberOf: V) & ((value == nil) not)) ifTrue: [self val]! !
!Term categoriesFor: #anonim:!public! !

!Term methodsFor!
anonim: dict
	| tmp |
	(self isMemberOf: Pair) ifTrue: [tmp := Pair new. tmp car: ((self car) anonim: dict) cdr: ((self cdr) anonim:dict) ].
	(self isMemberOf: C) ifTrue: [^self].
	((self isMemberOf: V) & ((value == nil) not)) ifTrue: [self val]! !
!Term categoriesFor: #anonim:!public! !

!Term methodsFor!
anonim: dict
	| tmp |
	(self isMemberOf: Pair) ifTrue: [tmp := Pair new. tmp car: ((self car) anonim: dict) cdr: ((self cdr) anonim:dict) ].
	(self isMemberOf: C) ifTrue: [^self].
	((self isMemberOf: V)) ifTrue: [^(dict at: self)]! !
!Term categoriesFor: #anonim:!public! !

!Term methodsFor!
anonim: dict
	| tmp |
	(self isMemberOf: Pair) ifTrue: [tmp := Pair new. tmp car: ((self car) anonim: dict) cdr: ((self cdr) anonim:dict) ].
	(self isMemberOf: C) ifTrue: [^self].
	((self isMemberOf: V)) ifTrue: [^(dict at:type)]! !
!Term categoriesFor: #anonim:!public! !

!V methodsFor!
addr
	^addr! !
!V categoriesFor: #addr!accessing!private! !

!V methodsFor!
addr1: anObject
	addr := anObject! !
!V categoriesFor: #addr1:!accessing!private! !

!V categoriesFor: #addr!accessing!public! !

!V methodsFor!
addr
	^addr! !
!V categoriesFor: #addr!accessing!public! !

!Term methodsFor!
anonim: dict
	| tmp |
	(self isMemberOf: Pair) ifTrue: [tmp := Pair new. tmp car: ((self car) anonim: dict) cdr: ((self cdr) anonim:dict) ].
	(self isMemberOf: C) ifTrue: [^self].
	((self isMemberOf: V)) ifTrue: [^(dict at: (self addr))]! !
!Term categoriesFor: #anonim:!public! !

!Term methodsFor!
anonim: dict
	| tmp |
	(self isMemberOf: Pair) ifTrue: [tmp := Pair new. tmp car: ((self car) anonim: dict) cdr: ((self cdr) anonim:dict) ].
	(self isMemberOf: C) ifTrue: [^self].
	((self isMemberOf: V)) ifTrue: [^(dict at: (self addr))]! !
!Term categoriesFor: #anonim:!public! !

!C methodsFor!
anonim: dict
	! !
!C categoriesFor: #anonim:!public! !

!C methodsFor!
anonim: dict
	^self! !
!C categoriesFor: #anonim:!public! !

!C methodsFor!
anonim: dict
	^self! !
!C categoriesFor: #anonim:!public! !

!Pair methodsFor!
anonim: dict
	| tmp |
	tmp := Pair new. 
	tmp car: (self car eval) cdr: (self cdr eval).
	^tmp.
! !
!Pair categoriesFor: #anonim:!public! !

!V methodsFor!
anonim: dict
	! !
!V categoriesFor: #anonim:!public! !

!V methodsFor!
anonim: dict
	! !
!V categoriesFor: #anonim:!public! !

!Pair methodsFor!
anonim: dict
	| tmp |
	tmp := Pair new. 
	tmp car: (self car anonim) cdr: (self cdr eval).
	^tmp.
! !
!Pair categoriesFor: #anonim:!public! !

!Pair methodsFor!
anonim: dict
	| tmp |
	tmp := Pair new. 
	tmp car: ((self car) anonim:dict) cdr: ((self cdr) anonim: dict ).
	^tmp.
! !
!Pair categoriesFor: #anonim:!public! !

!Pair methodsFor!
anonim: dict
	| tmp |
	tmp := Pair new. 
	tmp car: ((self car) anonim:dict) cdr: ((self cdr) anonim: dict ).
	^tmp.
! !
!Pair categoriesFor: #anonim:!public! !

!V methodsFor!
anonim: dict
	^(dict at: addr)! !
!V categoriesFor: #anonim:!public! !

V removeSelector: #addr ifAbsent: []!

V removeSelector: #addr1: ifAbsent: []!

!Term methodsFor!
anonim: dict! !
!Term categoriesFor: #anonim:!public! !

!C methodsFor!
eval
	^self! !
!C categoriesFor: #eval!public! !

!C methodsFor!
eval
	^self! !
!C categoriesFor: #eval!public! !

!Pair methodsFor!
eval
	| tmp |
	tmp := Pair new. tmp car: (self car eval) cdr: (self cdr eval).
	^tmp.
! !
!Pair categoriesFor: #eval!public! !

!V methodsFor!
eval
	((value == nil)) ifTrue: [self val]! !
!V categoriesFor: #eval!public! !

!Term methodsFor!
eval! !
!Term categoriesFor: #eval!public! !

!V methodsFor!
eval
	((value == nil) not) ifTrue: [self val]! !
!V categoriesFor: #eval!public! !

!V methodsFor!
eval
	((value == nil) not) ifTrue: [self val]! !
!V categoriesFor: #eval!public! !

!V methodsFor!
eval
	((value == nil) not) ifTrue: [self val]! !
!V categoriesFor: #eval!public! !

!V methodsFor!
eval
	((value == nil) not) ifTrue: [^self val] ifFalse: [^self]! !
!V categoriesFor: #eval!public! !

!Rule methodsFor!
trans
	| dict h b i len|
	dict := Dictionary new.
	h := head getVarsList.
	len := body size.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	dict at: h put: (V FreeVar).
	! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len|
	dict := Dictionary new.
	h := head getVarsList.
	len := body size.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	dict at: h put: (V FreeVar).
	h anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len|
	dict := Dictionary new.
	h := head getVarsList.
	len := body size.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	dict at: h put: (V FreeVar).
	h anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b anonim. i := i + 1].! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len|
	dict := Dictionary new.
	h := head getVarsList.
	len := body size.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	dict at: h put: (V FreeVar).
	h anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b anonim: dict. i := i + 1].! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len|
	dict := Dictionary new.
	h := head getVarsList.
	len := body size.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	dict at: h put: (V FreeVar).
	h anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b anonim: dict. i := i + 1].! !
!Rule categoriesFor: #trans!public! !

V reset.!

tmp := Rule new.!

tmp head: (V @ 1, C % 7) body: (C % 1, C % 7) !

!Rule methodsFor!
head: h body: b
	head := h.
	body := b.! !
!Rule categoriesFor: #head:body:!public! !

!Rule methodsFor!
head: h body: b
	head := h.
	body := b.! !
!Rule categoriesFor: #head:body:!public! !

V reset.!

tmp := Rule new.!

tmp head: (V @ 1, C % 7) body: (C % 1, C % 7) !

tmp!

V reset.!

tmp := Rule new.!

tmp head: ((V @ 1), (C % 7)) body: (C % 1, C % 7)!

tmp!

tmp := Rule new.!

tmp head: ((V @ 1), (C % 7)) body: ((C % 1), (C % 7))!

tmp!

x:= tmp trans!

V reset.!

tmp := Rule new.!

tmp head: ((V @ 1), (C % 7)) body: #(((C % 1), (C % 7)))!

tmp!

x:= tmp trans!

arr := Array new.!

arr resize:1!

arr at: 1 put:  ((C % 1), (C % 7))!

tmp := Rule new.!

tmp head: ((V @ 1), (C % 7)) body: arr!

tmp!

x:= tmp trans!

V reset.!

tmp := Rule new.!

arr := Array new.!

arr at: 1 put:  ((C % 1), (C % 7))a!

arr at: 1 put:  ((C % 1), (C % 7))!

V reset.!

tmp := Rule new.!

arr := Array new.!

arr resize:1!

arr at: 1 put:  ((C % 1), (C % 7))!

tmp head: ((V @ 1), (C % 7)) body: arr!

x:= tmp trans!

"17:10:18, 19 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\marsz\p.img7'"!

!Rule methodsFor!
trans
	| dict h b i len|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	dict at: h put: (V FreeVar).
	h anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b anonim: dict. i := i + 1].! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vars| b := (body at:i). vars:= b getVarsList. j:=1. [j<= (vars size)] whileTrue: [((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. j:=j+1]. i:=i+1].
	dict at: h put: (V FreeVar).
	h anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b anonim: dict. i := i + 1].! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vars | b := (body at:i). vars:= b getVarsList. j:=1. [j<= (vars size)] whileTrue: [((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. j:=j+1]. i:=i+1].
	dict at: h put: (V FreeVar).
	h anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b anonim: dict. i := i + 1].! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. j:=j+1]. i:=i+1].
	dict at: h put: (V FreeVar).
	h anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b anonim: dict. i := i + 1].! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=b at j. ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. j:=j+1]. i:=i+1].
	dict at: h put: (V FreeVar).
	h anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b anonim: dict. i := i + 1].! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=b at: j. ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. j:=j+1]. i:=i+1].
	dict at: h put: (V FreeVar).
	h anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b anonim: dict. i := i + 1].! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=b at: j. ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. j:=j+1]. i:=i+1].
	dict at: h put: (V FreeVar).
	h anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b anonim: dict. i := i + 1].! !
!Rule categoriesFor: #trans!public! !

V reset.!

tmp := Rule new.!

arr := Array new.!

arr resize:1!

arr at: 1 put:  ((C % 1), (C % 7))!

tmp head: ((V @ 1), (C % 7)) body: arr!

x:= tmp trans!

x!

V reset.!

tmp := Rule new.!

arr := Array new.!

arr resize:1!

arr at: 1 put:  ((C % 1), (C % 7))!

tmp head: ((V @ 1), (C % 7)) body: arr!

!Rule methodsFor!
trans
	| dict h b i len|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=b at: j. ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. j:=j+1]. i:=i+1].
	h anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b anonim: dict. i := i + 1].! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=b at: j. ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. j:=j+1]. i:=i+1].
	h anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b anonim: dict. i := i + 1].! !
!Rule categoriesFor: #trans!public! !

x:= tmp trans!

!Rule methodsFor!
trans
	| dict h b i len|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=b at: j. ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. j:=j+1]. i:=i+1].
	head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b anonim: dict. i := i + 1].! !
!Rule categoriesFor: #trans!public! !

V reset.!

tmp := Rule new.!

arr := Array new.!

arr resize:1!

arr at: 1 put:  ((C % 1), (C % 7))!

tmp head: ((V @ 1), (C % 7)) body: arr!

x:= tmp trans!

!V methodsFor!
anonim: dict
	^(dict at: self)! !
!V categoriesFor: #anonim:!public! !

!V methodsFor!
anonim: dict
	^(dict at: self)! !
!V categoriesFor: #anonim:!public! !

!V methodsFor!
anonim: dict
	^(dict at: self)! !
!V categoriesFor: #anonim:!public! !

V reset.
tmp := Rule new.
arr := Array new.
arr resize:1
arr at: 1 put:  ((C % 1), (C % 7))
tmp head: ((V @ 1), (C % 7)) body: arr!

V reset.!

tmp := Rule new.!

arr := Array new.!

arr resize:1!

arr at: 1 put:  ((C % 1), (C % 7))!

tmp head: ((V @ 1), (C % 7)) body: arr!

x:= tmp trans!

V reset.
tmp := Rule new.
arr := Array new.
arr resize:1.
arr at: 1 put:  ((C % 1), (C % 7)).
tmp head: ((V @ 1), (C % 7)) body: arr.!

x:= tmp trans!

x!

!Rule methodsFor!
trans
	| dict h b i len tmp|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=b at: j. ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. j:=j+1]. i:=i+1].
	head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b anonim: dict. i := i + 1].
	tmp := Pair new.
	tmp car: head cdr: body.
	^tmp! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=b at: j. ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. j:=j+1]. i:=i+1].
	head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b anonim: dict. i := i + 1].
	tmp := Pair new.
	tmp car: head cdr: body.
	^tmp! !
!Rule categoriesFor: #trans!public! !

V reset.
tmp := Rule new.
arr := Array new.
arr resize:1.
arr at: 1 put:  ((C % 1), (C % 7)).
tmp head: ((V @ 1), (C % 7)) body: arr.!

x:= tmp trans!

x!

V reset.
tmp := Rule new.
arr := Array new.
arr resize:1.
arr at: 1 put:  ((C % 1), (C % 7)).
tmp head: ((V @ 1), (C % 7)) body: arr.
!

x:= tmp transa Pair!

x:= tmp trans!

!Rule methodsFor!
trans
	| dict h b i len tmp|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=b at: j. ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. j:=j+1]. i:=i+1].
	head := head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b := b anonim: dict. i := i + 1].
	tmp := Pair new.
	tmp car: head cdr: body.
	^tmp! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=b at: j. ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. j:=j+1]. i:=i+1].
	head := head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b := b anonim: dict. i := i + 1].
	tmp := Pair new.
	tmp car: head cdr: body.
	^tmp! !
!Rule categoriesFor: #trans!public! !

V reset.
tmp := Rule new.
arr := Array new.
arr resize:1.
arr at: 1 put:  ((C % 1), (C % 7)).
tmp head: ((V @ 1), (C % 7)) body: arr.!

x:= tmp trans!

x!

"21:31:16, 19 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\pomarszy\xasd.img7'"!

!Database methodsFor!
find: term index: index
	| len  work i t|
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[ i := i + 1.
			  t := (rules at: i) trans.
			]! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	| len  work i t h|
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[ i := i + 1.
			  t := (rules at: i) trans.
			  h := t head.
			]! !
!Database categoriesFor: #find:index:!public! !

!Rule methodsFor!
head
	^head! !
!Rule categoriesFor: #head!public! !

!Rule methodsFor!
body
	^body! !
!Rule categoriesFor: #body!public! !

!Database methodsFor!
find: term index: index
	| len  work i t h|
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[ i := i + 1.
			  t := (rules at: i) trans.
			  h := t head.
			  term go: h do: []
			]! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	| len  work i t h|
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[ i := i + 1.
			  t := (rules at: i) trans.
			  h := t head.
			  term go: h do: [work := false]
			]! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	| len  work i t h|
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[ i := i + 1.
			  t := (rules at: i) trans.
			  h := t head.
			  term go: h do: [work := false]
			].
	(i > len) ifTrue: [^Error]! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	| len  work i t h|
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[ i := i + 1.
			  t := (rules at: i) trans.
			  h := t head.
			  term go: h do: [work := false. ^t body]
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[ i := i + 1.
			  t := (rules at: i) trans.
			  h := t head.
			  term go: h do: [work := false. ^t body]
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[ i := i + 1.
			  t := (rules at: i) trans.
			  h := t head.
			  term go: h do: [work := false. ^t body]
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[ i := i + 1.
			  t := (rules at: i) trans.
			  h := t head.
			  term go: h do: [work := false. p car: (t body) cdr: i . ^p]
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[ i := i + 1.
			  t := (rules at: i) trans.
			  h := t head.
			  term go: h do: [work := false. p car: (t body) cdr: i . ^p]
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[ i := i + 1.
			  t := (rules at: i) trans.
			  h := t head.
			  term go: h do: [work := false. p car: (t body) cdr: i . ^p]
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[ i := i + 1.
			  t := (rules at: i) trans.
			  h := t head.
			  term go: h do: [work := false. p car: (t body) cdr: i . ^p]
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[ i := i + 1.
			  t := (rules at: i) trans.
			  h := t head.
			  term go: h do: [work := false. p car: (t body) cdr: i . ^p]
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[ i := i + 1.
			  t := (rules at: i) trans.
			  h := t head.
			  term go: h do: [work := false. p car: (t body) cdr: i . ^p]
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

p := Prolog new.!

p head: ((C % 1),(C %2)) body: []!

p head: ((C % 1),(C %2)) body: []!

p head: ((C % 1),(C %2)) body: []!

p head: ((C % 1),(C %2)) body: []!

p !

db := Database new!

db addRule: ((C % 1),(C %2))!

db addRule: ((C % 1),(C %2))!

!Database class methodsFor!
new
	| tmp |
	tmp := super new.
	tmp init.
	^ tmp! !
!Database class categoriesFor: #new!public! !

db := Database new!

db addRule: ((C % 1),(C %2))!

p := Prolog new.!

p head: ((C % 1),(C %2)) body: []!

p head: ((C % 1),(C %2)) body: []!

p!

p := Prolog new.!

p head: ((C % 1),(C %2)) body: []!

p!

!Prolog methodsFor!
go: ask do: action
	database find: ask index: 1.
	! !
!Prolog categoriesFor: #go:do:!public! !

p go: ((V @ 0),(C %2))  do: []!

!Database methodsFor!
find: term index: index
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[
			  t := (rules at: i) trans.
			  h := t head.
			  term go: h do: [work := false. p car: (t body) cdr: i . ^p].
			  i := i + 1.
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

p go: ((V @ 0),(C %2))  do: []!

!Database methodsFor!
find: term index: index
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[
			  t := (rules at: i) trans.
			  h := t car.
			  term go: h do: [work := false. p car: (t body) cdr: i . ^p].
			  i := i + 1.
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[
			  t := (rules at: i) trans.
			  h := t car.
			  term go: h do: [work := false. p car: (t body) cdr: i . ^p].
			  i := i + 1.
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

p go: ((V @ 0),(C %2))  do: []!

p go: ((V @ 0),(C %2))  do: []!

!Database methodsFor!
find: term index: index
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[
			  t := (rules at: i) trans.
			  h := t car.
			  term go: h do: [work := false. p car: (t cdr) cdr: i . ^p].
			  i := i + 1.
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

p go: ((V @ 0),(C %2))  do: []!

p go: ((V @ 0),(C %2))  do: []!

!Database methodsFor!
find: term index: index
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[
			  t := (rules at: i) trans.
			  h := t car.
			  term go: h do: [work := false. p car: (t car) cdr: i . ^p].
			  i := i + 1.
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

p go: ((V @ 0),(C %2))  do: []!

p go: ((V @ 0),(C %2))  do: []!

!Rule methodsFor!
trans
	| dict h b i len tmp r created|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=b at: j. ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. j:=j+1]. i:=i+1].
	head := head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b := b anonim: dict. i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: head body: body.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=b at: j. ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. j:=j+1]. i:=i+1].
	head := head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b := b anonim: dict. i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: head body: body.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=b at: j. ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. j:=j+1]. i:=i+1].
	head := head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b := b anonim: dict. i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: head body: body.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

V reset.
tmp := Rule new.
arr := Array new.
arr resize:1.
arr at: 1 put:  ((C % 1), (C % 7)).
tmp head: ((V @ 1), (C % 7)) body: arr.!

x:= tmp trans!

x!

!Database methodsFor!
find: term index: index
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[
			  t := (rules at: i) trans.
			  h := t car head.
			  term go: h do: [work := false. p car: (t car body) cdr: i . ^p].
			  i := i + 1.
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[
			  t := (rules at: i) trans.
			  h := t car head.
			  term go: h do: [work := false. p car: (t car body) cdr: i . ^p].
			  V delete: t cdr.
			  i := i + 1.
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[
			  t := (rules at: i) trans.
			  h := t car head.
			  term go: h do: [work := false. p car: (t car body) cdr: i . ^p].
			  V delete: t cdr.
			  i := i + 1.
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

!V class methodsFor!
delete: bag
	! !
!V class categoriesFor: #delete:!public! !

!V class methodsFor!
delete: bag
	UsedVars := UsedVars - bag.! !
!V class categoriesFor: #delete:!public! !

!V class methodsFor!
delete: bag
	UsedVars := UsedVars - bag.! !
!V class categoriesFor: #delete:!public! !

p := Prolog new.!

p head: ((C % 1),(C %2)) body: []!

p go: ((V @ 0),(C %2))  do: []!

p head: ((C % 1),(C %3)) body: []!

p go: ((V @ 0),(C %2))  do: []!

p := Prolog new.!

p head: ((C % 1),(C %3)) body: []!

p head: ((C % 1),(C %2)) body: []!

p go: ((V @ 0),(C %2))  do: []!

p := Prolog new.!

p head: ((V @ 1),(C %3)) body: []!

p head: ((C % 1),(C %2)) body: []!

p go: ((V @ 0),(C %2))  do: []!

p go: ((V @ 0),(C %2))  do: []!

p go: ((V @ 0),(C %2))  do: []!

p go: ((V @ 0),(C %2))  do: []!

V reset.!

p := Prolog new.!

p head: ((V @ 1),(C %3)) body: []!

p head: ((C % 1),(C %2)) body: []!

p go: ((V @ 0),(C %2))  do: []!

d := Dictionary new.!

d at: 0 put:1.!

d associations!

d values!

p go: ((V @ 0),(C %2))  do: []!

!Prolog methodsFor!
go: ask do: action
	^database find: ask index: 1.
	! !
!Prolog categoriesFor: #go:do:!public! !

p := Prolog new.!

V reset!

p head: ((V @ 1),(C %3)) body: []!

p head: ((C % 1),(C %2)) body: []!

x:= p go: ((V @ 0),(C %2))  do: []!

x!

p !

p := Prolog new.
V reset!

p head: ((V @ 1),(C %3)) body: []!

p head: ((C % 1),(C %2)) body: []!

x:= p go: ((V @ 0),(C %2))  do: []!

p := Prolog new.
V reset!

p head: ((V @ 1),(C %3)) body: [].
p head: ((C % 1),(C %2)) body: [].!

p!

x:= p go: ((V @ 0),(C %2))  do: []!

p := Prolog new.
V reset.
p head: ((V @ 1),(C %3)) body: [].
p head: ((C % 1),(C %2)) body: [].!

x:= p go: ((V @ 0),(C %2))  do: []!

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead |
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=b at: j. ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. j:=j+1]. i:=i+1].
	head := head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b := b anonim: dict. i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: head body: body.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead |
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=b at: j. ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b := b anonim: dict. i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: head body: body.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead |
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=b at: j. ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b := b anonim: dict. i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: body.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead |
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=b at: j. ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b := b anonim: dict. i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: body.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

p := Prolog new.
V reset.
p head: ((V @ 1),(C %3)) body: [].
p head: ((C % 1),(C %2)) body: [].!

x:= p go: ((V @ 0),(C %2))  do: []!

x!

p!

"23:15:35, 19 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\noc\xasd.img7'"!

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!Fitter methodsFor!
match: rule
	
	! !
!Fitter categoriesFor: #match:!public! !

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!Fitter methodsFor!
setDatabase: db
	database := db! !
!Fitter categoriesFor: #setDatabase:!public! !

!Fitter methodsFor!
setDatabase: db
	database := db! !
!Fitter categoriesFor: #setDatabase:!public! !

!Fitter methodsFor!
setDatabase: db
	database := db
	! !
!Fitter categoriesFor: #setDatabase:!public! !

!Fitter methodsFor!
match: rule
	^database find: rule index: 1.
	
	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match: rule
	| res |
	res := database find: rule index: 1.
	
	
	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match: rule
	| res |
	res := database find: rule index: 1.
	
	
	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match: rule
	| res fit i |
	res := database find: rule index: 1.
	dbIndex := res cdr.
	fit := res car.
	i := 1.
	[ i >= 1 & i <= (fit size)] whileTrue: 
		[
		  
		] 
	
	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match: rule
	| res fit i |
	res := database find: rule index: 1.
	dbIndex := res cdr.
	fit := res car.
	i := 1.
	[ i >= 1 & i <= (fit size)] whileTrue: 
		[
		  
		] 
	
	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
setRule: rule setDatabase: db
	database := db
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Fitter removeSelector: #setDatabase: ifAbsent: []!

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r.
	database := db
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

!Fitter methodsFor!
match
	| res fit i |
	res := database find: rule index: 1.
	dbIndex := res cdr.
	fit := res car.
	i := 1.
	[ i >= 1 & i <= (fit size)] whileTrue: 
		[
		  
		] 
	
	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i |
	res := database find: rule index: 1.
	dbIndex := res cdr.
	fit := res car.
	i := 1.
	[ i >= 1 & i <= (fit size)] whileTrue: 
		[
		  
		] 
	
	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r.
	database := db.
	dbIndex :=1.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

Fitter removeSelector: #match: ifAbsent: []!

!Fitter methodsFor!
match
	| res fit i |
	res := database find: rule index: dbIndex .
	dbIndex := res cdr.
	fit := res car.
	i := 1.
	[ i >= 1 & i <= (fit size)] whileTrue: 
		[
		  
		] 
	
	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans tmp|
	res := database find: rule index: dbIndex.
	dbIndex := res cdr.
	fit := res car.
	i := 1.
	[ i >= 1 & i <= (fit size)] whileTrue: 
		[
		  ans := (fit at: i) match
		] 
	
	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans tmp|
	res := database find: rule index: dbIndex.
	dbIndex := res cdr.
	fit := res car.
	i := 1.
	[ i >= 1 & i <= (fit size)] whileTrue: 
		[
		  ans := (fit at: i) match.
		  (ans == Error) ifTrue: [i := -1]
		  ifFalse: []
		] 
	
	! !
!Fitter categoriesFor: #match!public! !

"23:31:49, 19 czerwca 2017: Image saved"!

"23:31:50, 19 czerwca 2017: Image saved"!

"23:31:56, 19 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\spoko\ggg.img7'"!

!Fitter methodsFor!
match
	| res fit i ans tmp|
	res := database find: rule index: dbIndex.
	dbIndex := res cdr.
	fit := res car.
	i := 1.
	[ i >= 1 & i <= (fit size)] whileTrue: 
		[
		  ans := (fit at: i) match.
		  (ans == Error) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		] 
	
	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans tmp|
	res := database find: rule index: dbIndex.
	dbIndex := res cdr.
	fit := res car.
	i := 1.
	[ i >= 1 & i <= (fit size)] whileTrue: 
		[
		  ans := (fit at: i) match.
		  (ans == Error) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans tmp|
	res := database find: rule index: dbIndex.
	dbIndex := res cdr.
	fit := res car.
	i := 1.
	[ i >= 1 & i <= (fit size)] whileTrue: 
		[
		  ans := (fit at: i) match.
		  (ans == Error) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers|
	res := database find: rule index: dbIndex.
	dbIndex := res cdr.
	fit := res car.
	i := 1.
	[ i >= 1 & i <= (fit size)] whileTrue: 
		[
		  ans := (fit at: i) match.
		  (ans == Error) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers|
	res := database find: rule index: dbIndex.
	dbIndex := res cdr.
	fit := res car.
	i := 1.
	[ i >= 1 & i <= (fit size)] whileTrue: 
		[
		  ans := (fit at: i) match.
		  (ans == Error) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers|
	res := database find: rule index: dbIndex.
	dbIndex := res cdr.
	fit := res car.
	i := 1.
	fit do: [:elem | matchers
	[ i >= 1 & i <= (fit size)] whileTrue: 
		[
		  ans := (fit at: i) match.
		  (ans == Error) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers|
	res := database find: rule index: dbIndex.
	dbIndex := res cdr.
	fit := res car.
	i := 1.
	fit do: [:elem | matchers resize: ((matchers size) + 1).]. 
	[ i >= 1 & i <= (fit size)] whileTrue: 
		[
		  ans := (fit at: i) match.
		  (ans == Error) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp|
	res := database find: rule index: dbIndex.
	dbIndex := res cdr.
	fit := res car.
	i := 1.
	fit do: [:elem | matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]. 
	[ i >= 1 & i <= (fit size)] whileTrue: 
		[
		  ans := (fit at: i) match.
		  (ans == Error) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp|
	res := database find: rule index: dbIndex.
	dbIndex := res cdr.
	fit := res car.
	i := 1.
	fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]. 
	[ i >= 1 & i <= (fit size)] whileTrue: 
		[
		  ans := (fit at: i) match.
		  (ans == Error) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp|
	res := database find: rule index: dbIndex.
	dbIndex := res cdr.
	fit := res car.
	i := 1.
	matchers := Array new.
	fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]. 
	[ i >= 1 & i <= (fit size)] whileTrue: 
		[
		  ans := (fit at: i) match.
		  (ans == Error) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp|
	res := database find: rule index: dbIndex.
	dbIndex := res cdr.
	fit := res car.
	i := 1.
	matchers := Array new.
	fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]. 
	[ i >= 1 & i <= (fit size)] whileTrue: 
		[
		  ans := (fit at: i) match.
		  (ans == Error) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match!public! !

!Prolog methodsFor!
go: ask do: action
	 | m |
	 m := Fitter new.
	m setRule: ask setDatabase: database.
	^ m match
	! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | m |
	 m := Fitter new.
	m setRule: ask setDatabase: database.
	^ m match
	! !
!Prolog categoriesFor: #go:do:!public! !

p := Prolog new.
V reset.
p head: ((V @ 1),(C %3)) body: [].
p head: ((C % 1),(C %2)) body: [].!

x:= p go: ((V @ 0),(C %2))  do: []!

!Fitter methodsFor!
match
	| res fit i ans matchers tmp|
	res := database find: rule index: dbIndex.
	dbIndex := res cdr.
	fit := res car.
	i := 1.
	matchers := Array new.
	fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]. 
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == Error) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match!public! !

z := #(1,2,3)!

z do:[:e| w:=w+1]!

w!

z := Array new:3!

z at: 1 put: 1!

z at: 2 put: 11!

z at: 3 put: 1111!

w:=0!

z do:[:e| w:=w+1]!

w!

z do:[:e| w:=w+e]!

w!

p := Prolog new.
V reset.
p head: ((V @ 1),(C %3)) body: [].
p head: ((C % 1),(C %2)) body: [].!

x:= p go: ((V @ 0),(C %2))  do: []!

x!

z := Array new!

z do:[:e| w:=w+e]!

p := Prolog new.
V reset.
p head: ((V @ 1),(C %3)) body: [].
p head: ((C % 1),(C %2)) body: [].!

x:= p go: ((V @ 0),(C %2))  do: []!

p := Prolog new.
V reset.
e := Array new.
p head: ((V @ 1),(C %3)) body: e.
p head: ((C % 1),(C %2)) body: e.!

x:= p go: ((V @ 0),(C %2))  do: []!

x:= p go: ((V @ 0),(C %4))  do: []!

x:= p go: ((V @ 0),(C %4))  do: []!

p := Prolog new.
V reset.
e := Array new.
p head: ((V @ 1),(C %3)) body: e.
p head: ((C % 1),(C %2)) body: e.!

x:= p go: ((V @ 0),(C %4))  do: []!

!Fitter methodsFor!
match
	| res fit i ans matchers tmp|
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr.
	fit := res car.
	i := 1.
	matchers := Array new.
	fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]. 
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == Error) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match!public! !

x:= p go: ((V @ 0),(C %4))  do: []!

"23:56:39, 19 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\spac.img7'"!

"23:56:47, 19 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\spac2\spac.img7'"!

e resize:1!

e at:1 put:  ((C % 1),(C %3))!

e!

p head: ((V @ #x),(C %1)) body: e.!

x:= p go: ((V @ 0),(C %1))  do: []!

x:= p go: ((V @ 0),(C %1))  do: []!

x:= p go: ((V @ 0),(C %1))  do: []!

a:= Array new!

p := Prolog new.
V reset.!

p head: ((V @ 1),(C %3)) body: a.
p head: ((C % 1),(C %2)) body: a.
p head: ((V @ #x),(C %1)) body: e.!

x:= p go: ((V @ 0),(C %1))  do: []!

!Fitter methodsFor!
match
	| res fit i ans matchers tmp|
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr.
	fit := res car.
	i := 1.
	matchers := Array new.
	fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]. 
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match!public! !

x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.

!

t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p!

p!

p go: x do: [w add: x value].!

w!

w!

!Fitter methodsFor!
match
	| res fit i ans matchers tmp|
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := (res cdr) + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]. 
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp|
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr.
	fit := res car.
	i := 1.
	matchers := Array new.
	fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]. 
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match!public! !

w := OrderedCollection new.!

p go: x do: [w add: x value].!

!Prolog methodsFor!
go: ask do: action
	 | m |
	 m := Fitter new.
	m setRule: ask setDatabase: database.
	^ m match
	action value
	! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | m |
	 m := Fitter new.
	m setRule: ask setDatabase: database.
	^ m match.
	action value
	! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | m |
	 m := Fitter new.
	m setRule: ask setDatabase: database.
	^ m match.
	action value
	! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | m |
	 m := Fitter new.
	m setRule: ask setDatabase: database.
	m match.
	action value
	! !
!Prolog categoriesFor: #go:do:!public! !

p go: x do: [w add: x value].!

!Prolog methodsFor!
go: ask do: action
	 | m res|
	 m := Fitter new.
	m setRule: ask setDatabase: database.
	res := m match.
	(res == true) ifTrue: [action value]
	! !
!Prolog categoriesFor: #go:do:!public! !

p go: x do: [w add: x value].!

!Fitter methodsFor!
match
	| res fit i ans matchers tmp|
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match!public! !

p go: x do: [w add: x value].!

w := OrderedCollection new.!

p go: x do: [w add: x value].!

w!

!Prolog methodsFor!
go: ask do: action
	 | m res|
	 m := Fitter new.
	m setRule: ask setDatabase: database.
	res := m match.
	res := true.
	[res == true] whileTrue: [res := m match. (res == true) ifTrue: [action value].]
	! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | m res|
	 m := Fitter new.
	m setRule: ask setDatabase: database.
	res := m match.
	res := true.
	[res == true] whileTrue: [res := m match. (res == true) ifTrue: [action value].]
	! !
!Prolog categoriesFor: #go:do:!public! !

p go: x do: [w add: x value].!

!Fitter methodsFor!
match
	| res fit i ans matchers tmp|
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp|
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match!public! !

p go: x do: [w add: x value].!

x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
!

t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

w := OrderedCollection new.!

p go: x do: [w add: x value].!

w!

x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.!

t do: [:each | p fact: C % each].!

w := OrderedCollection new.!

p go: x do: [w add: x value].!

w!

p go: x do: [w add: x value].!

p go: x do: [w add: x value].!

w!

w!

x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.!

t do: [:each | p fact: C % each].!

w := OrderedCollection new.!

p go: x do: [w add: x value].!

!Prolog methodsFor!
go: ask do: action
	 | m res|
	 m := Fitter new.
	m setRule: ask setDatabase: database.
	res := true.
	[res == true] whileTrue: [res := m match. (res == true) ifTrue: [action value].]
	! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | m res|
	 m := Fitter new.
	m setRule: ask setDatabase: database.
	res := true.
	[res == true] whileTrue: [res := m match. (res == true) ifTrue: [action value].]
	! !
!Prolog categoriesFor: #go:do:!public! !

x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.!

t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

x := V @ #x. V reset.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.!

t do: [:each | p fact: C % each].!

w := OrderedCollection new.!

p go: x do: [w add: x value].!

x := V @ #x. V reset.
t := #(1 2 3) asOrderedCollection.!

p := Prolog new.!

t do: [:each | p fact: C % each].!

w := OrderedCollection new.!

p go: x do: [w add: x value].!

x := V @ #x. V reset.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].!

w := OrderedCollection new.!

p go: x do: [w add: x value].!

x := V @ #x. V reset.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

x := V @ #x. V reset.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

x := V @ #x. V reset.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

!Database methodsFor!
find: term index: index
	| len  work i t h p czy|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[
			  t := (rules at: i) trans.
			  h := t car head.
			  term go: h do: [work := false. p car: (t car body) cdr: i . ^p].
			  V delete: t cdr.
			  i := i + 1.
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	| len  work i t h p czy|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[
			  t := (rules at: i) trans.
			  h := t car head. 
			  czy := false.
			  term go: h do: [work := false. p car: (t car body) cdr: i . czy:=true].
			  (czy == true) ifTrue: [^p]. 
			  V delete: t cdr.
			  i := i + 1.
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	| len  work i t h p czy|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[
			  t := (rules at: i) trans.
			  h := t car head. 
			  czy := false.
			  term go: h do: [work := false. p car: (t car body) cdr: i . czy:=true].
			  (czy == true) ifTrue: [^p]. 
			  V delete: t cdr.
			  i := i + 1.
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

x := V @ #x. V reset.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

x := V @ #x. V reset.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

"11:08:09, 20 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\torek\spac.img7'"!

!Prolog methodsFor!
go: ask do: action
	 | m res recover|
	 m := Fitter new.
	m setRule: ask setDatabase: database.
	res := true.
	recover := ask getVarsList.
	recover do: [ :x | x  zeros].
	[res == true] whileTrue: [res := m match. (res == true) ifTrue: [action value].]
	! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | m res recover|
	 m := Fitter new.
	m setRule: ask setDatabase: database.
	res := true.
	recover := ask getVarsList.
	[res == true] whileTrue: [res := m match. (res == true) ifTrue: [action value]. recover do: [ :x | x  zeros].]
	! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | m res recover|
	 m := Fitter new.
	m setRule: ask setDatabase: database.
	res := true.
	recover := ask getVarsList.
	[res == true] whileTrue: [res := m match. (res == true) ifTrue: [action value]. recover do: [ :x | x  zeros].]
	! !
!Prolog categoriesFor: #go:do:!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

p go: x do: [w add: x value].!

!Database methodsFor!
find: term index: index
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[
			  t := (rules at: i) trans.
			  h := t car head. 
			  term go: h do: [work := false. p car: (t car body) cdr: i . ^p].
			  V delete: t cdr.
			  i := i + 1.
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[
			  t := (rules at: i) trans.
			  h := t car head. 
			  term go: h do: [work := false. p car: (t car body) cdr: i . ^p].
			  V delete: t cdr.
			  i := i + 1.
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].!

w!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].!

w := 0.!

p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].!

p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].!

Term subclass: #Conjunction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Conjunction guid: (GUID fromString: '{CBE73080-1688-4DF6-B1CE-A3A18A6CC2B4}')!
Conjunction comment: ''!
!Conjunction categoriesForClass!Kernel-Objects! !
!Conjunction methodsFor!
& t
	| tmp |
	tmp := Array new: 2.
	tmp at: 1 put: self.
	tmp at: 2 put: t.
	^ tmp! !
!Conjunction categoriesFor: #&!public! !

Conjunction removeFromSystem!

Object subclass: #Conjunction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Conjunction guid: (GUID fromString: '{8DA2ACFB-7179-49CF-8981-E69A5070108F}')!
Conjunction comment: ''!
!Conjunction categoriesForClass!Kernel-Objects! !
Object subclass: #Conjunction
	instanceVariableNames: 'terms'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!Conjunction class methodsFor!
new
	| tmp |
	tmp := super new.
	tmp init.
	^ tmp.! !
!Conjunction class categoriesFor: #new!public! !

!Conjunction methodsFor!
init
	terms := Array new.! !
!Conjunction categoriesFor: #init!public! !

!Conjunction methodsFor!
add: t
	| len |
	len := terms size.
	terms resize: (len + 1).
	terms at: (len +1) put: t! !
!Conjunction categoriesFor: #add:!public! !

!Conjunction methodsFor!
add: t
	| len |
	len := terms size.
	terms resize: (len + 1).
	terms at: (len +1) put: t! !
!Conjunction categoriesFor: #add:!public! !

!Term methodsFor!
& t
	| tmp |
	tmp := Conjunction new.
	tmp add: self.
	tmp add: t.
	^ tmp! !
!Term categoriesFor: #&!public! !

!Term methodsFor!
& t
	| tmp |
	tmp := Conjunction new.
	tmp add: self.
	tmp add: t.
	^ tmp! !
!Term categoriesFor: #&!public! !

!Conjunction methodsFor!
& t
	self add: t! !
!Conjunction categoriesFor: #&!public! !

!Conjunction methodsFor!
& t
	self add: t.
	^ self! !
!Conjunction categoriesFor: #&!public! !

!Conjunction methodsFor!
& t
	self add: t.
	^ self! !
!Conjunction categoriesFor: #&!public! !

!Prolog methodsFor!
go: ask do: action
	 | m res recover|
	m := Fitter new.
	m setRule: ask setDatabase: database.
	res := true.
	recover := ask getVarsList.
	[res == true] whileTrue: [res := m match. (res == true) ifTrue: [action value]. recover do: [ :x | x  zeros].]
	! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | m res recover matchers tmp|
	matchers := Array new.
	(ask isMemberOf: Term) ifTrue: [matchers resize: 1. 	m := Fitter new. m setRule: ask setDatabase: database. matchers at:1 put: m ]
	ifFalse: [
			matchers := Array new.
			(ask size > 0) ifTrue: [ask do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
		     ].
	res := true.
	recover := ask getVarsList.
	[res == true] whileTrue: [res := m match. (res == true) ifTrue: [action value]. recover do: [ :x | x  zeros].]
	! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | m res recover matchers tmp i|
	matchers := Array new.
	(ask isMemberOf: Term) ifTrue: [matchers resize: 1. 	m := Fitter new. m setRule: ask setDatabase: database. matchers at:1 put: m ]
	ifFalse: [
			matchers := Array new.
			(ask size > 0) ifTrue: [ask do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
		     ].
	res := true.
	recover := ask getVarsList.
	i := 1.
[
	[ (i >= 1) & (i <= (matchers size))] whileTrue: 
		[
		  | ans |
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
].
	(i > (matchers size)) ifTrue: [true] ifFalse: [false].
	[res == true] whileTrue: [res := m match. (res == true) ifTrue: [action value]. recover do: [ :x | x  zeros].]
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | m res recover matchers tmp i|
	matchers := Array new.
	(ask isMemberOf: Term) ifTrue: [matchers resize: 1. 	m := Fitter new. m setRule: ask setDatabase: database. matchers at:1 put: m ]
	ifFalse: [
			matchers := Array new.
			(ask size > 0) ifTrue: [ask do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
		     ].
	res := true.
	recover := ask getVarsList.
	i := 1.
[
	| what |
	[ (i >= 1) & (i <= (matchers size))] whileTrue: 
		[
		  | ans |
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
].
	(i > (matchers size)) ifTrue: [true] ifFalse: [false].
	[res == true] whileTrue: [res := m match. (res == true) ifTrue: [action value]. recover do: [ :x | x  zeros].]
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | m res recover matchers tmp i|
	matchers := Array new.
	(ask isMemberOf: Term) ifTrue: [matchers resize: 1. 	m := Fitter new. m setRule: ask setDatabase: database. matchers at:1 put: m ]
	ifFalse: [
			matchers := Array new.
			(ask size > 0) ifTrue: [ask do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
		     ].
	res := true.
	recover := ask getVarsList. " wez w petli "
	[res == true] 
	whileTrue:
	[
		res := [
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans |
					  ans := (matchers at: i) match.
					  (ans == false) ifTrue: [i :=i - 1]
					  ifFalse: [i:= i + 1]
					].
				(i > (matchers size)) ifTrue: [true] ifFalse: [false].
			]. 
			(res == true) ifTrue: [action value]. 
			recover do: [ :x | x  zeros].
	]
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | m res recover matchers tmp i tab|
	matchers := Array new.
	(ask isMemberOf: Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.
			matchers := Array new.
			(ask size > 0) ifTrue: [ask do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
			recover := Array new.
			ask do: [:elem | recover := recover , elem getVarsList ]
		     ].
	res := true.
	[res == true] 
	whileTrue:
	[
		res := [
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans |
					  ans := (matchers at: i) match.
					  (ans == false) ifTrue: [i :=i - 1]
					  ifFalse: [i:= i + 1]
					].
				(i > (matchers size)) ifTrue: [true] ifFalse: [false].
			]. 
			(res == true) ifTrue: [action value]. 
			recover do: [ :x | x  zeros].
	]
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | m res recover matchers tmp i tab|
	matchers := Array new.
	(ask isMemberOf: Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.
			matchers := Array new.
			(ask size > 0) ifTrue: [ask do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
			recover := Array new.
			ask do: [:elem | recover := recover , elem getVarsList ]
		     ].
	res := true.
	[res == true] 
	whileTrue:
	[
		res := [
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans |
					  ans := (matchers at: i) match.
					  (ans == false) ifTrue: [i :=i - 1]
					  ifFalse: [i:= i + 1]
					].
				(i > (matchers size)) ifTrue: [true] ifFalse: [false].
			]. 
			(res == true) ifTrue: [action value]. 
			recover do: [ :x | x  zeros].
	]
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Conjunction methodsFor!
terms
	^terms! !
!Conjunction categoriesFor: #terms!public! !

!Conjunction methodsFor!
terms
	^terms! !
!Conjunction categoriesFor: #terms!public! !

!Prolog methodsFor!
go: ask do: action
	 | m res recover matchers tmp i tab|
	matchers := Array new.
	(ask isMemberOf: Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , elem getVarsList ].
	res := true.
	[res == true] 
	whileTrue:
	[
		res := [
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans |
					  ans := (matchers at: i) match.
					  (ans == false) ifTrue: [i :=i - 1]
					  ifFalse: [i:= i + 1]
					].
				(i > (matchers size)) ifTrue: [true] ifFalse: [false].
			]. 
			(res == true) ifTrue: [action value]. 
			recover do: [ :x | x  zeros].
	]
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | m res recover matchers tmp i tab|
	matchers := Array new.
	(ask isMemberOf: Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	res := true.
	[res == true] 
	whileTrue:
	[
		res := [
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans |
					  ans := (matchers at: i) match.
					  (ans == false) ifTrue: [i :=i - 1]
					  ifFalse: [i:= i + 1]
					].
				(i > (matchers size)) ifTrue: [true] ifFalse: [false].
			]. 
			(res == true) ifTrue: [action value]. 
			recover do: [ :x | x  zeros].
	]
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | m res recover matchers tmp i tab|
	matchers := Array new.
	(ask isMemberOf: Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	res := true.
	[res == true] 
	whileTrue:
	[
		res := [
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans |
					  ans := (matchers at: i) match.
					  (ans == false) ifTrue: [i :=i - 1]
					  ifFalse: [i:= i + 1]
					].
				(i > (matchers size)) ifTrue: [true] ifFalse: [false].
			]. 
			(res == true) ifTrue: [action value]. 
			recover do: [ :x | x  zeros].
	]
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab|
	matchers := Array new.
	(ask isMemberOf: Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	res := true.
	[res == true] 
	whileTrue:
	[
		res := [
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans |
					  ans := (matchers at: i) match.
					  (ans == false) ifTrue: [i :=i - 1]
					  ifFalse: [i:= i + 1]
					].
				(i > (matchers size)) ifTrue: [true] ifFalse: [false].
			]. 
			(res == true) ifTrue: [action value]. 
			recover do: [ :x | x  zeros].
	]
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
head: h body: b
	| tmp arr|
	tmp := Pair new.
	(b isMemberOf: Term) ifTrue: [arr:= Array new:1. arr at:1 put: b].
	tmp car: h cdr: b.
	database addRule: tmp  ! !
!Prolog categoriesFor: #head:body:!public! !

!Prolog methodsFor!
head: h body: b
	| tmp arr|
	tmp := Pair new.
	(b isMemberOf: Term) ifTrue: [arr:= Array new:1. arr at:1 put: b]
	ifFalse: [arr:= b terms].
	tmp car: h cdr: b.
	database addRule: tmp  ! !
!Prolog categoriesFor: #head:body:!public! !

p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].!

x isMemberOf: Term!

x class!

x class instanceClass!

x class superclass!

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab|
	matchers := Array new.
	((ask class superclass) isMemberOf: Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	res := true.
	[res == true] 
	whileTrue:
	[
		res := [
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans |
					  ans := (matchers at: i) match.
					  (ans == false) ifTrue: [i :=i - 1]
					  ifFalse: [i:= i + 1]
					].
				(i > (matchers size)) ifTrue: [true] ifFalse: [false].
			]. 
			(res == true) ifTrue: [action value]. 
			recover do: [ :x | x  zeros].
	]
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
head: h body: b
	| tmp arr|
	tmp := Pair new.
	((b class superclass) isMemberOf: Term) ifTrue: [arr:= Array new:1. arr at:1 put: b]
	ifFalse: [arr:= b terms].
	tmp car: h cdr: b.
	database addRule: tmp  ! !
!Prolog categoriesFor: #head:body:!public! !

!Prolog methodsFor!
head: h body: b
	| tmp arr|
	tmp := Pair new.
	((b class superclass) isMemberOf: Term) ifTrue: [arr:= Array new:1. arr at:1 put: b]
	ifFalse: [arr:= b terms].
	tmp car: h cdr: b.
	database addRule: tmp  ! !
!Prolog categoriesFor: #head:body:!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.!

t do: [:each | p fact: C % each].!

w := OrderedCollection new.!

p go: x do: [w add: x value].!

!Prolog methodsFor!
head: h body: b
	| tmp arr|
	tmp := Pair new.
	((b class superclass) == Term) ifTrue: [arr:= Array new:1. arr at:1 put: b]
	ifFalse: [arr:= b terms].
	tmp car: h cdr: b.
	database addRule: tmp  ! !
!Prolog categoriesFor: #head:body:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	res := true.
	[res == true] 
	whileTrue:
	[
		res := [
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans |
					  ans := (matchers at: i) match.
					  (ans == false) ifTrue: [i :=i - 1]
					  ifFalse: [i:= i + 1]
					].
				(i > (matchers size)) ifTrue: [true] ifFalse: [false].
			]. 
			(res == true) ifTrue: [action value]. 
			recover do: [ :x | x  zeros].
	]
	




! !
!Prolog categoriesFor: #go:do:!public! !

p go: x do: [w add: x value].!

p go: x do: [w add: x value].!

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	res := true.
	[res == true] 
	whileTrue:
	[
		res := [
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans |
					  ans := (matchers at: i) match.
					  (ans == false) ifTrue: [i :=i - 1]
					  ifFalse: [i:= i + 1]
					].
				(i > (matchers size)) ifTrue: [true] ifFalse: [false].
			] value. 
			(res == true) ifTrue: [action value]. 
			recover do: [ :x | x  zeros].
	]
	




! !
!Prolog categoriesFor: #go:do:!public! !

p go: x do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].!

self assert: [w = t].!

w!

w := 0.0!

p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].!

w := 0!

p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].!

w!

w := 0!

p go: (C % 1) & (C % 2) & (C % 4) do: [w := w + 1].!

w!

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].!

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].!

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].!

!Term methodsFor!
& t
	| tmp |
	(t isMemberOf: Conjunction) ifTrue: [tmp:=Conjunction new. tmp add: self. tmp & t .^tmp].
	tmp := Conjunction new.
	tmp add: self.
	tmp add: t.
	^ tmp! !
!Term categoriesFor: #&!public! !

!Term methodsFor!
& t
	| tmp |
	(t isMemberOf: Conjunction) ifTrue: [tmp:=Conjunction new. tmp add: self. tmp := tmp & t .^tmp].
	tmp := Conjunction new.
	tmp add: self.
	tmp add: t.
	^ tmp! !
!Term categoriesFor: #&!public! !

"12:26:45, 20 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\wowow\spac.img7'"!

!Conjunction methodsFor!
& t
	(t isMemberOf: Conjunction) ifTrue: [terms := terms, t terms].
	self add: t.
	^ self! !
!Conjunction categoriesFor: #&!public! !

!Conjunction methodsFor!
& t
	(t isMemberOf: Conjunction) ifTrue: [terms := terms, t terms].
	self add: t.
	^ self! !
!Conjunction categoriesFor: #&!public! !

w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].
!

!Conjunction methodsFor!
& t
	(t isMemberOf: Conjunction) ifTrue: [terms := terms, t terms. ^self].
	self add: t.
	^ self! !
!Conjunction categoriesFor: #&!public! !

!Conjunction methodsFor!
& t
	(t isMemberOf: Conjunction) ifTrue: [terms := terms, t terms. ^self].
	self add: t.
	^ self! !
!Conjunction categoriesFor: #&!public! !

w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].
!

w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].
!

w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].
!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.!

p!

!Prolog methodsFor!
head: h body: b
	| tmp arr|
	tmp := Pair new.
	((b class superclass) == Term) ifTrue: [arr:= Array new:1. arr at:1 put: b]
	ifFalse: [arr:= b terms].
	tmp car: h cdr: b.
	database addRule: tmp  ! !
!Prolog categoriesFor: #head:body:!public! !

!Prolog methodsFor!
head: h body: b
	| tmp arr|
	tmp := Pair new.
	((b class superclass) == Term) ifTrue: [arr:= Array new:1. arr at:1 put: b]
	ifFalse: [arr:= b terms].
	tmp car: h cdr: b.
	database addRule: tmp  ! !
!Prolog categoriesFor: #head:body:!public! !

!Prolog methodsFor!
head: h body: b
	| tmp arr|
	tmp := Pair new.
	((b class superclass) == Term) ifTrue: [arr:= Array new:1. arr at:1 put: b]
	ifFalse: [arr:= b terms].
	tmp car: h cdr: arr.
	database addRule: tmp  ! !
!Prolog categoriesFor: #head:body:!public! !

!Prolog methodsFor!
head: h body: b
	| tmp arr|
	tmp := Pair new.
	((b class superclass) == Term) ifTrue: [arr:= Array new:1. arr at:1 put: b]
	ifFalse: [arr:= b terms].
	tmp car: h cdr: arr.
	database addRule: tmp  ! !
!Prolog categoriesFor: #head:body:!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].!

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.!

p!

w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

!Pair methodsFor!
getVarsList
	| tmp |
	tmp := Array new.
	tmp := self car getVarsList, self cdr getVarsList.
	^ tmp! !
!Pair categoriesFor: #getVarsList!public! !

!Pair methodsFor!
getVarsList
	| tmp |
	tmp := Array new.
	tmp := self car getVarsList, self cdr getVarsList.
	^ tmp! !
!Pair categoriesFor: #getVarsList!public! !

!Pair methodsFor!
getVarsList
	| tmp |
	tmp := Array new.
	tmp := self car getVarsList, self cdr getVarsList.
	^ tmp! !
!Pair categoriesFor: #getVarsList!public! !

!Pair methodsFor!
getVarsList
	| tmp |
	tmp := Array new.
	tmp := self car getVarsList, self cdr getVarsList.
	^ tmp! !
!Pair categoriesFor: #getVarsList!public! !

!Pair methodsFor!
getVarsList
	| tmp |
	tmp := Array new.
	tmp := self car getVarsList, self cdr getVarsList.
	^ tmp! !
!Pair categoriesFor: #getVarsList!public! !

!Pair methodsFor!
getVarsList
	| tmp |
	tmp := Array new.
	tmp := self car getVarsList, self cdr getVarsList.
	^ tmp! !
!Pair categoriesFor: #getVarsList!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].!

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead |
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=b at: j. ((dict includes: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b := b anonim: dict. i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: body.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead |
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includes: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b := b anonim: dict. i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: body.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].
!

w!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].!

w!

self assert: [w = 1].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].a 
self assert: [w = 1].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.!

w := 0
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].!

w := 0
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].!

w := 0
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].!

w := 0
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].!

w := 0
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

"13:06:38, 20 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\grejt\okd.img7'"!

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p!

try:=x, (L % 1 % 2 % 3) % #member!

try!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].


z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

x!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].


z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].


z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

!Pair methodsFor!
print
	^ #x! !
!Pair categoriesFor: #print!public! !

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].


z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].


z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].


z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].


z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].


z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

dict := Dictionary new!

dict at: 1 put: 0.
dict at: 7 put: 9!

dict includes:  0!

dict includes:  1!

dict key: 1!

dict find: 1!

dict includesKey: 1!

dict includesKey: 0!

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead |
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includes: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b := b anonim: dict. i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: body.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead |
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b := b anonim: dict. i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: body.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead |
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b := b anonim: dict. i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: body.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead |
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b := b anonim: dict. i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: body.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead |
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b := b anonim: dict. i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: body.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead |
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b := b anonim: dict. i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: body.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].


z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].


z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

!V methodsFor!
zeros
	value := nil.
	refers := Array new! !
!V categoriesFor: #zeros!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].


z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].


z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

!V methodsFor!
zeros
	value := nil.
	refers := Set new! !
!V categoriesFor: #zeros!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].


z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i).b := b anonim: dict. i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: body.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	newBody := Array new.
	[i <= len] whileTrue: [b := (body at:i).newBody := b anonim: dict. i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: body.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	newBody := Array new.
	[i <= len] whileTrue: [b := (body at:i).newBody := newBody, (b anonim: dict). i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: body.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	newBody := Array new.
	[i <= len] whileTrue: [b := (body at:i).newBody := newBody, (b anonim: dict). i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: newBody.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	newBody := Array new.
	len := body size.
	[i <= len] whileTrue: [b := (body at:i).newBody := newBody, (b anonim: dict). i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: newBody.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	newBody := Array new.
	len := body size.
	[i <= len] whileTrue: [b := (body at:i).newBody := newBody, (b anonim: dict). i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: newBody.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

"14:07:33, 20 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\dasd\sadads.img7'"!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].


z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	newBody := Array new.
	len := body size.
	[i <= len] whileTrue: [b := (body at:i). newBody resize: (newBody  size + 1).newBody at:  (newBody  size ) put:(b anonim: dict). i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: newBody.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].


z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	newBody := Array new.
	[i <= len] whileTrue: [b := (body at:i). newBody resize: (newBody  size + 1).newBody at:  (newBody  size ) put:(b anonim: dict). i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: newBody.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].!

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].!

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].
!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	newBody := body deepCopy.
	[i <= len] whileTrue: [b := (body at:i). newBody resize: (newBody  size + 1).newBody at:  (newBody  size ) put:(b anonim: dict). i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: newBody.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	newBody := body deepCopy.
	[i <= len] whileTrue: [b := (newBody at:i). newBody resize: (newBody  size + 1).newBody at:  (newBody  size ) put:(b anonim: dict). i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: newBody.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	newBody := body deepCopy.
	[i <= len] whileTrue: [b := (newBody at:i). b anonim: dict. i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: newBody.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
!

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0
!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i). b anonim: dict. i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: newBody.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].
!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i). b anonim: dict. i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: body.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i). b anonim: dict. i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: body.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].
!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	[i <= len] whileTrue: [b := (body at:i). b anonim: dict. i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: body.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].
!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].
!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0!

w := 0
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	( len > 0 ) ifFalse: [newBody:= body] ifTrue: [newBody := Array new.].
	[i <= len] whileTrue: [b := (body at:i). b anonim: dict. i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: newBody.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	( len > 0 ) ifFalse: [newBody:= body] ifTrue: [newBody := Array new.].
	[i <= len] whileTrue: [b := (body at:i). newBody resize: ((newBody  size )+ 1). newBody at: (newBody  size) put: (b anonim: dict). i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: newBody.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	( len > 0 ) ifFalse: [newBody:= body] ifTrue: [newBody := Array new.].
	[i <= len] whileTrue: [b := (body at:i). newBody resize: ((newBody  size )+ 1). newBody at: (newBody  size) put: (b anonim: dict). i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: newBody.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	( len > 0 ) ifFalse: [newBody:= body] ifTrue: [newBody := Array new.].
	[i <= len] whileTrue: [b := (body at:i). newBody resize: ((newBody  size )+ 1). newBody at: (newBody  size) put: (b anonim: dict). i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: newBody.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	( len > 0 ) ifFalse: [newBody:= body] ifTrue: [newBody := Array new.].
	[i <= len] whileTrue: [b := (body at:i). newBody resize: ((newBody  size )+ 1). newBody at: (newBody  size) put: (b anonim: dict). i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: newBody.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	( len > 0 ) ifFalse: [newBody:= body] ifTrue: [newBody := Array new.].
	[i <= len] whileTrue: [b := (body at:i). newBody resize: ((newBody  size )+ 1). newBody at: (newBody  size) put: (b anonim: dict). i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: newBody.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	( len > 0 ) ifFalse: [newBody:= body] ifTrue: [newBody := Array new.].
	[i <= len] whileTrue: [b := (body at:i). newBody resize: ((newBody  size )+ 1). newBody at: (newBody  size) put: (b anonim: dict). i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: newBody.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	( len > 0 ) ifFalse: [newBody:= body] ifTrue: [newBody := Array new.].
	[i <= len] whileTrue: [b := (body at:i). newBody resize: ((newBody  size )+ 1). newBody at: (newBody  size) put: (b anonim: dict). i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: newBody.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	( len > 0 ) ifFalse: [newBody:= body] ifTrue: [newBody := Array new.].
	[i <= len] whileTrue: [b := (body at:i). newBody resize: ((newBody  size )+ 1). newBody at: (newBody  size) put: (b anonim: dict). i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: newBody.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	( len > 0 ) ifFalse: [newBody:= body] ifTrue: [newBody := Array new.].
	[i <= len] whileTrue: [b := (body at:i). newBody resize: ((newBody  size )+ 1). newBody at: (newBody  size) put: (b anonim: dict). i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: newBody.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	( len > 0 ) ifFalse: [newBody:= body] ifTrue: [newBody := Array new.].
	[i <= len] whileTrue: [b := (body at:i). newBody resize: ((newBody  size )+ 1). newBody at: (newBody  size) put: (b anonim: dict). i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: newBody.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	( len > 0 ) ifFalse: [newBody:= body] ifTrue: [newBody := Array new.].
	[i <= len] whileTrue: [b := (body at:i). newBody resize: ((newBody  size )+ 1). newBody at: (newBody  size) put: (b anonim: dict). i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: newBody.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

!Rule methodsFor!
trans
	| dict h b i len tmp r created newHead newBody|
	dict := Dictionary new.
	h := head getVarsList.
	len := h size.
	i := 1.
	[i <= len] whileTrue: [b := (h at:i). ((dict includesKey: b) not) ifTrue: [dict at: b put: (V FreeVar)]. i:=i+1].
	len := body size.
	i := 1.
	[i <= len] whileTrue: [| j vs | b := (body at:i). vs:= b getVarsList. j:=1. [j<= (vs size)] whileTrue: [| t | t:=vs at: j. ((dict includesKey: t) not) ifTrue: [dict at: t put: (V FreeVar)]. j:=j+1]. i:=i+1].
	newHead := head anonim: dict.
	i := 1.
	( len > 0 ) ifFalse: [newBody:= body] ifTrue: [newBody := Array new.].
	[i <= len] whileTrue: [b := (body at:i). newBody resize: ((newBody  size )+ 1). newBody at: (newBody  size) put: (b anonim: dict). i := i + 1].
	tmp := Pair new.
	r := Rule new.
	r head: newHead body: newBody.
	created := dict values.
	tmp car: r cdr: created.
	^tmp


! !
!Rule categoriesFor: #trans!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0
!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].
!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].
!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].
!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].
!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.!

w := 0
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].
!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

"15:50:29, 20 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\g\sadads.img7'"!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0
!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].
!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].
!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].
!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

!Database methodsFor!
find: term index: index
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[
			  t := (rules at: i) trans.
			  h := t car head. 
			  term go: h do: [work := false. p car: (t car body) cdr: i . ^p].
			  "V delete: t cdr."
			  i := i + 1.
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[
			  t := (rules at: i) trans.
			  h := t car head. 
			  term go: h do: [work := false. p car: (t car body) cdr: i . ^p].
			  "V delete: t cdr."
			  i := i + 1.
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].
!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

!V methodsFor!
is: v
	| list |
	(v isMemberOf: V) ifTrue: [^refers add: v].
	((value == nil) not) ifTrue:[ ((value cmp: v) not) ifTrue: [^Error] ifFalse: [^self]].
	list := v getVarsList.
	((list indexOf: self) > 0) ifTrue: [^Error].
	value := v.
	refers do: [:el | el is: v].
	"refers := Set new."


! !
!V categoriesFor: #is:!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].
!

!V methodsFor!
is: v
	| list |
	(v isMemberOf: V) ifTrue: [^refers add: v].
	((value == nil) not) ifTrue:[ ((value cmp: v) not) ifTrue: [^Error] ifFalse: [^self]].
	list := v getVarsList.
	((list indexOf: self) > 0) ifTrue: [^Error].
	value := v.
	refers do: [:el | el is: v].
	"refers := Set new."


! !
!V categoriesFor: #is:!public! !

!V methodsFor!
zeros
	value := nil.
	refers do: [:el | el zeros].
	refers := Set new
	! !
!V categoriesFor: #zeros!public! !

!V methodsFor!
zeros
	value := nil.
	refers do: [:el | (el isUninitialized)  ifTrue: [el zeros]].
	refers := Set new
	! !
!V categoriesFor: #zeros!public! !

!V methodsFor!
zeros
	value := nil.
	refers do: [:el | (el isUninitialized)  ifTrue: [el zeros]].
	refers := Set new
	! !
!V categoriesFor: #zeros!public! !

!V methodsFor!
zeros
	value := nil.
	refers do: [:el | (el isUninitialized)  ifTrue: [el zeros]].
	refers := Set new
	! !
!V categoriesFor: #zeros!public! !

!V methodsFor!
zeros
	value := nil.
	refers do: [:el | (el isUninitialized)  ifTrue: [el zeros]].
	refers := Set new
	! !
!V categoriesFor: #zeros!public! !

!V methodsFor!
zeros
	value := nil.
	refers do: [:el | (el isUninitialized)  ifTrue: [el zeros]].
	refers := Set new
	! !
!V categoriesFor: #zeros!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

!V methodsFor!
zeros
	value := nil.
	refers do: [:el | (el isUninitialized not)  ifTrue: [el zeros]].
	refers := Set new
	! !
!V categoriesFor: #zeros!public! !

!V methodsFor!
zeros
	value := nil.
	refers do: [:el | (el isUninitialized not)  ifTrue: [el zeros]].
	refers := Set new
	! !
!V categoriesFor: #zeros!public! !

!V methodsFor!
zeros
	value := nil.
	refers do: [:el | (el isUninitialized not)  ifTrue: [el zeros]].
	refers := Set new
	! !
!V categoriesFor: #zeros!public! !

!V methodsFor!
zeros
	value := nil.
	refers do: [:el | (el isUninitialized not)  ifTrue: [el zeros]].
	refers := Set new
	! !
!V categoriesFor: #zeros!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

!V methodsFor!
zeros
	value := nil.
	refers do: [:el | (el isUninitialized not)  ifTrue: [el zeros]].
	"refers := Set new"
	! !
!V categoriesFor: #zeros!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.0
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].a Prolog w!

w!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].a Prolog w!

w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

w!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].


z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

p !

try!

"17:15:44, 20 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\fixed\sadads.img7'"!

!Fitter methodsFor!
match: last action: block
	| res fit i ans matchers tmp|
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match:action:!public! !

!Fitter methodsFor!
match: last action: block
	| res fit i ans matchers tmp|
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match:action:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp|
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.].
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp|
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.] ifFalse:  [ans := (matchers at: i) match.].
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp|
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.] ifFalse:  [ans := (matchers at: i) match.].
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	res := true.
	[res == true] 
	whileTrue:
	[
		res := [
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans |
					  (i ==  (matchers size)) ifTrue: [ ans := (matchers at: i) match: action.] ifFalse:  [ans := (matchers at: i) match.].
					  ans := (matchers at: i) match.
					  (ans == false) ifTrue: [i :=i - 1]
					  ifFalse: [i:= i + 1]
					].
				(i > (matchers size)) ifTrue: [true] ifFalse: [false].
			] value. 
			(res == true) ifTrue: [action value]. 
			recover do: [ :x | x  zeros].
	]
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	res := true.
	[res == true] 
	whileTrue:
	[
		res := [
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans |
					  (i ==  (matchers size)) ifTrue: [ ans := (matchers at: i) match: action.] ifFalse:  [ans := (matchers at: i) match.].
					  "ans := (matchers at: i) match."
					  (ans == false) ifTrue: [i :=i - 1]
					  ifFalse: [i:= i + 1]
					].
				(i > (matchers size)) ifTrue: [true] ifFalse: [false].
			] value. 
			(res == true) ifTrue: [action value]. 
			recover do: [ :x | x  zeros].
	]
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	"res := true."
	"[res == true] "
	"whileTrue:"
	"["
		"res := ["
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans |
					  (i ==  (matchers size)) ifTrue: [ ans := (matchers at: i) match: action.] ifFalse:  [ans := (matchers at: i) match.].
					  "ans := (matchers at: i) match."
					  (ans == false) ifTrue: [i :=i - 1]
					  ifFalse: [i:= i + 1]
					].
				"(i > (matchers size)) ifTrue: [true] ifFalse: [false]."
			"] value. "
			"(res == true) ifTrue: [action value]. "
			recover do: [ :x | x  zeros].
	"]"
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	"res := true."
	"[res == true] "
	"whileTrue:"
	"["
		"res := ["
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans |
					  (i ==  (matchers size)) ifTrue: [ ans := (matchers at: i) match: action.] ifFalse:  [ans := (matchers at: i) match.].
					  "ans := (matchers at: i) match."
					  (ans == false) ifTrue: [i :=i - 1]
					  ifFalse: [i:= i + 1]
					].
				"(i > (matchers size)) ifTrue: [true] ifFalse: [false]."
			"] value. "
			"(res == true) ifTrue: [action value]. "
			recover do: [ :x | x  zeros].
	"]"
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp|
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.] ifFalse:  [ans := (matchers at: i) match.].
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [block value. ^true] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp|
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.] ifFalse:  [ans := (matchers at: i) match.].
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(0==(fit size)) ifTrue: [block value. ^true] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp|
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.] ifFalse:  [ans := (matchers at: i) match.].
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(0==(fit size)) ifTrue: [block value. ^false] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp|
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.] ifFalse:  [ans := (matchers at: i) match.].
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(0==(fit size)) ifTrue: [block value. ^false] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.!

t do: [:each | p fact: C % each].!

w := OrderedCollection new.!

w := OrderedCollection new.!

p go: x do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	"res := true."
	"[res == true] "
	"whileTrue:"
	"["
		"res := ["
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans |
					  (i ==  (matchers size)) ifTrue: [ ans := (matchers at: i) match: action.] ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].
					  "ans := (matchers at: i) match."

					].
				"(i > (matchers size)) ifTrue: [true] ifFalse: [false]."
			"] value. "
			"(res == true) ifTrue: [action value]. "
			recover do: [ :x | x  zeros].
	"]"
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	"res := true."
	"[res == true] "
	"whileTrue:"
	"["
		"res := ["
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans |
					  (i ==  (matchers size)) 
					  ifTrue: [ ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					  ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].
					  "ans := (matchers at: i) match."

					].
				"(i > (matchers size)) ifTrue: [true] ifFalse: [false]."
			"] value. "
			"(res == true) ifTrue: [action value]. "
			recover do: [ :x | x  zeros].
	"]"
	




! !
!Prolog categoriesFor: #go:do:!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp|
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.] ifFalse:  [ans := (matchers at: i) match.].
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(0==(fit size)) ifTrue: [block value. ^true] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

w!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

w!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].a!

w!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje|
	moje := rule eval getVarsList.
	
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.] ifFalse:  [ans := (matchers at: i) match.].
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(0==(fit size)) ifTrue: [block value. ^true] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje|
	moje := rule eval getVarsList.
	moje do: [ :x | x  zeros].	
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.] ifFalse:  [ans := (matchers at: i) match.].
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(0==(fit size)) ifTrue: [block value. ^true] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje|
	moje := rule eval getVarsList.
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.] ifFalse:  [ans := (matchers at: i) match.].
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(0==(fit size)) ifTrue: [block value. 	moje do: [ :x | x  zeros].	^true] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

"18:07:24, 20 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\ly\sadads.img7'"!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

w!

self assert: [w = t].!

w := 0.!

p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].!

w!

self assert: [w = 1].!

w := 0.!

p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].!

self assert: [w = 1].!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].!

w!

self assert: [w = 1].!

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

w!

w!

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje|
	moje := rule eval getVarsList.
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(0==(fit size)) ifTrue: [block value. 	moje do: [ :x | x  zeros].	^true] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje|
	moje := rule eval getVarsList.
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [block value. 	moje do: [ :x | x  zeros].	^true] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

w!

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].a Prolog
self assert: [w = t].
!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].!

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
!

self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].
!

nil!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
a Prolog
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 00
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
!

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].

self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].
!

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].

self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].
!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

!Pair methodsFor!
printString
	^ #x! !
!Pair categoriesFor: #printString!public! !

!Pair methodsFor!
printString
	^ #x! !
!Pair categoriesFor: #printString!public! !

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

!Pair methodsFor!
printString
	^ car, cdr! !
!Pair categoriesFor: #printString!public! !

!Pair methodsFor!
printString
	^ car, cdr! !
!Pair categoriesFor: #printString!public! !

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

!Pair methodsFor!
displayString
	^ car, cdr! !
!Pair categoriesFor: #displayString!public! !

!Pair methodsFor!
displayString
	^ car, cdr! !
!Pair categoriesFor: #displayString!public! !

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

Pair removeSelector: #displayString ifAbsent: []!

Pair removeSelector: #printString ifAbsent: []!

p!

try!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].

self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].

self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
!

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].!

self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].
!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

rule eval !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [block value. 	moje do: [ :x | x  zeros].	^true] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [block value. 	moje do: [ :x | x  zeros].	^true] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [block value. 	moje do: [ :x | x  zeros].	^true] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].a Prolog

self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].

self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].
!

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].

self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

w!

self assert: [w = #(3 2 1) asOrderedCollection].!

w := OrderedCollection new.!

m := L % 1 % 2 % 3 % 4.!

n := L % 0 % 2 % 4 % 6.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

w!

a := V @ #a.
b := V @ #b.
c := V @ #c.!

p fact: L, x, x % #append.!

p head: (a, x), b, (c, x) % #append body: a, b, c % #append.!

w!

w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

"21:18:22, 20 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\troche\tttt.img7'"!

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

w!

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.!

w := OrderedCollection new.!

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

w!

w!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

w!

w := OrderedCollection new.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

w := OrderedCollection new.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: rule index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match!public! !

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

w!

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]
	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]
	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]
	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]
	! !
!Fitter categoriesFor: #match!public! !

w := OrderedCollection new.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

w!

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]
	! !
!Fitter categoriesFor: #match!public! !

w := OrderedCollection new.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [block value. 	moje do: [ :x | x  zeros].	^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [block value. 	moje do: [ :x | x  zeros].	^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [block value. 	moje do: [ :x | x  zeros].	^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [block value. 	moje do: [ :x | x  zeros].	^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [block value. 	moje do: [ :x | x  zeros].	^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]




	! !
!Fitter categoriesFor: #match:!public! !

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

w!

w := OrderedCollection new.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

w!

w := OrderedCollection new.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	moje do: [ :x | x  zeros].
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	moje do: [ :x | x  zeros].
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]



	! !
!Fitter categoriesFor: #match!public! !

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

w!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	(rule eval) do: [ :x | x  zeros].
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]



	! !
!Fitter categoriesFor: #match!public! !

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	(rule getVarsListl) do: [ :x | x  zeros].
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	(rule getVarsList) do: [ :x | x  zeros].
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]



	! !
!Fitter categoriesFor: #match!public! !

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

w!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	(rule getVarsList) do: [ :x | x  zeros].
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	(rule getVarsList) do: [ :x | x  zeros].
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [block value. 	moje do: [ :x | x  zeros].	^true] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

p go: (x, m % #member) do: [w add: x value].!

w!

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	"(rule getVarsList) do: [ :x | x  zeros]."
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [^false]



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	"(rule getVarsList) do: [ :x | x  zeros]."
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	"(rule getVarsList) do: [ :x | x  zeros]."
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	"(rule getVarsList) do: [ :x | x  zeros]."
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]



	! !
!Fitter categoriesFor: #match!public! !

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

w!

w := OrderedCollection new.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

w!

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	(dbIndex > 1) ifTrue: [(rule getVarsList) do: [ :x | x  zeros].].
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	(dbIndex > 1) ifTrue: [(rule getVarsList) do: [ :x | x  zeros].].
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	(dbIndex > 1) ifTrue: [(rule getVarsList) do: [ :x | x  zeros].].
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]



	! !
!Fitter categoriesFor: #match!public! !

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

w!

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	(dbIndex > 1) ifTrue: [(rule getVarsList) do: [ :x | x  zeros].].
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	(dbIndex > 1) ifTrue: [(rule getVarsList) do: [ :x | x  zeros].].
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	(dbIndex > 1) ifTrue: [(rule getVarsList) do: [ :x | x  zeros].].
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	(dbIndex > 1) ifTrue: [(rule getVarsList) do: [ :x | x  zeros].].
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	(dbIndex > 1) ifTrue: [(rule getVarsList) do: [ :x | x  zeros].].
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	(dbIndex > 1) ifTrue: [(rule getVarsList) do: [ :x | x  zeros].].
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]



	! !
!Fitter categoriesFor: #match!public! !

w := OrderedCollection new.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

w!

w := OrderedCollection new.!

p go: (x, m % #member)do: [w add: x value].!

w!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
!

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].!

self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].

self assert: [w = #(3 2 1) asOrderedCollection].!

"22:28:41, 20 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\prwie_ok\p.img7'"!

"22:28:50, 20 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\wrotekre\p.img7'"!

!Fitter methodsFor!
match:  block next: m
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [block value. 	moje do: [ :x | x  zeros].	^true] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:next:!public! !

!Fitter methodsFor!
match:  block next: fitter
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [block value. 	moje do: [ :x | x  zeros].	^true] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:next:!public! !

!Fitter methodsFor!
match:  block next: fitter
	| res fit i ans matchers tmp moje maj next|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [block value. 	moje do: [ :x | x  zeros].	^true] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:next:!public! !

!Fitter methodsFor!
match:  block next: fitter
	| res fit i ans matchers tmp moje maj next|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block  next:nil. (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [block value. 	moje do: [ :x | x  zeros].	^true] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:next:!public! !

!Fitter methodsFor!
match:  block next: fitter
	| res fit i ans matchers tmp moje maj next|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block  next:nil. (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [(next == nil) ifTrue: [block value. moje do: [ :x | x  zeros].]. fitter match: block next: nil.^true] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:next:!public! !

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule' next
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule next'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!Fitter methodsFor!
setRule: r setDatabase: db next: n
	rule := r.
	database := db.
	dbIndex :=1.
	next := n.
	! !
!Fitter categoriesFor: #setRule:setDatabase:next:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db next: n
	rule := r.
	database := db.
	dbIndex :=1.
	next := n.
	! !
!Fitter categoriesFor: #setRule:setDatabase:next:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db next: n
	rule := r.
	database := db.
	dbIndex :=1.
	next := n.
	! !
!Fitter categoriesFor: #setRule:setDatabase:next:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db next: n
	rule := r.
	database := db.
	dbIndex :=1.
	next := n.
	! !
!Fitter categoriesFor: #setRule:setDatabase:next:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db next: n
	rule := r.
	database := db.
	dbIndex :=1.
	next := n.
	! !
!Fitter categoriesFor: #setRule:setDatabase:next:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db next: n
	rule := r.
	database := db.
	dbIndex :=1.
	next := n.
	! !
!Fitter categoriesFor: #setRule:setDatabase:next:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db next: n
	rule := r.
	database := db.
	dbIndex :=1.
	next := n.
	! !
!Fitter categoriesFor: #setRule:setDatabase:next:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db next: n
	rule := r.
	database := db.
	dbIndex :=1.
	next := n.
	! !
!Fitter categoriesFor: #setRule:setDatabase:next:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db next: n
	rule := r.
	database := db.
	dbIndex :=1.
	next := n.
	! !
!Fitter categoriesFor: #setRule:setDatabase:next:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db next: n
	rule := r.
	database := db.
	dbIndex :=1.
	next := n.
	! !
!Fitter categoriesFor: #setRule:setDatabase:next:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db next: n
	rule := r.
	database := db.
	dbIndex :=1.
	next := n.
	! !
!Fitter categoriesFor: #setRule:setDatabase:next:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db next: n
	rule := r.
	database := db.
	dbIndex :=1.
	next := n.
	! !
!Fitter categoriesFor: #setRule:setDatabase:next:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db next: n
	rule := r.
	database := db.
	dbIndex :=1.
	next := n.
	! !
!Fitter categoriesFor: #setRule:setDatabase:next:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db next: n
	rule := r.
	database := db.
	dbIndex :=1.
	next := n.
	! !
!Fitter categoriesFor: #setRule:setDatabase:next:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db next: n
	rule := r.
	database := db.
	dbIndex :=1.
	next := n.
	! !
!Fitter categoriesFor: #setRule:setDatabase:next:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db next: n
	rule := r.
	database := db.
	dbIndex :=1.
	next := n.
	! !
!Fitter categoriesFor: #setRule:setDatabase:next:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db next: n
	rule := r.
	database := db.
	dbIndex :=1.
	next := n.
	! !
!Fitter categoriesFor: #setRule:setDatabase:next:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db next: n
	rule := r.
	database := db.
	dbIndex :=1.
	next := n.
	! !
!Fitter categoriesFor: #setRule:setDatabase:next:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db next: n
	rule := r.
	database := db.
	dbIndex :=1.
	next := n.
	! !
!Fitter categoriesFor: #setRule:setDatabase:next:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [(next == nil) ifTrue:[block value. moje do: [ :x | x  zeros]. ^true]. next match: block ] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [(next == nil) ifTrue:[block value. moje do: [ :x | x  zeros]. ^true]. next match: block ] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [(next == nil) ifTrue:[block value. moje do: [ :x | x  zeros]. ^true]. next match: block ] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [(next == nil) ifTrue:[block value. moje do: [ :x | x  zeros]. ^true]. next match: block ] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
xxx:  block
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [(next == nil) ifTrue:[block value. moje do: [ :x | x  zeros]. ^true]. next match: block ] ifFalse: [^false]




	! !
!Fitter categoriesFor: #xxx:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	(dbIndex == 1) ifTrue: [].
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [(next == nil) ifTrue:[block value. moje do: [ :x | x  zeros]. ^true]. next match: block ] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	(dbIndex == 1) ifTrue: [
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	].
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [(next == nil) ifTrue:[block value. moje do: [ :x | x  zeros]. ^true]. next match: block ] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	res := true.
	[res == true] whileTrue: [
		res := database find: maj index: dbIndex.
	].
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
	(dbIndex == 1) ifTrue: [
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	].
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [(next == nil) ifTrue:[block value. moje do: [ :x | x  zeros]. ^true]. next match: block ] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	res := true.
	[res == true] whileTrue: [
		res := database find: maj index: dbIndex.
		(res == Error) ifTrue: [^false].
	].
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
	(dbIndex == 1) ifTrue: [
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	].
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [(next == nil) ifTrue:[block value. moje do: [ :x | x  zeros]. ^true]. next match: block ] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	res := true.
	moje := rule eval getVarsList.
	maj := rule eval .
	[(res == Error) not] whileTrue: [
		res := database find: maj index: dbIndex.
		(res == Error) ifTrue: [^false].
	].
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
	(dbIndex == 1) ifTrue: [
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	].
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [(next == nil) ifTrue:[block value. moje do: [ :x | x  zeros]. ^true]. next match: block ] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	res := true.
	moje := rule eval getVarsList.
	maj := rule eval .
	[(res == Error) not] whileTrue: [
		res := database find: maj index: dbIndex.
		(res == Error) ifTrue: [^false].
		matchers := Array new.
	].
	i := 1.
	
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [(next == nil) ifTrue:[block value. moje do: [ :x | x  zeros]. ^true]. next match: block ] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	res := true.
	moje := rule eval getVarsList.
	maj := rule eval .
	[(res == Error) not] whileTrue: [
		res := database find: maj index: dbIndex.
		(res == Error) ifTrue: [^false].
		matchers := Array new.
		(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	].
	i := 1.
	
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [(next == nil) ifTrue:[block value. moje do: [ :x | x  zeros]. ^true]. next match: block ] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	res := true.
	moje := rule eval getVarsList.
	maj := rule eval .
	[(res == Error) not] whileTrue: [
		res := database find: maj index: dbIndex.
		(res == Error) ifTrue: [^false].
		matchers := Array new.
		(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	].
	i := 1.
	

	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [(next == nil) ifTrue:[block value. moje do: [ :x | x  zeros]. ^true]. next match: block ] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	res := true.
	moje := rule eval getVarsList.
	maj := rule eval .
	[(res == Error) not] whileTrue: [
		res := database find: maj index: dbIndex.
		(res == Error) ifTrue: [^false].
		dbIndex := res cdr + 1.
		fit := res car.
		matchers := Array new.
		(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	].
	i := 1.
	

	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [(next == nil) ifTrue:[block value. moje do: [ :x | x  zeros]. ^true]. next match: block ] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	res := true.
	moje := rule eval getVarsList.
	maj := rule eval .
	[(res == Error) not] whileTrue: [
		res := database find: maj index: dbIndex.
		(res == Error) ifTrue: [^false].
		dbIndex := res cdr + 1.
		fit := res car.
		matchers := Array new.
		(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
		i := 1.
	].
	
	

	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].
	(0==(fit size)) ifTrue: [(next == nil) ifTrue:[block value. moje do: [ :x | x  zeros]. ^true]. next match: block ] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	res := true.
	moje := rule eval getVarsList.
	maj := rule eval .
	[(res == Error) not] whileTrue: [
		res := database find: maj index: dbIndex.
		(res == Error) ifTrue: [^false].
		dbIndex := res cdr + 1.
		fit := res car.
		matchers := Array new.
		(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
		i := 1.
		[ (i >= 1) & (i <= (fit size))] whileTrue: 
			[
			  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
						ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
			].
		
	].
	
	
	(0==(fit size)) ifTrue: [(next == nil) ifTrue:[block value. moje do: [ :x | x  zeros]. ^true]. next match: block ] ifFalse: [^false]




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	res := true.
	moje := rule eval getVarsList.
	maj := rule eval .
	[(res == Error) not] whileTrue: [
		res := database find: maj index: dbIndex.
		(res == Error) ifTrue: [^false].
		dbIndex := res cdr + 1.
		fit := res car.
		matchers := Array new.
		(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
		i := 1.
		[ (i >= 1) & (i <= (fit size))] whileTrue: 
			[
			  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
						ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
			].
		(0==(fit size)) ifTrue: [(next == nil) ifTrue:[block value. moje do: [ :x | x  zeros]. ^true]. next match: block ] ifFalse: [^false]
	].
	
	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	res := true.
	moje := rule eval getVarsList.
	maj := rule eval .
	[(res == Error) not] whileTrue: [
		res := database find: maj index: dbIndex.
		(res == Error) ifTrue: [^false].
		dbIndex := res cdr + 1.
		fit := res car.
		matchers := Array new.
		(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
		i := 1.
		[ (i >= 1) & (i <= (fit size))] whileTrue: 
			[
			  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
						ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
			].
		(0==(fit size)) ifTrue: [block value. moje do: [ :x | x  zeros]. ^true.] ifFalse: [^false]
	].
	
	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	res := true.
	moje := rule eval getVarsList.
	maj := rule eval .
	[(res == Error) not] whileTrue: [
		res := database find: maj index: dbIndex.
		(res == Error) ifTrue: [^false].
		dbIndex := res cdr + 1.
		fit := res car.
		matchers := Array new.
		(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
		i := 1.
		[ (i >= 1) & (i <= (fit size))] whileTrue: 
			[
			  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
						ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
			].
		(0==(fit size)) ifTrue: [block value. moje do: [ :x | x  zeros]. ^true.].
	].
	^false
	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
loop! !
!Fitter categoriesFor: #loop!public! !

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule pos matchers'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule pos matchers'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule pos matchers'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule pos matchers'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!Fitter methodsFor!
setRule: r setDatabase: db next: n
	rule := r.
	database := db.
	dbIndex :=1.
	! !
!Fitter categoriesFor: #setRule:setDatabase:next:!public! !

Fitter removeSelector: #setRule:setDatabase:next: ifAbsent: []!

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r.
	database := db.
	dbIndex :=1.
	pos:=1.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r.
	database := db.
	dbIndex :=1.
	pos:=1.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

!Fitter methodsFor!
loop
	! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop: block
	| ans |
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].		 
		  "(ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]"
		].! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans |
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].		 
		].! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans |
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].! !
!Fitter categoriesFor: #loop:!public! !

Fitter removeSelector: #loop ifAbsent: []!

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	res := true.
	moje := rule eval getVarsList.
	maj := rule eval .
	(dbIndex > 1) ifTrue: [

	].
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
		dbIndex := res cdr + 1.
		fit := res car.
		matchers := Array new.
		(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
		i := 1.
		[ (i >= 1) & (i <= (fit size))] whileTrue: 
			[
			  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
						ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
			].
		(0==(fit size)) ifTrue: [block value. moje do: [ :x | x  zeros]. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

"23:33:14, 20 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\Nowy folder\p.img7'"!

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	res := true.
	moje := rule eval getVarsList.
	maj := rule eval .
	[(res == Error) not] whileTrue: [
		res := database find: maj index: dbIndex.
		(res == Error) ifTrue: [^false].
		dbIndex := res cdr + 1.
		fit := res car.
		matchers := Array new.
		(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
		i := 1.
		[ (i >= 1) & (i <= (fit size))] whileTrue: 
			[
			  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
						ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
			].
		(0==(fit size)) ifTrue: [block value. moje do: [ :x | x  zeros]. ^true.].
	]
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
loop: block
	| ans |
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans |
	(matchers == nil) ifTrue: [^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
match:  block
	|dbFound res fit i ans matchers tmp moje maj|
	dbFound := self dbFind.
	res := true.
	moje := rule eval getVarsList.
	maj := rule eval .
	[(res == Error) not] whileTrue: [
		res := database find: maj index: dbIndex.
		(res == Error) ifTrue: [^false].
		dbIndex := res cdr + 1.
		fit := res car.
		matchers := Array new.
		(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
		i := 1.
		[ (i >= 1) & (i <= (fit size))] whileTrue: 
			[
			  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
						ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
			].
		(0==(fit size)) ifTrue: [block value. moje do: [ :x | x  zeros]. ^true.].
	]
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
dbFind
! !
!Fitter categoriesFor: #dbFind!public! !

!Fitter methodsFor!
match:  block
	|dbFound res fit i ans matchers tmp moje maj|
	ans := self loop: block.
	(ans == false) ifTrue: [dbFound := self dbFind. (dbFound == Error) ifTrue: [^false].]
	ifFalse: [].

	res := true.
	moje := rule eval getVarsList.
	maj := rule eval .
	[(res == Error) not] whileTrue: [
		res := database find: maj index: dbIndex.
		(res == Error) ifTrue: [^false].
		dbIndex := res cdr + 1.
		fit := res car.
		matchers := Array new.
		(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
		i := 1.
		[ (i >= 1) & (i <= (fit size))] whileTrue: 
			[
			  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
						ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
			].
		(0==(fit size)) ifTrue: [block value. moje do: [ :x | x  zeros]. ^true.].
	]
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	|dbFound res fit i ans matchers tmp moje maj|
	ans := self loop: block.
	(ans == false) ifTrue: [dbFound := self dbFind. (dbFound == Error) ifTrue: [^false]. matchers := self createMatches: dbFound]
	ifFalse: [].

	res := true.
	moje := rule eval getVarsList.
	maj := rule eval .
	[(res == Error) not] whileTrue: [
		res := database find: maj index: dbIndex.
		(res == Error) ifTrue: [^false].
		dbIndex := res cdr + 1.
		fit := res car.
		matchers := Array new.
		(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
		i := 1.
		[ (i >= 1) & (i <= (fit size))] whileTrue: 
			[
			  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
						ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
			].
		(0==(fit size)) ifTrue: [block value. moje do: [ :x | x  zeros]. ^true.].
	]
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
createMatches! !
!Fitter categoriesFor: #createMatches!public! !

!Fitter methodsFor!
createMatches: fit! !
!Fitter categoriesFor: #createMatches:!public! !

!Fitter methodsFor!
match:  block
	|dbFound res fit i ans matchers tmp moje maj|
	ans := self loop: block.
	(ans == false) ifTrue: [dbFound := self dbFind. (dbFound == Error) ifTrue: [^false]. self createMatches: dbFound. self match: block]
	ifFalse: [^true].

	res := true.
	moje := rule eval getVarsList.
	maj := rule eval .
	[(res == Error) not] whileTrue: [
		res := database find: maj index: dbIndex.
		(res == Error) ifTrue: [^false].
		dbIndex := res cdr + 1.
		fit := res car.
		matchers := Array new.
		(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
		i := 1.
		[ (i >= 1) & (i <= (fit size))] whileTrue: 
			[
			  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
						ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
			].
		(0==(fit size)) ifTrue: [block value. moje do: [ :x | x  zeros]. ^true.].
	]
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
dbFind
	| moje maj res|
	moje := rule eval getVarsList.
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	^res car.! !
!Fitter categoriesFor: #dbFind!public! !

!Fitter methodsFor!
match:  block
	|dbFound res fit i ans matchers tmp moje maj|
	ans := self loop: block.
	(ans == false) ifTrue: [dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatches: dbFound. self match: block]
	ifFalse: [^true].

	res := true.
	moje := rule eval getVarsList.
	maj := rule eval .
	[(res == Error) not] whileTrue: [
		res := database find: maj index: dbIndex.
		(res == Error) ifTrue: [^false].
		dbIndex := res cdr + 1.
		fit := res car.
		matchers := Array new.
		(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
		i := 1.
		[ (i >= 1) & (i <= (fit size))] whileTrue: 
			[
			  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
						ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
			].
		(0==(fit size)) ifTrue: [block value. moje do: [ :x | x  zeros]. ^true.].
	]
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
createMatches: fit
	| tmp |
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].! !
!Fitter categoriesFor: #createMatches:!public! !

!Fitter methodsFor!
createMatches: fit
	| tmp |
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].! !
!Fitter categoriesFor: #createMatches:!public! !

!Fitter methodsFor!
match:  block
	|dbFound res fit i ans matchers tmp moje maj|
	ans := self loop: block.
	(ans == false) ifTrue: [dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatches: dbFound. self match: block]
	ifFalse: [^true].
		i := 1.
		[ (i >= 1) & (i <= (fit size))] whileTrue: 
			[
			  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
						ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
			].
		(0==(fit size)) ifTrue: [block value. moje do: [ :x | x  zeros]. ^true.].
	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	|dbFound res fit i ans matchers tmp moje maj|
	ans := self loop: block.
	(ans == false) ifTrue: [dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatches: dbFound. self match: block]
	ifFalse: [^true].
	(0==(fit size)) ifTrue: [block value. moje do: [ :x | x  zeros]. ^true.].
	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	|dbFound res fit i ans matchers tmp moje maj|
	ans := self loop: block.
	(ans == false) ifTrue: [dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatches: dbFound. self match: block]
	ifFalse: [block value. moje do: [ :x | x  zeros]. ^true.].
	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
dbFind
	| moje maj res|
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	^res car.! !
!Fitter categoriesFor: #dbFind!public! !

!Fitter methodsFor!
dbFind
	| maj res|
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	^res car.! !
!Fitter categoriesFor: #dbFind!public! !

!Fitter methodsFor!
match:  block
	|dbFound res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	ans := self loop: block.
	(ans == false) ifTrue: [dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatches: dbFound. self match: block]
	ifFalse: [block value. moje do: [ :x | x  zeros]. ^true.].
	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	|dbFound ans moje |
	moje := rule eval getVarsList.
	ans := self loop: block.
	(ans == false) ifTrue: [dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatches: dbFound. self match: block]
	ifFalse: [block value. moje do: [ :x | x  zeros]. ^true.].
	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	|dbFound ans moje |
	moje := rule eval getVarsList.
	ans := self loop: block.
	(ans == false) 	ifTrue: [dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatches: dbFound. self match: block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. ^true.].
	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
loop: block
	| ans |
	(matchers == nil) ifTrue: [^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
yyy
	| res fit i ans matchers tmp moje maj|
	moje := rule eval getVarsList.
	(dbIndex > 1) ifTrue: [(rule getVarsList) do: [ :x | x  zeros].].
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	fit := res car.
	i := 1.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	[ (i >= 1) & (i <= (fit size))] whileTrue: 
		[
		  ans := (matchers at: i) match.
		  (ans == false) ifTrue: [i :=i - 1]
		  ifFalse: [i:= i + 1]
		].
	(i > (fit size)) ifTrue: [^true] ifFalse: [moje do: [ :x | x  zeros]. ^false]



	! !
!Fitter categoriesFor: #yyy!public! !

!Fitter methodsFor!
match
	|dbFound ans moje |
	moje := rule eval getVarsList.
	ans := self loop.
	(ans == false) 	ifTrue: [dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatches: dbFound. self match]
				ifFalse: [^true.].! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
loop
	| ans |
	(matchers == nil) ifTrue: [^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans |
	(matchers == nil) ifTrue: [^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match.  
		  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:= pos + 1].
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
match
	|dbFound ans "moje" |
	"moje := rule eval getVarsList."
	ans := self loop.
	(ans == false) 	ifTrue: [dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatches: dbFound. self match]
				ifFalse: [^true.].! !
!Fitter categoriesFor: #match!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

!Fitter methodsFor!
match:  block
	|dbFound ans moje |
	moje := rule eval getVarsList.
	ans := self loop: block.
	(ans == false) 	ifTrue: [dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatches: dbFound. self match: block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. ^true.].
	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	|dbFound ans moje |
	moje := rule eval getVarsList.
	ans := self loop: block.
	(ans == false) 	ifTrue: [dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatches: dbFound. self match: block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. ^true.].
	
	




	! !
!Fitter categoriesFor: #match:!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

!Fitter methodsFor!
match:  block
	|dbFound ans moje |
	ans := self loop: block.
	(ans == false) 	ifTrue: [dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatches: dbFound. self match: block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. ^true.].
	
	




	! !
!Fitter categoriesFor: #match:!public! !

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule pos matchers moje'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule pos matchers moje'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule pos matchers moje'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule pos matchers moje'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule pos matchers moje'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r.
	database := db.
	dbIndex :=1.
	pos:=1.
	moje := rule eval getVarsList.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r.
	database := db.
	dbIndex :=1.
	pos:=1.
	moje := rule eval getVarsList.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r.
	database := db.
	dbIndex :=1.
	pos:=1.
	moje := rule eval getVarsList.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r.
	database := db.
	dbIndex :=1.
	pos:=1.
	moje := rule eval getVarsList.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r.
	database := db.
	dbIndex :=1.
	pos:=1.
	moje := rule eval getVarsList.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r.
	database := db.
	dbIndex :=1.
	pos:=1.
	moje := rule eval getVarsList.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r.
	database := db.
	dbIndex :=1.
	pos:=1.
	moje := rule eval getVarsList.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r.
	database := db.
	dbIndex :=1.
	pos:=1.
	moje := rule eval getVarsList.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r.
	database := db.
	dbIndex :=1.
	pos:=1.
	moje := rule eval getVarsList.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r.
	database := db.
	dbIndex :=1.
	pos:=1.
	moje := rule eval getVarsList.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

!Fitter methodsFor!
match:  block
	|dbFound ans|
	ans := self loop: block.
	(ans == false) 	ifTrue: [dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatches: dbFound. self match: block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. ^true.].
	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match
	|dbFound ans "moje" |
	"moje := rule eval getVarsList."
	ans := self loop.
	(ans == false) 	ifTrue: [dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatches: dbFound. self match]
				ifFalse: [^true.].! !
!Fitter categoriesFor: #match!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

w!

self assert: [w = t].!

w := 0.!

p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].!

"10:10:29, 21 czerwca 2017: Dolphin Smalltalk Professional started"!

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule pos matchers moje'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	res := true.
	moje := rule eval getVarsList.
	maj := rule eval .
	(dbIndex > 1) ifTrue: [

	].
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
		dbIndex := res cdr + 1.
		fit := res car.
		matchers := Array new.
		(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
		i := 1.
		[ (i >= 1) & (i <= (fit size))] whileTrue: 
			[
			  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
						ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
			].
		(0==(fit size)) ifTrue: [block value. moje do: [ :x | x  zeros]. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp moje maj|
	res := true.
	moje := rule eval getVarsList.
	maj := rule eval .
	(dbIndex > 1) ifTrue: [

	].
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
		dbIndex := res cdr + 1.
		fit := res car.
		matchers := Array new.
		(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
		i := 1.
		[ (i >= 1) & (i <= (fit size))] whileTrue: 
			[
			  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
						ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
			].
		(0==(fit size)) ifTrue: [block value. moje do: [ :x | x  zeros]. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r.
	database := db.
	dbIndex :=1.
	pos:=1.
	moje := nil.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r.
	database := db.
	dbIndex :=1.
	pos:=1.
	moje := rule eval getVarsList.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r.
	database := db.
	dbIndex :=1.
	pos:=1.
	moje := rule eval getVarsList.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans matchers tmp dbFound maj|
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatcher: dbFound. self match]
				ifFalse: [block value. moje do: [ :x | x  zeros]. ^true.].
	res := true.
	moje := rule eval getVarsList.
	maj := rule eval .
	(dbIndex > 1) ifTrue: [

	].
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
		dbIndex := res cdr + 1.
		fit := res car.
		matchers := Array new.
		(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
		i := 1.
		[ (i >= 1) & (i <= (fit size))] whileTrue: 
			[
			  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
						ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
			].
		(0==(fit size)) ifTrue: [block value. moje do: [ :x | x  zeros]. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
dbFind
	! !
!Fitter categoriesFor: #dbFind!public! !

!Fitter methodsFor!
dbFind
	| res maj|
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
		dbIndex := res cdr + 1.
		^res car.! !
!Fitter categoriesFor: #dbFind!public! !

!Fitter methodsFor!
dbFind
	| res maj|
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	^res car.! !
!Fitter categoriesFor: #dbFind!public! !

!Fitter methodsFor!
dbFind
	| res maj|
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	^res car.! !
!Fitter categoriesFor: #dbFind!public! !

!Fitter methodsFor!
dbFind
	| res maj|
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	^res car.! !
!Fitter categoriesFor: #dbFind!public! !

!Fitter methodsFor!
dbFind
	| res maj|
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	^res car.! !
!Fitter categoriesFor: #dbFind!public! !

!Fitter methodsFor!
dbFind
	| res maj|
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	^res car.! !
!Fitter categoriesFor: #dbFind!public! !

!Fitter methodsFor!
dbFind
	| res maj|
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	^res car.! !
!Fitter categoriesFor: #dbFind!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans dbFound maj tmp|
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatcher: dbFound. self match]
				ifFalse: [block value. moje do: [ :x | x  zeros]. ^true.].

		matchers := Array new.
		(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
		i := 1.
		[ (i >= 1) & (i <= (fit size))] whileTrue: 
			[
			  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
						ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
			].
		(0==(fit size)) ifTrue: [block value. moje do: [ :x | x  zeros]. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
createMatcher! !
!Fitter categoriesFor: #createMatcher!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans dbFound maj tmp|
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match]
				ifFalse: [block value. moje do: [ :x | x  zeros]. ^true.].

		matchers := Array new.
		(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
		i := 1.
		[ (i >= 1) & (i <= (fit size))] whileTrue: 
			[
			  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
						ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
			].
		(0==(fit size)) ifTrue: [block value. moje do: [ :x | x  zeros]. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
createMatchers! !
!Fitter categoriesFor: #createMatchers!public! !

!Fitter methodsFor!
createMatchers
	! !
!Fitter categoriesFor: #createMatchers!public! !

!Fitter methodsFor!
createMatchers: fit
	| tmp |
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].! !
!Fitter categoriesFor: #createMatchers:!public! !

!Fitter methodsFor!
createMatchers: fit
	| tmp |
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].! !
!Fitter categoriesFor: #createMatchers:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans dbFound maj tmp|
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match]
				ifFalse: [block value. moje do: [ :x | x  zeros]. ^true.].
		i := 1.
		[ (i >= 1) & (i <= (fit size))] whileTrue: 
			[
			  (i == (fit size)) ifTrue: [ ans := (matchers at: i) match: block.  (ans == false) ifTrue: [i :=i - 1]ifFalse: []] 
						ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].		 
			].
		(0==(fit size)) ifTrue: [block value. moje do: [ :x | x  zeros]. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
loop: block
	| ans |
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans |
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop
	| ans |
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans |
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans |
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans |
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans |
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans |
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans |
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans dbFound maj tmp|
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match]
				ifFalse: [block value. moje do: [ :x | x  zeros]. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans dbFound maj tmp|
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match]
				ifFalse: [block value. moje do: [ :x | x  zeros]. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| res fit i ans dbFound maj tmp|
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match]
				ifFalse: [block value. moje do: [ :x | x  zeros]. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound |
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match]
				ifFalse: [block value. moje do: [ :x | x  zeros]. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

"10:21:30, 21 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\tertretret\p.img7'"!

!Fitter methodsFor!
match:  block
	| ans dbFound |
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers = nil. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound |
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers = nil. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match
	| ans dbFound |
	ans := self loop.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match]
				ifFalse: [^true.].



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound |
	ans := self loop.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match]
				ifFalse: [^true.].



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound |
	ans := self loop.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match]
				ifFalse: [^true.].



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound |
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match:block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers = nil. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound |
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match:block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers = nil. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound |
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match:block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers = nil. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound |
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match:block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers = nil. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound |
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match:block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers = nil. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound |
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match:block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers = nil. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound |
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match:block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers = nil. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound |
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match:block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers = nil. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound |
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match:block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers = nil. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound |
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match:block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers = nil. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound |
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match:block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers = nil. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
loop
	| ans |
	( matchers == nil) ifTrue: [^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans |
	( matchers == nil) ifTrue: [^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop: block
	| ans |
	( matchers == nil) ifTrue: [^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans |
	( matchers == nil) ifTrue: [^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans |
	( matchers == nil) ifTrue: [^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans |
	( matchers == nil) ifTrue: [^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans |
	( matchers == nil) ifTrue: [^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans |
	( matchers == nil) ifTrue: [^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans |
	( matchers == nil) ifTrue: [^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans |
	( matchers == nil) ifTrue: [^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans |
	( matchers == nil) ifTrue: [^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop:!public! !

"10:23:00, 21 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\bfgbgf.img7'"!

"10:23:03, 21 czerwca 2017: Image saved"!

"10:23:10, 21 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\jkljklj\kl;.img7'"!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

!Fitter methodsFor!
match:  block
	| ans dbFound |
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match:block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

self assert: [w = t].!

w := 0.!

p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].

w := 0.!

p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].!

"10:29:06, 21 czerwca 2017: Dolphin Smalltalk Professional started"!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

!Fitter methodsFor!
match:  block
	| ans dbFound |
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match:block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound |
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match:block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].!

w := 0.!

p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].!

!Fitter methodsFor!
match
	| ans dbFound |
	ans := self loop.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match]
				ifFalse: [matchers:= nil. ^true.].



	! !
!Fitter categoriesFor: #match!public! !

w := 0!

p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
!

self assert: [w = 1].!

w := 0.!

"10:34:29, 21 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\ozehg\kl;.img7'"!

p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].!

self assert: [w = 1].!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.!

w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].!

self assert: [w = 1].!

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

self assert: [w = #(3 2 1) asOrderedCollection].!

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

self assert: [w = #(4 2) asOrderedCollection].!

w!


a := V @ #a.
b := V @ #b.
c := V @ #c.
!

p fact: L, x, x % #append.!

p head: (a, x), b, (c, x) % #append body: a, b, c % #append.!

a!

w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].

self assert: [w = 1].

w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].
!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].

self assert: [w = #(3 2 1) asOrderedCollection].!

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

!Fitter methodsFor!
match
	| ans dbFound |
	ans := self loop.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match]
				ifFalse: [matchers:= nil. ^true.].



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound |
	moje do: [ :x | x  zeros].
	ans := self loop.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match]
				ifFalse: [matchers:= nil. ^true.].



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound |
	moje do: [ :x | x  zeros].
	ans := self loop.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match]
				ifFalse: [matchers:= nil. ^true.].



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound |
	moje do: [ :x | x  zeros].
	ans := self loop.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match]
				ifFalse: [matchers:= nil. ^true.].



	! !
!Fitter categoriesFor: #match!public! !

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

w!

w := OrderedCollection new.!

m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

w!

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

!Fitter methodsFor!
match
	| ans dbFound |
	moje do: [ :x | x  zeros].
	ans := self loop.
	^[(ans == false) ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match]
				ifFalse: [matchers:= nil. ^true.].]



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound |
	moje do: [ :x | x  zeros].
	ans := self loop.
	^[(ans == false) ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match]
				ifFalse: [matchers:= nil. ^true.].]



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound |
	moje do: [ :x | x  zeros].
	ans := self loop.
	^[(ans == false) ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match]
				ifFalse: [matchers:= nil. ^true.].]



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound |
	ans := self loop: block.
	^[(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match:block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. ^true.].]

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound |
	ans := self loop: block.
	^[(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match:block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. ^true.].]

	
	




	! !
!Fitter categoriesFor: #match:!public! !

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

"10:59:25, 21 czerwca 2017: Dolphin Smalltalk Professional started"!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].!

self assert: [w = 1].

w := 0.0
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1]!


self assert: [w = 1].

w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1]
!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

self assert: [w = #(3 2 1) asOrderedCollection].!

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

x value!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
!

self assert: [w = 1].

w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1]!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

self assert: [w = #(3 2 1) asOrderedCollection].!

"ttttttttttt"
w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.a!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].

self assert: [w = 1].!


w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1]!


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

self assert: [w = #(3 2 1) asOrderedCollection].!

"ttttttttttt"
w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

!Fitter methodsFor!
loop
	| ans |
	( matchers == nil) ifTrue: [ moje do: [ :x | x  zeros]. ^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans |
	( matchers == nil) ifTrue: [ moje do: [ :x | x  zeros]. ^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans |
	( matchers == nil) ifTrue: [ moje do: [ :x | x  zeros]. ^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans |
	( matchers == nil) ifTrue: [ moje do: [ :x | x  zeros]. ^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans |
	( matchers == nil) ifTrue: [ moje do: [ :x | x  zeros]. ^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop!public! !

y := V @ #y.!

 V reset. x := V @ #x.!

y := V @ #y.!

z := V @ #z.!

w := OrderedCollection new.!

m := L % 1 % 2 % 3 % 4.!

n := L % 0 % 2 % 4 % 6.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

!Fitter methodsFor!
createMatchers: fit
	| tmp |
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].! !
!Fitter categoriesFor: #createMatchers:!public! !

!Fitter methodsFor!
createMatchers: fit
	| tmp |
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].! !
!Fitter categoriesFor: #createMatchers:!public! !

!Fitter methodsFor!
createMatchers: fit
	| tmp |
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].! !
!Fitter categoriesFor: #createMatchers:!public! !

!Fitter methodsFor!
createMatchers: fit
	| tmp |
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].! !
!Fitter categoriesFor: #createMatchers:!public! !

!Fitter methodsFor!
createMatchers: fit
	| tmp |
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].! !
!Fitter categoriesFor: #createMatchers:!public! !

!Fitter methodsFor!
createMatchers: fit
	| tmp |
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].! !
!Fitter categoriesFor: #createMatchers:!public! !

!Fitter methodsFor!
createMatchers: fit
	| tmp |
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].! !
!Fitter categoriesFor: #createMatchers:!public! !

"11:34:55, 21 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\Nowy folder (2)\kl;.img7'"!

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.!

 V reset. x := V @ #x.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

w!

 V reset. x := V @ #x.a V!

 V reset. x := V @ #x.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

!Fitter methodsFor!
match
	| ans dbFound |
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound. self match]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound |
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound |
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

"11:50:34, 21 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\ciekaw\h.img7'"!

 V reset. x := V @ #x.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

w!

 V reset. x := V @ #x.!

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.!

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. tmp:= rule eval getVarsList . self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

 V reset. x := V @ #x.!

w := OrderedCollection new.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. moje:= moje difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule pos matchers moje chg'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule pos matchers moje chg'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule pos matchers moje chg'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule pos matchers moje chg'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule pos matchers moje chg'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule pos matchers moje chg'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule pos matchers moje chg'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= moje difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= moje difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= moje difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= moje difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r.
	database := db.
	dbIndex :=1.
	pos:=1.
	moje := rule eval getVarsList.
	chg := moje.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r.
	database := db.
	dbIndex :=1.
	pos:=1.
	moje := rule eval getVarsList.
	chg := moje.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r.
	database := db.
	dbIndex :=1.
	pos:=1.
	moje := rule eval getVarsList.
	chg := moje.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r.
	database := db.
	dbIndex :=1.
	pos:=1.
	moje := rule eval getVarsList.
	chg := moje.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

!Fitter methodsFor!
loop
	| ans |
	( matchers == nil) ifTrue: [ chg do: [ :x | x  zeros]. ^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). chg:= tmp difference: chg. self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). chg:= tmp difference: chg. self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

 V reset. x := V @ #x.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

w!

 V reset. x := V @ #x.!

 V reset. x := V @ #x.!

w := OrderedCollection new.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

 V reset. x := V @ #x.!

w := OrderedCollection new.!

w := OrderedCollection new.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

!Fitter methodsFor!
loop
	| ans |
	( matchers == nil) ifTrue: [ chg do: [ :x | x  zeros]. chg := Array new. ^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans |
	( matchers == nil) ifTrue: [ chg do: [ :x | x  zeros]. chg := Array new. ^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans |
	( matchers == nil) ifTrue: [ chg do: [ :x | x  zeros]. chg := Array new. ^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans |
	( matchers == nil) ifTrue: [ chg do: [ :x | x  zeros]. chg := Array new. ^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans |
	( matchers == nil) ifTrue: [ chg do: [ :x | x  zeros]. chg := Array new. ^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans |
	( matchers == nil) ifTrue: [ chg do: [ :x | x  zeros]. chg := Array new. ^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop!public! !

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

 V reset. x := V @ #x.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

!Fitter methodsFor!
loop
	| ans czy|
	( matchers == nil) ifTrue: [ chg do: [ :x | x  zeros]. chg := Array new. ^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans czy|
	( matchers == nil) ifTrue: [ chg do: [ :x | x  zeros]. chg := Array new. ^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans czy|
	( matchers == nil) ifTrue: [ chg do: [ :x | x  zeros]. chg := Array new. czy := false].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans czy|
	( matchers == nil) ifTrue: [ chg do: [ :x | x  zeros]. chg := Array new. czy := false].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [[pos:= pos + 1]] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. ^true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. czy := true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. czy := true.].
	].




	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. czy := true.].
	].
	^czy.



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. czy := true.].
	].
	^czy.



	! !
!Fitter categoriesFor: #match!public! !

 V reset. x := V @ #x.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. czy := true. dbFound := false].
	].
	^czy.



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [matchers:= nil. czy := true. dbFound := false].
	].
	^czy.



	! !
!Fitter categoriesFor: #match!public! !

 V reset. x := V @ #x.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

!Fitter methodsFor!
loop
	| ans czy|
	( matchers == nil) ifTrue: [ chg do: [ :x | x  zeros]. chg := Array new. czy := false].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:= pos + 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans czy|
	( matchers == nil) ifTrue: [ chg do: [ :x | x  zeros]. chg := Array new. czy := false].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:= pos + 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true]. ^czy! !
!Fitter categoriesFor: #loop!public! !

 V reset. x := V @ #x.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

 V reset. x := V @ #x.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [czy := true. dbFound := false].
	].
	^czy.



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [czy := true. dbFound := false].
	].
	^czy.



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [czy := true. dbFound := false].
	].
	^czy.



	! !
!Fitter categoriesFor: #match!public! !

 V reset. x := V @ #x.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound]
					ifFalse: [(matchers size == 0) ifTrue: [matchers  := nil]. czy := true. dbFound := false].
	].
	^czy.



	! !
!Fitter categoriesFor: #match!public! !

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

 V reset. x := V @ #x.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

!Fitter methodsFor!
loop
	| ans czy|
	( matchers == nil) ifTrue: [ chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:= pos + 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans czy|
	( matchers == nil) ifTrue: [ chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1] ifFalse: [pos:=pos-1].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:= pos + 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans czy|
	( matchers == nil) ifTrue: [ chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1] ifFalse: [pos:=pos-1].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:= pos + 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans czy|
	( matchers == nil) ifTrue: [ chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1] ifFalse: [pos:=pos-1].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:= pos + 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true]. ^czy! !
!Fitter categoriesFor: #loop!public! !

 V reset. x := V @ #x.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

 V reset. x := V @ #x.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

 V reset. x := V @ #x.!

 V reset. x := V @ #x.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

!Fitter methodsFor!
loop
	| ans czy|
	( matchers == nil) ifTrue: [ chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1] ifFalse: [pos:=pos-1. (pos == 0) ifTrue: [pos:=1.]].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:= pos + 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans czy|
	( matchers == nil) ifTrue: [ chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1] ifFalse: [pos:=pos-1. (pos == 0) ifTrue: [pos:=1.]].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:= pos + 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans czy|
	( matchers == nil) ifTrue: [ chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1] ifFalse: [pos:=pos-1. (pos == 0) ifTrue: [pos:=1.]].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:= pos + 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true]. ^czy! !
!Fitter categoriesFor: #loop!public! !

 V reset. x := V @ #x.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

"12:57:10, 21 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\probaaa\proba.img7'"!

!Fitter methodsFor!
match:  block
	| ans dbFound |
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [pos:=1. ^false]. self createMatchers: dbFound. self match:block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

 V reset. x := V @ #x.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

!Fitter methodsFor!
loop
	| ans czy|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false.] ifFalse: [pos:=pos-1. (pos == 0) ifTrue: [pos:=1.]].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:= pos + 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop: block
	| ans |
	( matchers == nil) ifTrue: [^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [pos:=1.^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans |
	( matchers == nil) ifTrue: [^false].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [pos:=1. ^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans |
	( matchers == nil) ifTrue: [^false].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [pos:=1. ^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop
	| ans czy|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:= pos + 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans czy|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:= pos + 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans czy|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == false) ifTrue: [pos :=pos - 1] ifFalse: [pos:= pos + 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans czy|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == true) ifTrue: [pos :=pos + 1] ifFalse: [pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop: block
	| ans czy|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false.].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [pos:=1. ^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: []] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [pos:=1. ^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
					ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [pos:=1. ^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [pos:=1. ^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop
	| ans czy|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == true) ifTrue: [pos :=pos + 1] ifFalse: [pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans czy|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match. 
		 (ans == true) ifTrue: [pos :=pos + 1] ifFalse: [pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop: block
	| ans czy|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [^false] ifFalse: [^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [^false] ifFalse: [ pos:=(matchers size). ^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [^false] ifFalse: [ pos:=(matchers size). ^true]! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound. pos:=1.]
					ifFalse: [(matchers size == 0) ifTrue: [matchers  := nil]. czy := true. dbFound := false].
	].
	^czy.



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [tmp:= rule eval getVarsList. dbFound := self dbFind. (dbFound == false) ifTrue: [czy:=false. ^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound. pos:=1.]
					ifFalse: [(matchers size == 0) ifTrue: [matchers  := nil]. czy := true. dbFound := false].
	].
	^czy.



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [czy:=false. ^false]. chg:= tmp difference: (rule eval getVarsList ). self createMatchers: dbFound. pos:=1.
						   ]
					ifFalse: [(matchers size == 0) ifTrue: [matchers  := nil]. czy := true. dbFound := false].
	].
	^czy.



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound. pos:=1.
						   ]
					ifFalse: [(matchers size == 0) ifTrue: [matchers  := nil]. czy := true. dbFound := false].
	].
	^czy.



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	ans := self loop. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [(matchers size == 0) ifTrue: [matchers  := nil]. czy := true. dbFound := false].
	].
	^czy.



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [(matchers size == 0) ifTrue: [matchers  := nil]. czy := true. dbFound := false].
	].
	^czy.



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [(matchers size == 0) ifTrue: [matchers  := nil]. czy := true. dbFound := false].
	].
	^czy.



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop: block. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [(matchers size == 0) ifTrue: [matchers  := nil]. czy := true. dbFound := false].
	].
	^czy.
	ans := self loop: block.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [pos:=1. ^false]. self createMatchers: dbFound. self match:block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop: block. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [(matchers size == 0) ifTrue: [matchers  := nil]. czy := true. dbFound := false].
	].
	^czy.
	(ans == false) 	ifTrue: [ dbFound := self dbFind. (dbFound == false) ifTrue: [pos:=1. ^false]. self createMatchers: dbFound. self match:block]
				ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. ^true.].

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop: block. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. czy:=true. ^true.].
	].
	^czy.

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop: block. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. czy:=true. ^true.].
	].
	^czy.

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop: block. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. czy:=true. ^true.].
	].
	^czy.

	
	




	! !
!Fitter categoriesFor: #match:!public! !

"14:13:19, 21 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\zmiany\proba.img7'"!

 V reset. x := V @ #x.!

w := OrderedCollection new.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

!Fitter methodsFor!
match:  block
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop: block. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [pos:=1.czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. czy:=true. ^true.].
	].
	^czy.

	
	




	! !
!Fitter categoriesFor: #match:!public! !

 V reset. x := V @ #x.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [dbIndex :=1. czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [(matchers size == 0) ifTrue: [matchers  := nil]. czy := true. dbFound := false].
	].
	^czy.



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop: block. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [dbIndex :=1. czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. czy:=true. ^true.].
	].
	^czy.

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop: block. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [dbIndex :=1. czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. czy:=true. ^true.].
	].
	^czy.

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [dbIndex :=1. pos:=1.czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [(matchers size == 0) ifTrue: [matchers  := nil]. czy := true. dbFound := false].
	].
	^czy.



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop: block. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [dbIndex :=1. pos:=1.czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. czy:=true. ^true.].
	].
	^czy.

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop: block. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [dbIndex :=1. pos:=1. czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. czy:=true. ^true.].
	].
	^czy.

	
	




	! !
!Fitter categoriesFor: #match:!public! !

"14:28:03, 21 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\hj\proba.img7'"!

 V reset. x := V @ #x.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

 V reset. x := V @ #x.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

 V reset. x := V @ #x.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value].!

w!

w := OrderedCollection new.!

 V reset. x := V @ #x.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value]!

w!

w := OrderedCollection new.!

p go: (x, m % #member) do: [w add: x value]!

w!

 V reset. x := V @ #x.!

w := OrderedCollection new.!

m := L % 1 % 2 % 3 % 4.!

n := L % 0 % 2 % 4 % 6.!

p go: (1, m % #member) &  (1, n % #member) do: [w add: x value]!

 V reset. x := V @ #x.!

w := OrderedCollection new.!

p go: ((C % 1), m % #member) & ((C % 1), n % #member) do: [w add: x value]!

w!

 V reset. x := V @ #x.!

p go: ((C % 2), m % #member) & ((C % 2), n % #member) do: [w add: x value]!

p go: ((C % 2), m % #member) & ((C % 2), n % #member) do: [w add: x value]!

w := OrderedCollection new.!

p go: ((C % 2), m % #member) & ((C % 2), n % #member) do: [w add: 2]!

w!

p go: ((C % 3), m % #member) & ((C % 3), n % #member) do: [w add: 3]!

w!

p go: ((C % 4), m % #member) & ((C % 4), n % #member) do: [w add: 4]!

w!

!Fitter methodsFor!
loop
	| ans czy tmp|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  "ans := (matchers at: pos) match."
		  
		 (ans == true) ifTrue: [pos :=pos + 1] ifFalse: [pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans czy tmp|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  "ans := (matchers at: pos) match."
		  tmp := Matcher new.
		  tmp setRule: (((matchers at: pos) rule) eval) setDatabase: database.
		 (ans == true) ifTrue: [pos :=pos + 1] ifFalse: [pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
rule
	^rule! !
!Fitter categoriesFor: #rule!public! !

!Fitter methodsFor!
loop
	| ans czy tmp|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  "ans := (matchers at: pos) match."
		  tmp := Matcher new.
		  tmp setRule: (((matchers at: pos) rule) eval) setDatabase: database.
		  ans := tmp match.
		 (ans == true) ifTrue: [pos :=pos + 1] ifFalse: [pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans czy tmp|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  "ans := (matchers at: pos) match."
		  tmp := Matcher new.
		  tmp setRule: (((matchers at: pos) rule) eval) setDatabase: database.
		  ans := tmp match.
		 (ans == true) ifTrue: [pos :=pos + 1] ifFalse: [pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans czy tmp|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  "ans := (matchers at: pos) match."
		  tmp := Matcher new.
		  tmp setRule: (((matchers at: pos) rule) eval) setDatabase: database.
		  ans := tmp match.
		 (ans == true) ifTrue: [pos :=pos + 1] ifFalse: [pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans czy tmp|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  "ans := (matchers at: pos) match."
		  tmp := Matcher new.
		  tmp setRule: (((matchers at: pos) rule) eval) setDatabase: database.
		  ans := tmp match.
		 (ans == true) ifTrue: [pos :=pos + 1] ifFalse: [pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  tmp :=  (matchers at: pos) rule.
		  e:= Matcher new.
		  e setRule: (tmp eval) setDatabase: database.
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos) match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := (matchers at: pos) match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  tmp :=  (matchers at: pos) rule.
		  e:= Matcher new.
		  e setRule: (tmp eval) setDatabase: database.
		  (pos == (matchers size)) 	ifTrue: [ ans := e match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := e match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  tmp :=  (matchers at: pos) rule.
		  e:= Matcher new.
		  e setRule: (tmp eval) setDatabase: database.
		  (pos == (matchers size)) 	ifTrue: [ ans := e match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := e match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  tmp :=  (matchers at: pos) rule.
		  e:= Matcher new.
		  e setRule: (tmp eval) setDatabase: database.
		  (pos == (matchers size)) 	ifTrue: [ ans := e match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := e match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule pos matchers moje chg last'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule pos matchers moje chg last'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r.
	database := db.
	dbIndex :=1.
	pos:=1.
	moje := rule eval getVarsList.
	chg := moje.
	last :=0.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop: block. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [dbIndex :=1. pos:=1. czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1. last:=0.
						   ]
					ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. czy:=true. ^true.].
	].
	^czy.

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop: block. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [dbIndex :=1. pos:=1. last:=0. czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1. last:=0.
						   ]
					ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. czy:=true. ^true.].
	].
	^czy.

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [dbIndex :=1. pos:=1. last:=0.czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [(matchers size == 0) ifTrue: [matchers  := nil]. czy := true. dbFound := false].
	].
	^czy.



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [dbIndex :=1. pos:=1. last:=0.czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.  last:=0.
						   ]
					ifFalse: [(matchers size == 0) ifTrue: [matchers  := nil]. czy := true. dbFound := false].
	].
	^czy.



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
loop
	| ans czy tmp|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  "ans := (matchers at: pos) match."
		  (pos > last) 	ifTrue: [  tmp := Matcher new.
						  tmp setRule: (((matchers at: pos) rule) eval) setDatabase: database.]
					ifFalse: [tmp := (matchers at: pos)].
		 ans := tmp match.
		 (ans == true) ifTrue: [pos :=pos + 1] ifFalse: [pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans czy tmp|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  "ans := (matchers at: pos) match."
		  (pos > last) 	ifTrue: [  tmp := Matcher new.
						  tmp setRule: (((matchers at: pos) rule) eval) setDatabase: database.]
					ifFalse: [tmp := (matchers at: pos)].
		 ans := tmp match.
		 (ans == true) ifTrue: [last:= pos. pos :=pos + 1 ] ifFalse: [pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		 (pos > last) ifTrue: [ tmp :=  (matchers at: pos) rule.
						e:= Matcher new.
						e setRule: (tmp eval) setDatabase: database. ].
		  (pos == (matchers size)) 	ifTrue: [ ans := e match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := e match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		 (pos > last) ifTrue: [ tmp :=  (matchers at: pos) rule.
						e:= Matcher new.
						e setRule: (tmp eval) setDatabase: database. ]
					ifFalse: [e :=4 ].
		  (pos == (matchers size)) 	ifTrue: [ ans := e match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := e match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		 (pos > last) ifTrue: [ tmp :=  (matchers at: pos) rule.
						e:= Matcher new.
						e setRule: (tmp eval) setDatabase: database. ]
					ifFalse: [e := (matchers at: pos) ].
		  (pos == (matchers size)) 	ifTrue: [ ans := e match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := e match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		 (pos > last) ifTrue: [ tmp :=  (matchers at: pos) rule.
						e:= Matcher new.
						e setRule: (tmp eval) setDatabase: database. ]
					ifFalse: [e := (matchers at: pos) ].
		  (pos == (matchers size)) 	ifTrue: [ ans := e match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := e match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [last:=pos. pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

"15:01:42, 21 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\aaaa\proba.img7'"!

 V reset. x := V @ #x.!

w := OrderedCollection new.!

p go: (x, m % #member) & (x, n % #member) do: [w add: 4]!

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	"res := true."
	"[res == true] "
	"whileTrue:"
	"["
		"res := ["
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans |
					  (i ==  (matchers size)) 
					  ifTrue: [ ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					  ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].
					  "ans := (matchers at: i) match."

					].
				"(i > (matchers size)) ifTrue: [true] ifFalse: [false]."
			"] value. "
			"(res == true) ifTrue: [action value]. "
			recover do: [ :x | x  zeros].
	"]"
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	"res := true."
	"[res == true] "
	"whileTrue:"
	"["
		"res := ["
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans |
					  (i ==  (matchers size)) 
					  ifTrue: [ ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					  ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [last:=i. i:= i + 1] ].
					  "ans := (matchers at: i) match."

					].
				"(i > (matchers size)) ifTrue: [true] ifFalse: [false]."
			"] value. "
			"(res == true) ifTrue: [action value]. "
			recover do: [ :x | x  zeros].
	"]"
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	"res := true."
	"[res == true] "
	"whileTrue:"
	"["
		"res := ["
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans |
					  (i ==  (matchers size)) 
					  ifTrue: [ ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					  ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [last:=i. i:= i + 1] ].
					  "ans := (matchers at: i) match."

					].
				"(i > (matchers size)) ifTrue: [true] ifFalse: [false]."
			"] value. "
			"(res == true) ifTrue: [action value]. "
			recover do: [ :x | x  zeros].
	"]"
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	"res := true."
	"[res == true] "
	"whileTrue:"
	"["
		"res := ["
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans to|
					   (i > last) ifTrue: [to := Matcher  new. to setRule: (((matchers at: i)  rule) eval) setDatabase: database ] ifFalse: [to := (matchers at: i) ].
					  (i ==  (matchers size)) 
					  ifTrue: [ ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					  ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [last:=i. i:= i + 1] ].
					  "ans := (matchers at: i) match."

					].
				"(i > (matchers size)) ifTrue: [true] ifFalse: [false]."
			"] value. "
			"(res == true) ifTrue: [action value]. "
			recover do: [ :x | x  zeros].
	"]"
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	"res := true."
	"[res == true] "
	"whileTrue:"
	"["
		"res := ["
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans to|
					   (i > last) ifTrue: [to := Matcher  new. to setRule: (((matchers at: i)  rule) eval) setDatabase: database ] ifFalse: [to := (matchers at: i) ].
					  (i ==  (matchers size)) 
					  ifTrue: [ ans := to match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					  ifFalse:  [ans := to match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [last:=i. i:= i + 1] ].
					  "ans := (matchers at: i) match."

					].
				"(i > (matchers size)) ifTrue: [true] ifFalse: [false]."
			"] value. "
			"(res == true) ifTrue: [action value]. "
			recover do: [ :x | x  zeros].
	"]"
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	"res := true."
	"[res == true] "
	"whileTrue:"
	"["
		"res := ["
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans to|
					   (i > last) ifTrue: [to := Matcher  new. to setRule: (((matchers at: i)  rule) eval) setDatabase: database ] ifFalse: [to := (matchers at: i) ].
					  (i ==  (matchers size)) 
					  ifTrue: [ ans := to match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					  ifFalse:  [ans := to match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [last:=i. i:= i + 1] ].
					  "ans := (matchers at: i) match."

					].
				"(i > (matchers size)) ifTrue: [true] ifFalse: [false]."
			"] value. "
			"(res == true) ifTrue: [action value]. "
			recover do: [ :x | x  zeros].
	"]"
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	"res := true."
	"[res == true] "
	"whileTrue:"
	"["
		"res := ["
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans to|
					   (i > last) ifTrue: [to := Matcher  new. to setRule: (((matchers at: i)  rule) eval) setDatabase: database ] ifFalse: [to := (matchers at: i) ].
					  (i ==  (matchers size)) 
					  ifTrue: [ ans := to match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					  ifFalse:  [ans := to match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [last:=i. i:= i + 1] ].
					  "ans := (matchers at: i) match."

					].
				"(i > (matchers size)) ifTrue: [true] ifFalse: [false]."
			"] value. "
			"(res == true) ifTrue: [action value]. "
			recover do: [ :x | x  zeros].
	"]"
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	"res := true."
	"[res == true] "
	"whileTrue:"
	"["
		"res := ["
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans to|
					   (i > last) ifTrue: [to := Matcher  new. to setRule: (((matchers at: i)  rule) eval) setDatabase: database ] ifFalse: [to := (matchers at: i) ].
					  (i ==  (matchers size)) 
					  ifTrue: [ ans := to match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					  ifFalse:  [ans := to match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [last:=i. i:= i + 1] ].
					  "ans := (matchers at: i) match."

					].
				"(i > (matchers size)) ifTrue: [true] ifFalse: [false]."
			"] value. "
			"(res == true) ifTrue: [action value]. "
			recover do: [ :x | x  zeros].
	"]"
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	"res := true."
	"[res == true] "
	"whileTrue:"
	"["
		"res := ["
				i := 1. last:=0.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans to|
					   (i > last) ifTrue: [to := Matcher  new. to setRule: (((matchers at: i)  rule) eval) setDatabase: database ] ifFalse: [to := (matchers at: i) ].
					  (i ==  (matchers size)) 
					  ifTrue: [ ans := to match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					  ifFalse:  [ans := to match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [last:=i. i:= i + 1] ].
					  "ans := (matchers at: i) match."

					].
				"(i > (matchers size)) ifTrue: [true] ifFalse: [false]."
			"] value. "
			"(res == true) ifTrue: [action value]. "
			recover do: [ :x | x  zeros].
	"]"
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	"res := true."
	"[res == true] "
	"whileTrue:"
	"["
		"res := ["
				i := 1. last:=0.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans to|
					   (i > last) ifTrue: [to := Matcher  new. to setRule: (((matchers at: i)  rule) eval) setDatabase: database ] ifFalse: [to := (matchers at: i) ].
					  (i ==  (matchers size)) 
					  ifTrue: [ ans := to match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					  ifFalse:  [ans := to match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [last:=i. i:= i + 1] ].
					  "ans := (matchers at: i) match."

					].
				"(i > (matchers size)) ifTrue: [true] ifFalse: [false]."
			"] value. "
			"(res == true) ifTrue: [action value]. "
			recover do: [ :x | x  zeros].
	"]"
	




! !
!Prolog categoriesFor: #go:do:!public! !

 V reset. x := V @ #x.!

p go: (x, m % #member) & (x, n % #member) do: [w add: 4]!

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	"res := true."
	"[res == true] "
	"whileTrue:"
	"["
		"res := ["
				i := 1. last:=0.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans to|
					   (i > last) ifTrue: [to :=Fitter new. to setRule: (((matchers at: i)  rule) eval) setDatabase: database ] ifFalse: [to := (matchers at: i) ].
					  (i ==  (matchers size)) 
					  ifTrue: [ ans := to match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					  ifFalse:  [ans := to match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [last:=i. i:= i + 1] ].
					  "ans := (matchers at: i) match."

					].
				"(i > (matchers size)) ifTrue: [true] ifFalse: [false]."
			"] value. "
			"(res == true) ifTrue: [action value]. "
			recover do: [ :x | x  zeros].
	"]"
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	"res := true."
	"[res == true] "
	"whileTrue:"
	"["
		"res := ["
				i := 1. last:=0.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans to|
					   (i > last) ifTrue: [to :=Fitter new. to setRule: (((matchers at: i)  rule) eval) setDatabase: database ] ifFalse: [to := (matchers at: i) ].
					  (i ==  (matchers size)) 
					  ifTrue: [ ans := to match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					  ifFalse:  [ans := to match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [last:=i. i:= i + 1] ].
					  "ans := (matchers at: i) match."

					].
				"(i > (matchers size)) ifTrue: [true] ifFalse: [false]."
			"] value. "
			"(res == true) ifTrue: [action value]. "
			recover do: [ :x | x  zeros].
	"]"
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		 (pos > last) ifTrue: [ tmp :=  (matchers at: pos) rule.
						e:= Fitter new.
						e setRule: (tmp eval) setDatabase: database. ]
					ifFalse: [e := (matchers at: pos) ].
		  (pos == (matchers size)) 	ifTrue: [ ans := e match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := e match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [last:=pos. pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		 (pos > last) ifTrue: [ tmp :=  (matchers at: pos) rule.
						e:= Fitter new.
						e setRule: (tmp eval) setDatabase: database. ]
					ifFalse: [e := (matchers at: pos) ].
		  (pos == (matchers size)) 	ifTrue: [ ans := e match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := e match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [last:=pos. pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop
	| ans czy tmp|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  "ans := (matchers at: pos) match."
		  (pos > last) 	ifTrue: [  tmp :=Fitter new.
						  tmp setRule: (((matchers at: pos) rule) eval) setDatabase: database.]
					ifFalse: [tmp := (matchers at: pos)].
		 ans := tmp match.
		 (ans == true) ifTrue: [last:= pos. pos :=pos + 1 ] ifFalse: [pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

p go: (x, m % #member) & (x, n % #member) do: [w add: 4]!

"15:07:49, 21 czerwca 2017: Dolphin Smalltalk Professional started"!

 V reset. x := V @ #x.!

!Fitter methodsFor!
loop
	| ans czy tmp|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  "ans := (matchers at: pos) match."
		  (pos > last) 	ifTrue: [  tmp := Fitter new.
						  tmp setRule: (((matchers at: pos) rule) eval) setDatabase: database.]
					ifFalse: [tmp := (matchers at: pos)].
		 ans := tmp match.
		 (ans == true) ifTrue: [last:= pos. pos :=pos + 1 ] ifFalse: [pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		 (pos > last) ifTrue: [ tmp :=  (matchers at: pos) rule.
						e:= Fitter new.
						e setRule: (tmp eval) setDatabase: database. ]
					ifFalse: [e := (matchers at: pos) ].
		  (pos == (matchers size)) 	ifTrue: [ ans := e match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := e match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [last:=pos. pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		 (pos > last) ifTrue: [ tmp :=  (matchers at: pos) rule.
						e:= Fitter new.
						e setRule: (tmp eval) setDatabase: database. ]
					ifFalse: [e := (matchers at: pos) ].
		  (pos == (matchers size)) 	ifTrue: [ ans := e match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := e match. (ans == false) ifTrue: [pos:=pos- 1]ifFalse: [last:=pos. pos:= pos + 1] ].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop
	| ans czy tmp|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  "ans := (matchers at: pos) match."
		  (pos > last) 	ifTrue: [  tmp := Fitter new.
						       tmp setRule: (((matchers at: pos) rule) eval) setDatabase: database.]
					ifFalse: [tmp := (matchers at: pos)].
		 ans := tmp match.
		 (ans == true) ifTrue: [last:= pos. pos :=pos + 1 ] ifFalse: [pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	"res := true."
	"[res == true] "
	"whileTrue:"
	"["
		"res := ["
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans |
					  (i ==  (matchers size)) 
					  ifTrue: [ ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					  ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].
					  "ans := (matchers at: i) match."

					].
				"(i > (matchers size)) ifTrue: [true] ifFalse: [false]."
			"] value. "
			"(res == true) ifTrue: [action value]. "
			recover do: [ :x | x  zeros].
	"]"
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	"res := true."
	"[res == true] "
	"whileTrue:"
	"["
		"res := ["
				i := 1. last :=0.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans |
					  (i ==  (matchers size)) 
					  ifTrue: [ ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					  ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].
					  "ans := (matchers at: i) match."

					].
				"(i > (matchers size)) ifTrue: [true] ifFalse: [false]."
			"] value. "
			"(res == true) ifTrue: [action value]. "
			recover do: [ :x | x  zeros].
	"]"
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	"res := true."
	"[res == true] "
	"whileTrue:"
	"["
		"res := ["
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans |
					  (i ==  (matchers size)) 
					  ifTrue: [ ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					  ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1] ].
					  "ans := (matchers at: i) match."

					].
				"(i > (matchers size)) ifTrue: [true] ifFalse: [false]."
			"] value. "
			"(res == true) ifTrue: [action value]. "
			recover do: [ :x | x  zeros].
	"]"
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	"res := true."
	"[res == true] "
	"whileTrue:"
	"["
		"res := ["
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans r|
					  (i ==  (matchers size)) 
					  ifTrue: [ ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					  ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((matchers at: i) rule eval) setDatabase: database ] ] ].
					  "ans := (matchers at: i) match."

					].
				"(i > (matchers size)) ifTrue: [true] ifFalse: [false]."
			"] value. "
			"(res == true) ifTrue: [action value]. "
			recover do: [ :x | x  zeros].
	"]"
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
	"res := true."
	"[res == true] "
	"whileTrue:"
	"["
		"res := ["
				i := 1.
				[ (i >= 1) & (i <= (matchers size))] whileTrue: 
					[
					  | ans|
					  (i ==  (matchers size)) 
					  ifTrue: [ ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					  ifFalse:  [ans := (matchers at: i) match. (ans == false) ifTrue: [i :=i - 1]ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((matchers at: i) rule eval) setDatabase: database ] ] ].
					  "ans := (matchers at: i) match."

					].
				"(i > (matchers size)) ifTrue: [true] ifFalse: [false]."
			"] value. "
			"(res == true) ifTrue: [action value]. "
			recover do: [ :x | x  zeros].
	"]"
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((matchers at: i) rule eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

"15:46:08, 21 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\hhhh\proba.img7'"!

 V reset. x := V @ #x!

w := OrderedCollection new.!

p go: (x, m % #member) & (x, n % #member) do: [w add: 4]!

"15:47:24, 21 czerwca 2017: Dolphin Smalltalk Professional started"!

 V reset. x := V @ #x.!

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.!

p go: (x, m % #member) & (x, n % #member) do: [w add: 4]!

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule pos matchers moje chg'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!Fitter methodsFor!
loop
	| ans czy tmp|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match.
		 (ans == true) ifTrue: [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (matchers at: pos) rule eval) setDatabase: database ] ] ifFalse: [pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans czy tmp|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match.
		 (ans == true) ifTrue: [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (matchers at: pos) rule eval) setDatabase: database ] ] ifFalse: [pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := e match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := e match. (ans == false) 
								ifTrue: [pos:=pos- 1]
								ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (matchers at: pos) rule eval) setDatabase: database ] ] ].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := (matchers at: pos)  match. (ans == false) 
								ifTrue: [pos:=pos- 1]
								ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (matchers at: pos) rule eval) setDatabase: database ] ] ].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := (matchers at: pos)  match. (ans == false) 
								ifTrue: [pos:=pos- 1]
								ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (matchers at: pos) rule eval) setDatabase: database ] ] ].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1]ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := (matchers at: pos)  match. (ans == false) 
								ifTrue: [pos:=pos- 1]
								ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (matchers at: pos) rule eval) setDatabase: database ] ] ].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := (matchers at: pos)  match. (ans == false) 
								ifTrue: [pos:=pos- 1]
								ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (matchers at: pos) rule eval) setDatabase: database ] ] ].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: [pos:=pos.]] 
							ifFalse:  [ans := (matchers at: pos)  match. (ans == false) 
								ifTrue: [pos:=pos- 1]
								ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (matchers at: pos) rule eval) setDatabase: database ] ] ].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: [pos:=pos.]] 
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (matchers at: pos) rule eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: [pos:=pos.]] 
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (matchers at: pos) rule eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: [pos:=pos.]] 
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (matchers at: pos) rule eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: [pos:=pos.]] 
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (matchers at: pos) rule eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: [pos:=pos.]] 
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (matchers at: pos) rule eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [dbIndex :=1. pos:=1. czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [(matchers size == 0) ifTrue: [matchers  := nil]. czy := true. dbFound := false].
	].
	^czy.



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop: block. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [dbIndex :=1. pos:=1. czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. czy:=true. ^true.].
	].
	^czy.

	
	




	! !
!Fitter categoriesFor: #match:!public! !

 V reset. x := V @ #x.!

"16:02:51, 21 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\go\g.img7'"!

 V reset. x := V @ #x.!

"ttttttttttt"
w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value]!

 V reset. x := V @ #x.!

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value]!

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r.
	database := db.
	dbIndex :=1.
	pos:=1.
	moje := rule eval getVarsList.
	chg := moje.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

p go: (x, m % #member) & (x, n % #member) do: [w add: x value]!

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.!

p go: ((C % 4), m % #member)do: [w add:4]!

w!

p go: ((C % 4), m % #member)do: [w add:4]!

w!

 V reset. x := V @ #x.!

w := OrderedCollection new.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value]!

 (matchers at: i)!

w!

w!

w := OrderedCollection new.!

m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value]!

w!

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.!

p go: ((C % 7), m % #member) do: [w add: x value]!

w!

 V reset. x := V @ #x.!

"ttttttttttt"
w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value]!

 V reset. x := V @ #x.!

"ttttttttttt"
w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value]!

!Fitter methodsFor!
match:  block
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop: block. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [pos:=1. czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. czy:=true. ^true.].
	].
	^czy.

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [pos:=1. czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [(matchers size == 0) ifTrue: [matchers  := nil]. czy := true. dbFound := false].
	].
	^czy.



	! !
!Fitter categoriesFor: #match!public! !

 V reset. x := V @ #x.!

"16:27:37, 21 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\hoho\g.img7'"!

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value]!

 V reset. x := V @ #x.!

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value]!

 V reset. x := V @ #x!

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value]!

w!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value]!

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((matchers at: i) rule eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule pos matchers moje chg raw'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule pos matchers moje chg raw'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Fitter
	instanceVariableNames: 'dbIndex database rule pos matchers moje chg raw'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!Fitter methodsFor!
createMatchers: fit
	| tmp |
	raw := fit.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].! !
!Fitter categoriesFor: #createMatchers:!public! !

!Fitter methodsFor!
createMatchers: fit
	| tmp |
	raw := fit.
	matchers := Array new.
	(fit size > 0) ifTrue: [fit do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].! !
!Fitter categoriesFor: #createMatchers:!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: [pos:=pos.]] 
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos)  eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

!Fitter methodsFor!
loop
	| ans czy tmp|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match.
		 (ans == true) ifTrue: [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos) rule eval) setDatabase: database ] ] ifFalse: [pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans czy tmp|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match.
		 (ans == true) ifTrue: [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos) rule eval) setDatabase: database ] ] ifFalse: [pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans czy tmp|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match.
		 (ans == true) ifTrue: [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos) eval) setDatabase: database ] ] ifFalse: [pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop
	| ans czy tmp|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match.
		 (ans == true) ifTrue: [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos) eval) setDatabase: database ] ] ifFalse: [pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

 V reset. x := V @ #x.!

w := OrderedCollection new.!

m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.!

p go: (x, m % #member) & (x, n % #member) do: [w add: x value]!

w!

"16:43:31, 21 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\czyzby\oby.img7'"!

 V reset. x := V @ #x.!

t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.!

p go: x do: [w add: x value].!

self assert: [w = t].!

w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].!

self assert: [w = 1].!

w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1]!

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.!

p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].!

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.!

p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].!

self assert: [w = #(3 2 1) asOrderedCollection].!

"ttttttttttt"
w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value]

self assert: [w = #(4 2) asOrderedCollection].!

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].

self assert: [w = #(4 2) asOrderedCollection].!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.!

w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

"16:45:14, 21 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\blisko\bliko.img7'"!

w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
[].!

x!

x!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].

self assert: [w = 1].

w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].


z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].

self assert: [w = #(3 2 1) asOrderedCollection].


"ttttttttttt"
w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].

self assert: [w = #(4 2) asOrderedCollection].
!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
!

w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
[w add:7].!

w!

x!

w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
[w add:x value].!

w!

w!

w := OrderedCollection new.
h := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
[w add:x value. h add:y value].!

h!

w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

x!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].

self assert: [w = 1].

w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].


z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].

self assert: [w = #(3 2 1) asOrderedCollection].


"ttttttttttt"
w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].

self assert: [w = #(4 2) asOrderedCollection].!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.

w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

w!

s!

V reset.!

t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].
!


a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].
!

t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].!

C % 1 go: C % 2 do: [self assert: [false]].!

w := 0.
C % 1 go: C % 1 do: [w := w + 1].
self assert: [w = 1].
!

x := V @ #x.
y := V @ #y.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].
!

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].!

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].!

w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].!

x go: L, x do: [self assert: [false]].!

V reset. t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].

a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].

t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].

C % 1 go: C % 2 do: [self assert: [false]].

w := 0.
C % 1 go: C % 1 do: [w := w + 1].
self assert: [w = 1].

x := V @ #x.
y := V @ #y.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].

w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].

x go: L, x do: [self assert: [false]].!

w := OrderedCollection new.
h := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [w add: x. h add:y].!

w!

w!

w := OrderedCollection new.
h := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [w add: x value. h add:y value].!

w!

h!

L % 1!

L % 1!

V reset.
t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].

a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].

t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].

C % 1 go: C % 2 do: [self assert: [false]].

w := 0.
C % 1 go: C % 1 do: [w := w + 1].
self assert: [w = 1].


x := V @ #x.
y := V @ #y.
x setValue: nil.
y setValue: nil.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].
w := 0.
[x value] on: Error do: [:ex | w := w + 1].
[y value] on: Error do: [:ex | w := w + 1].
self assert: [w = 2].

x setValue: nil.
w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].


w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].

w := 0.
z := V @ #z.
x % 1, x go: y, y, z do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1].
    self assert: [z value = 1]].
self assert: [w = 1].

x setValue: nil.
x go: L, x do: [self assert: [false]].


"external"
w := 0.
x, y % 1 go: z, x, y do: [
	w := w + 1.
	 self assert: [x value = 1].
	self assert: [y value = 1].
	self assert: [z value = 1]
].
self assert: [w = 1].

x := V @ #x.
y := V @ #y.
w := 0.
x go: y do: [
	x, y go: C % 1 % 1 do: [
	w := 1.
	self assert: [x value = 1].
	self assert: [y value = 1]
]
].

w := 0.
x := V @ #x.
y := V @ #y.
z := V @ #z.
d := V @ #d.
w := 0.
e := 0.
o := 0.
(x, y), (z, y) go: d do: [
	d go: (y, z), (x % 1) do: [
		w := 1.
		self assert: [x value = 1].
		self assert: [y value = 1].
		self assert: [z value = 1].
		self assert: [d value cdr cdr = 1].
		self assert: [d value cdr car = 1].
		self assert: [d value car cdr = 1].
		self assert: [d value car car = 1].

		self assert: [d cdr value cdr = 1].
		self assert: [d cdr value car = 1].
		self assert: [d car value cdr = 1].
		self assert: [d car value car = 1].
		
		self assert: [d cdr cdr value  = 1].
		self assert: [d cdr car value = 1].
		self assert: [d car cdr value = 1].
		self assert: [d car car value = 1].
		
		[x car] on: Error do: [:ex | e := e + 1].
		[x cdr] on: Error do: [:ex | e := e + 1].
	].
	[x value] on: Error do: [:ex | o := o + 1].
	[y value] on: Error do: [:ex | o := o + 1].
	[z value] on: Error do: [:ex | o := o + 1].
	[d value] on: Error do: [:ex | o := o + 1].
].
self assert: [w = 1].
self assert: [e = 2].
self assert: [o = 4].


x := V @ #x.
y := V @ #y.
w := 0.
x go: y do: [
y go: x do: [
x, y go: C % 1 % 2 do: [
w := w + 1.
].
].
].
self assert: [w = 0].


x := C % nil.
self assert: [x value = nil].
self assert: [L value = nil].

x := V @ nil.
y := V @ nil.
self assert: [x == y].
 
!

V reset.
t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].!

a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].!

t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].

C % 1 go: C % 2 do: [self assert: [false]].

w := 0.
C % 1 go: C % 1 do: [w := w + 1].
self assert: [w = 1].!

x := V @ #x.
y := V @ #y.
x setValue: nil.
y setValue: nil.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].
w := 0.
[x value] on: Error do: [:ex | w := w + 1].
[y value] on: Error do: [:ex | w := w + 1].
self assert: [w = 2].

x setValue: nil.
w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].


w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].

w := 0.
z := V @ #z.
x % 1, x go: y, y, z do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1].
    self assert: [z value = 1]].
self assert: [w = 1].

x setValue: nil.
x go: L, x do: [self assert: [false]].
!

x := V @ #x.
y := V @ #y.
x setValue: nil.
y setValue: nil.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].
w := 0.
[x value] on: Error do: [:ex | w := w + 1].
[y value] on: Error do: [:ex | w := w + 1].
self assert: [w = 2].

x setValue: nil.
w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].


w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].

w := 0.
z := V @ #z.
x % 1, x go: y, y, z do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1].
    self assert: [z value = 1]].
self assert: [w = 1].

x setValue: nil.
x go: L, x do: [self assert: [false]].
!

V reset.
t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].!

V reset.
t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].

a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].

t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].

C % 1 go: C % 2 do: [self assert: [false]].

w := 0.
C % 1 go: C % 1 do: [w := w + 1].
self assert: [w = 1].


x := V @ #x.
y := V @ #y.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].
w := 0.
[x value] on: Error do: [:ex | w := w + 1].
[y value] on: Error do: [:ex | w := w + 1].
self assert: [w = 2].


w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].


w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].

w := 0.
z := V @ #z.
x % 1, x go: y, y, z do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1].
    self assert: [z value = 1]].
self assert: [w = 1].


x go: L, x do: [self assert: [false]].
!

w := 0.
x, y % 1 go: z, x, y do: [
	w := w + 1.
	 self assert: [x value = 1].
	self assert: [y value = 1].
	self assert: [z value = 1]
].
self assert: [w = 1].!

x := V @ #x.
y := V @ #y.
w := 0.
x go: y do: [
	x, y go: C % 1 % 1 do: [
	w := 1.
	self assert: [x value = 1].
	self assert: [y value = 1]
]
].!

w := 0.
x := V @ #x.
y := V @ #y.
z := V @ #z.
d := V @ #d.
w := 0.
e := 0.
o := 0.
(x, y), (z, y) go: d do: [
	d go: (y, z), (x % 1) do: [
		w := 1.
		self assert: [x value = 1].
		self assert: [y value = 1].
		self assert: [z value = 1].
		self assert: [d value cdr cdr = 1].
		self assert: [d value cdr car = 1].
		self assert: [d value car cdr = 1].
		self assert: [d value car car = 1].

		self assert: [d cdr value cdr = 1].
		self assert: [d cdr value car = 1].
		self assert: [d car value cdr = 1].
		self assert: [d car value car = 1].
		
		self assert: [d cdr cdr value  = 1].
		self assert: [d cdr car value = 1].
		self assert: [d car cdr value = 1].
		self assert: [d car car value = 1].
		
		[x car] on: Error do: [:ex | e := e + 1].
		[x cdr] on: Error do: [:ex | e := e + 1].
	].
	[x value] on: Error do: [:ex | o := o + 1].
	[y value] on: Error do: [:ex | o := o + 1].
	[z value] on: Error do: [:ex | o := o + 1].
	[d value] on: Error do: [:ex | o := o + 1].
].
self assert: [w = 1].
self assert: [e = 2].
self assert: [o = 4].!

x := V @ #x.
y := V @ #y.
w := 0.
x go: y do: [
y go: x do: [
x, y go: C % 1 % 2 do: [
w := w + 1.
].
].
].
self assert: [w = 0].!

x := C % nil.
self assert: [x value = nil].
self assert: [L value = nil].
!

x := V @ nil.
y := V @ nil.
self assert: [x == y].!

s := OrderedCollection new.!

q := V @ #q.!

p go: a, q % #member do: [s add: (w at:1) value].!

w := OrderedCollection new.
h := OrderedCollection new.!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].

self assert: [w = 1].

w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].


z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].

self assert: [w = #(3 2 1) asOrderedCollection].


"ttttttttttt"
w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].

self assert: [w = #(4 2) asOrderedCollection].
!


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
!

w := OrderedCollection new.
h := OrderedCollection new.!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

q:=nil.!

 V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].

self assert: [w = 1].

w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].


y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].


z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].

self assert: [w = #(3 2 1) asOrderedCollection].


"ttttttttttt"
w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].

self assert: [w = #(4 2) asOrderedCollection].




a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

s!

a!

q!

x!

y!

C % t!

a C!

hh := C%(C%3)!

hh!

hh := C%(C%3%4)!

hh !

hh := C%3%4!

hh !

hh := C%(C%3%4) !

hh !

w :=0!

C%(C%3%4) go: (C%3%4) do: [w:=w+1]!

w!

(C%(C%3%4)) go: (C%3%4) do: [w:=w+1]!

(C%(C%3%4)) go: (C%3%4) do: [w:=w+1]w!

w!

e:=(C%(C%3%4)) !

e!

f:=(C%3%4)!

f!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.!

w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

a!

p go: a, q % #member do: [s add: a value].!

q!

x!

w !

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].
!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

s!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

w := OrderedCollection new.
h := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [w add: x value. h add: y value].!

w!

h!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
h := OrderedCollection new.!

V reset.!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
h := OrderedCollection new.!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $a% $b) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].
!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $a% $b) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

"18:51:52, 21 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\jakies\bliko.img7'"!

!C methodsFor!
printString
	! !
!C categoriesFor: #printString!public! !

!C methodsFor!
printString
	^'ok'! !
!C categoriesFor: #printString!public! !

p go: x, y, (L % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

p go: x, y, (L % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

!C methodsFor!
printString
	^ value asString! !
!C categoriesFor: #printString!public! !

p go: x, y, (L % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

!V methodsFor!
printString
	^ value asString! !
!V categoriesFor: #printString!public! !

!V methodsFor!
printString
	^ value asString! !
!V categoriesFor: #printString!public! !

!Pair methodsFor!
printString
	^ car value asString , ',' , cdr value asString! !
!Pair categoriesFor: #printString!public! !

!Pair methodsFor!
printString
	^ car value asString , ',' , cdr value asString! !
!Pair categoriesFor: #printString!public! !

p go: x, y, (L % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

!Pair methodsFor!
printString
	^ car printString , ',' , cdr printString! !
!Pair categoriesFor: #printString!public! !

p go: x, y, (L % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

!Pair methodsFor!
printString
	^ '(', car printString , ',' , cdr printString, ')'! !
!Pair categoriesFor: #printString!public! !

p go: x, y, (L % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

!C methodsFor!
printString
	(value==nil) ifTrue: [^'_'].^value asString! !
!C categoriesFor: #printString!public! !

!V methodsFor!
printString
	(value==nil) ifTrue: [^'_'].^value asString! !
!V categoriesFor: #printString!public! !

!V methodsFor!
printString
	(value==nil) ifTrue: [^'_'].^value asString! !
!V categoriesFor: #printString!public! !

!V methodsFor!
printString
	(value==nil) ifTrue: [^'*'].^value asString! !
!V categoriesFor: #printString!public! !

p go: x, y, (L % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

p go: x, y, (L % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

p!

p!

Object subclass: #Term
	instanceVariableNames: 'type value szow'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!C methodsFor!
printString
	(value==nil) ifTrue: [szow:='_'. ^'_'].^szow:= value asString! !
!C categoriesFor: #printString!public! !

!V methodsFor!
printString
	(value==nil) ifTrue: [szow:='*'. ^'*'].^szow:= value asString! !
!V categoriesFor: #printString!public! !

!V methodsFor!
printString
	(value==nil) ifTrue: [szow:='*'. ^'*'].^szow:= value asString! !
!V categoriesFor: #printString!public! !

!Pair methodsFor!
printString
	^ szow:='(', car printString , ',' , cdr printString, ')'! !
!Pair categoriesFor: #printString!public! !

p!

!Pair methodsFor!
printString
	^'(', car printString , ',' , cdr printString, ')'! !
!Pair categoriesFor: #printString!public! !

Object subclass: #Term
	instanceVariableNames: 'type value'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Term
	instanceVariableNames: 'type value'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #Term
	instanceVariableNames: 'type value'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!C methodsFor!
printString
	(value==nil) ifTrue: [^'_'].^value asString! !
!C categoriesFor: #printString!public! !

!C methodsFor!
printString
	(value==nil) ifTrue: [^'_'].^value asString! !
!C categoriesFor: #printString!public! !

!V methodsFor!
printString
	(value==nil) ifTrue: [ ^'*'].^value asString! !
!V categoriesFor: #printString!public! !

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.!

!V methodsFor!
printString
	(value==nil) ifTrue: [ ^addr asString, '=' , '*'].^addr asString, '=' , value asString! !
!V categoriesFor: #printString!public! !

!V methodsFor!
printString
	(value==nil) ifTrue: [ ^addr asString, '=' , '*'].^addr asString, '=' , value asString! !
!V categoriesFor: #printString!public! !

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.!

w := OrderedCollection new.
p go: x, y, (L % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

!C methodsFor!
printString
	(value==nil) ifTrue: [^'_'].^value! !
!C categoriesFor: #printString!public! !

!C methodsFor!
printString
	(value==nil) ifTrue: [^'_'].^value! !
!C categoriesFor: #printString!public! !

!V methodsFor!
printString
	(value==nil) ifTrue: [ ^addr asString, '=' , '*'].^addr asString, '=' , value! !
!V categoriesFor: #printString!public! !

w := OrderedCollection new.
p go: x, y, (L % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

!V methodsFor!
printString
	(value==nil) ifTrue: [ ^addr printString, '=' , '*'].^addr printString, '=' , value! !
!V categoriesFor: #printString!public! !

!C methodsFor!
printString
	(value==nil) ifTrue: [^'_'].^value printString! !
!C categoriesFor: #printString!public! !

!C methodsFor!
printString
	(value==nil) ifTrue: [^'_'].^value printString! !
!C categoriesFor: #printString!public! !

w := OrderedCollection new.
p go: x, y, (L % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.!

p go: x, y, (L % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	last := ask eval.
	((last class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:last.]
	ifFalse: [ tab:= last terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask eval.]
	ifFalse: [ tab:= last terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask eval.]
	ifFalse: [ tab:= ask.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask eval.]
	ifFalse: [ tab:= ask.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: elem setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask eval.]
	ifFalse: [ tab:= ask.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval)setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask eval.]
	ifFalse: [ tab:= ask.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval)setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem)setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem)setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem)setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem)setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem)setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem)setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem)setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem)setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem)setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem)setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask eval.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem)setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask eval.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval)setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask eval.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

p go: x, y, (L % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

w!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

w!


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

 a!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

w!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask eval.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval)setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask eval.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem)setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem)setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem)setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem)setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

q!

a!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].
!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].!

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem)setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval)setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | res recover matchers tmp i tab last|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask eval.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval)setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
!

w!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].
!

"20:47:41, 21 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\ghmmm\bliko.img7'"!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

self printString!

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r eval.
	database := db.
	dbIndex :=1.
	pos:=1.
	moje := rule eval getVarsList.
	chg := moje.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r eval.
	database := db.
	dbIndex :=1.
	pos:=1.
	moje := rule eval getVarsList.
	chg := moje.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

a Prolog!

w!

w!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].!

w!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].
!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

w!

V reset!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
!

!Fitter methodsFor!
setRule: r setDatabase: db
	rule := r eval.
	database := db.
	dbIndex :=1.
	pos:=1.
	moje := rule eval getVarsList.
	chg := moje.
	! !
!Fitter categoriesFor: #setRule:setDatabase:!public! !

Fitter removeSelector: #createMatcher ifAbsent: []!

Fitter removeSelector: #createMatchers ifAbsent: []!

Fitter removeSelector: #match:action: ifAbsent: []!

Fitter removeSelector: #match:next: ifAbsent: []!

!Prolog methodsFor!
go: ask do: action
	 | recover matchers tmp i tab|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask eval.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | recover matchers tmp i tab|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask eval.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  zeros].
	




! !
!Prolog categoriesFor: #go:do:!public! !

"21:00:09, 21 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\rrr\bliko.img7'"!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
!

!Fitter methodsFor!
loop
	| ans czy |
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match.
		 (ans == true) ifTrue: [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos) eval) setDatabase: database ] ] ifFalse: [pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!public! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: []] 
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos)  eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!public! !

1 max: 2!

"21:54:39, 21 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\ohhh\bliko.img7'"!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].
!


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].
!


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

!Matcher methodsFor!
chooseAction: terms
	| tmp fst snd err1 err2|
	tmp := self transformTerms: terms.
	fst := tmp car eval .
	snd := tmp cdr eval.
	((fst isMemberOf: V) & ((snd isMemberOf: V))) ifTrue: [err1 := fst is: snd. err2:= snd is: fst.  ((err1 == Error) | (err2 == Error)) ifTrue: [^Error]. ^Set new].
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			err1:= snd is: fst. (err1 == Error) ifTrue: [^Error]. ^Set new
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			err1:= fst is: snd. (err1 == Error) ifTrue: [^Error]. ^Set new
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| tmp fst snd err1 err2|
	tmp := self transformTerms: terms.
	fst := tmp car eval .
	snd := tmp cdr eval.
	((fst isMemberOf: V) & ((snd isMemberOf: V))) ifTrue: [err1 := fst is: snd. err2:= snd is: fst.  ((err1 == Error) | (err2 == Error)) ifTrue: [^Error]. ^Set new].
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			err1:= snd is: fst. (err1 == Error) ifTrue: [^Error]. ^Set new
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			err1:= fst is: snd. (err1 == Error) ifTrue: [^Error]. ^Set new
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

!Matcher methodsFor!
chooseAction: terms
	| tmp fst snd err1 err2|
	tmp := self transformTerms: terms.
	fst := tmp car eval .
	snd := tmp cdr eval.
	((fst isMemberOf: V) & ((snd isMemberOf: V))) ifTrue: [err1 := fst is: snd. err2:= snd is: fst.  ((err1 == Error) | (err2 == Error)) ifTrue: [^Error]. ^Set new].
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			err1:= snd is: fst. (err1 == Error) ifTrue: [^Error]. ^Set new
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			err1:= fst is: snd. (err1 == Error) ifTrue: [^Error]. ^Set new
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

w!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

w!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

w!

"05:23:15, 22 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\czwartek_poczatek\mj.img7'"!

"05:23:59, 22 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\workspace_czwartek\work.img7'"!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].
!


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

q!

223 eval!

z:= V @ 223!

k := z eval!

k!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

V reset.!

y := V @ #y.!

 x := V @ #x.!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

w!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

V reset. x := V @ #x.!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

w!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.!

w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

w!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

w!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
!

w!

w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

w!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
!

w!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

w!

w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

w!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

w!

V reset. x := V @ #x.!

y := V @ #y.!

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

w!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

!V class methodsFor!
var: i
	| tmp arr|
	(VarsDict == nil) ifTrue: [VarsDict  := Dictionary  new. UsedVars := Set new. Index:=0].
	tmp := VarsDict includesKey: i.
	UsedVars add: i.
	(tmp) ifTrue: 
			[arr := VarsDict at:i]
			ifFalse:
			[arr :=VarsDict at: i put: (V new addr: i )].
	^arr
	! !
!V class categoriesFor: #var:!public! !

!Database methodsFor!
find: term index: index
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[
			  t := (rules at: i) trans.
			  h := t car head. 
			  term go: h do: [work := false. p car: (t car body) cdr: i . ^p].
			  V delete: t cdr.
			  i := i + 1.
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

w!

V!

!V methodsFor!
hardReset
	self zeros.
	refers := Array new.! !
!V categoriesFor: #hardReset!public! !

!V methodsFor!
hardReset
	self zeros.
	refers := Set new.! !
!V categoriesFor: #hardReset!public! !

!V methodsFor!
hardReset
	self zeros.
	refers := Set new.! !
!V categoriesFor: #hardReset!public! !

!Prolog methodsFor!
go: ask do: action
	 | recover matchers tmp i tab|
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask eval.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  hardReset ].
	




! !
!Prolog categoriesFor: #go:do:!public! !

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

w!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

!V methodsFor!
is: v
	| list |
	(v isMemberOf: V) ifTrue: [^refers add: v].
	((value == nil) not) ifTrue:[ (((value eval)cmp: (v eval)) not) ifTrue: [^Error] ifFalse: [^self]].
	list := v getVarsList.
	((list indexOf: self) > 0) ifTrue: [^Error].
	value := v.
	refers do: [:el | el is: v].
	"refers := Set new."


! !
!V categoriesFor: #is:!public! !

!V methodsFor!
is: v
	| list |
	(v isMemberOf: V) ifTrue: [^refers add: v].
	((value == nil) not) ifTrue:[ (((value eval)cmp: (v eval)) not) ifTrue: [^Error] ifFalse: [^self]].
	list := v getVarsList.
	((list indexOf: self) > 0) ifTrue: [^Error].
	value := v.
	refers do: [:el | el is: v].
	"refers := Set new."


! !
!V categoriesFor: #is:!public! !

!V methodsFor!
is: v
	| list |
	(v isMemberOf: V) ifTrue: [^refers add: v].
	((value == nil) not) ifTrue:[ (((value eval)cmp: (v eval)) not) ifTrue: [^Error] ifFalse: [^self]].
	list := v getVarsList.
	((list indexOf: self) > 0) ifTrue: [^Error].
	value := v.
	refers do: [:el | el is: v].
	"refers := Set new."


! !
!V categoriesFor: #is:!public! !

!V methodsFor!
is: v
	| list |
	(v isMemberOf: V) ifTrue: [^refers add: v].
	((value == nil) not) ifTrue:[ (((value eval)cmp: (v eval)) not) ifTrue: [^Error] ifFalse: [^self]].
	list := v getVarsList.
	((list indexOf: self) > 0) ifTrue: [^Error].
	value := v.
	refers do: [:el | el is: v].
	"refers := Set new."


! !
!V categoriesFor: #is:!public! !

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
!

w!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

w!

!V methodsFor!
is: v
	| list |
	(v isMemberOf: V) ifTrue: [^refers add: v].
	((value == nil) not) ifTrue:[ ((value cmp: v ) not) ifTrue: [^Error] ifFalse: [^self]].
	list := v getVarsList.
	((list indexOf: self) > 0) ifTrue: [^Error].
	value := v.
	refers do: [:el | el is: v].
	"refers := Set new."


! !
!V categoriesFor: #is:!public! !

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
!

w!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

V@223!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
!

!Matcher methodsFor!
chooseAction: terms
	| tmp fst snd err1 err2|
	tmp := self transformTerms: terms.
	fst := tmp car.
	snd := tmp cdr.
	((fst isMemberOf: V) & ((snd isMemberOf: V))) ifTrue: [err1 := fst is: snd. err2:= snd is: fst.  ((err1 == Error) | (err2 == Error)) ifTrue: [^Error]. ^Set new].
	(fst cmp: snd) ifTrue: [^Set new].
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error].
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error].
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			err1:= snd is: fst. (err1 == Error) ifTrue: [^Error]. ^Set new
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			err1:= fst is: snd. (err1 == Error) ifTrue: [^Error]. ^Set new
		].
! !
!Matcher categoriesFor: #chooseAction:!public! !

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

w!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
!

(V @ 223) value!

(V @ 223) value!

(V @ 223) value!

(V @ 223) value!

(V @ 223) value!

x!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
!

p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

(V @ 223) value!

(V @ 223) value!

(V @ 223) value!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].!

!V methodsFor!
eval
	((value == nil) not) ifTrue: [^self val eval] ifFalse: [^self]! !
!V categoriesFor: #eval!public! !

!V methodsFor!
eval
	((value == nil) not) ifTrue: [^self val eval] ifFalse: [^self]! !
!V categoriesFor: #eval!public! !

!V methodsFor!
eval
	((value == nil) not) ifTrue: [^self val eval] ifFalse: [^self]! !
!V categoriesFor: #eval!public! !

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
!

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
!

w!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].


a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.

p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
self assert: [w = #('' 'abc' 'a' 'bc' 'ab' 'c' 'abc' '') asOrderedCollection]!

t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].

a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].

t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].

C % 1 go: C % 2 do: [self assert: [false]].

w := 0.
C % 1 go: C % 1 do: [w := w + 1].
self assert: [w = 1].


x := V @ #x.
y := V @ #y.
x setValue: nil.
y setValue: nil.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].
w := 0.
[x value] on: Error do: [:ex | w := w + 1].
[y value] on: Error do: [:ex | w := w + 1].
self assert: [w = 2].

x setValue: nil.
w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].


w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].

w := 0.
z := V @ #z.
x % 1, x go: y, y, z do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1].
    self assert: [z value = 1]].
self assert: [w = 1].

x setValue: nil.
x go: L, x do: [self assert: [false]].


"external"
w := 0.
x, y % 1 go: z, x, y do: [
	w := w + 1.
	 self assert: [x value = 1].
	self assert: [y value = 1].
	self assert: [z value = 1]
].
self assert: [w = 1].

x := V @ #x.
y := V @ #y.
w := 0.
x go: y do: [
	x, y go: C % 1 % 1 do: [
	w := 1.
	self assert: [x value = 1].
	self assert: [y value = 1]
]
].

w := 0.
x := V @ #x.
y := V @ #y.
z := V @ #z.
d := V @ #d.
w := 0.
e := 0.
o := 0.
(x, y), (z, y) go: d do: [
	d go: (y, z), (x % 1) do: [
		w := 1.
		self assert: [x value = 1].
		self assert: [y value = 1].
		self assert: [z value = 1].
		self assert: [d value cdr cdr = 1].
		self assert: [d value cdr car = 1].
		self assert: [d value car cdr = 1].
		self assert: [d value car car = 1].

		self assert: [d cdr value cdr = 1].
		self assert: [d cdr value car = 1].
		self assert: [d car value cdr = 1].
		self assert: [d car value car = 1].
		
		self assert: [d cdr cdr value  = 1].
		self assert: [d cdr car value = 1].
		self assert: [d car cdr value = 1].
		self assert: [d car car value = 1].
		
		[x car] on: Error do: [:ex | e := e + 1].
		[x cdr] on: Error do: [:ex | e := e + 1].
	].
	[x value] on: Error do: [:ex | o := o + 1].
	[y value] on: Error do: [:ex | o := o + 1].
	[z value] on: Error do: [:ex | o := o + 1].
	[d value] on: Error do: [:ex | o := o + 1].
].
self assert: [w = 1].
self assert: [e = 2].
self assert: [o = 4].


x := V @ #x.
y := V @ #y.
w := 0.
x go: y do: [
y go: x do: [
x, y go: C % 1 % 2 do: [
w := w + 1.
].
].
].
self assert: [w = 0].


x := C % nil.
self assert: [x value = nil].
self assert: [L value = nil].

x := V @ nil.
y := V @ nil.
self assert: [x == y].
 
!

t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].

a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].

t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].

C % 1 go: C % 2 do: [self assert: [false]].

w := 0.
C % 1 go: C % 1 do: [w := w + 1].
self assert: [w = 1].


x := V @ #x.
y := V @ #y.


w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].
w := 0.
[x value] on: Error do: [:ex | w := w + 1].
[y value] on: Error do: [:ex | w := w + 1].
self assert: [w = 2].


w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].


w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].

w := 0.
z := V @ #z.
x % 1, x go: y, y, z do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1].
    self assert: [z value = 1]].
self assert: [w = 1].


x go: L, x do: [self assert: [false]].


"external"
w := 0.
x, y % 1 go: z, x, y do: [
	w := w + 1.
	 self assert: [x value = 1].
	self assert: [y value = 1].
	self assert: [z value = 1]
].
self assert: [w = 1].

x := V @ #x.
y := V @ #y.
w := 0.
x go: y do: [
	x, y go: C % 1 % 1 do: [
	w := 1.
	self assert: [x value = 1].
	self assert: [y value = 1]
]
].

w := 0.
x := V @ #x.
y := V @ #y.
z := V @ #z.
d := V @ #d.
w := 0.
e := 0.
o := 0.
(x, y), (z, y) go: d do: [
	d go: (y, z), (x % 1) do: [
		w := 1.
		self assert: [x value = 1].
		self assert: [y value = 1].
		self assert: [z value = 1].
		self assert: [d value cdr cdr = 1].
		self assert: [d value cdr car = 1].
		self assert: [d value car cdr = 1].
		self assert: [d value car car = 1].

		self assert: [d cdr value cdr = 1].
		self assert: [d cdr value car = 1].
		self assert: [d car value cdr = 1].
		self assert: [d car value car = 1].
		
		self assert: [d cdr cdr value  = 1].
		self assert: [d cdr car value = 1].
		self assert: [d car cdr value = 1].
		self assert: [d car car value = 1].
		
		[x car] on: Error do: [:ex | e := e + 1].
		[x cdr] on: Error do: [:ex | e := e + 1].
	].
	[x value] on: Error do: [:ex | o := o + 1].
	[y value] on: Error do: [:ex | o := o + 1].
	[z value] on: Error do: [:ex | o := o + 1].
	[d value] on: Error do: [:ex | o := o + 1].
].
self assert: [w = 1].
self assert: [e = 2].
self assert: [o = 4].


x := V @ #x.
y := V @ #y.
w := 0.
x go: y do: [
y go: x do: [
x, y go: C % 1 % 2 do: [
w := w + 1.
].
].
].
self assert: [w = 0].


x := C % nil.
self assert: [x value = nil].
self assert: [L value = nil].

x := V @ nil.
y := V @ nil.
self assert: [x == y].
 
!

t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].

a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].

t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].

C % 1 go: C % 2 do: [self assert: [false]].

w := 0.
C % 1 go: C % 1 do: [w := w + 1].
self assert: [w = 1].


x := V @ #x.
y := V @ #y.


w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].
w := 0.
[x value] on: Error do: [:ex | w := w + 1].
[y value] on: Error do: [:ex | w := w + 1].
self assert: [w = 2].


w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].


w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].

w := 0.
z := V @ #z.
x % 1, x go: y, y, z do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1].
    self assert: [z value = 1]].
self assert: [w = 1].


x go: L, x do: [self assert: [false]].


"external"
w := 0.
x, y % 1 go: z, x, y do: [
	w := w + 1.
	 self assert: [x value = 1].
	self assert: [y value = 1].
	self assert: [z value = 1]
].
self assert: [w = 1].

x := V @ #x.
y := V @ #y.
w := 0.
x go: y do: [
	x, y go: C % 1 % 1 do: [
	w := 1.
	self assert: [x value = 1].
	self assert: [y value = 1]
]
].

w := 0.
x := V @ #x.
y := V @ #y.
z := V @ #z.
d := V @ #d.
w := 0.
e := 0.
o := 0.
(x, y), (z, y) go: d do: [
	d go: (y, z), (x % 1) do: [
		w := 1.
		self assert: [x value = 1].
		self assert: [y value = 1].
		self assert: [z value = 1].
		self assert: [d value cdr cdr = 1].
		self assert: [d value cdr car = 1].
		self assert: [d value car cdr = 1].
		self assert: [d value car car = 1].

		self assert: [d cdr value cdr = 1].
		self assert: [d cdr value car = 1].
		self assert: [d car value cdr = 1].
		self assert: [d car value car = 1].
		
		self assert: [d cdr cdr value  = 1].
		self assert: [d cdr car value = 1].
		self assert: [d car cdr value = 1].
		self assert: [d car car value = 1].
		
		[x car] on: Error do: [:ex | e := e + 1].
		[x cdr] on: Error do: [:ex | e := e + 1].
	].
	[x value] on: Error do: [:ex | o := o + 1].
	[y value] on: Error do: [:ex | o := o + 1].
	[z value] on: Error do: [:ex | o := o + 1].
	[d value] on: Error do: [:ex | o := o + 1].
].
self assert: [w = 1].
self assert: [e = 2].
self assert: [o = 4].


x := V @ #x.
y := V @ #y.
w := 0.
x go: y do: [
y go: x do: [
x, y go: C % 1 % 2 do: [
w := w + 1.
].
].
].
self assert: [w = 0].


x := C % nil.
self assert: [x value = nil].
self assert: [L value = nil].

 
!

t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].

a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].

t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].

C % 1 go: C % 2 do: [self assert: [false]].

w := 0.
C % 1 go: C % 1 do: [w := w + 1].
self assert: [w = 1].

x := V @ #x.
y := V @ #y.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].

w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].

x go: L, x do: [self assert: [false]].!

!Database methodsFor!
find: term index: index
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[
			  t := (rules at: i) trans.
			  h := t car head. 
			  term go: h do: [work := false. p car: (t car body) cdr: i . ^p].
			  "V delete: t cdr."
			  i := i + 1.
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].

a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].

t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].

C % 1 go: C % 2 do: [self assert: [false]].

w := 0.
C % 1 go: C % 1 do: [w := w + 1].
self assert: [w = 1].

x := V @ #x.
y := V @ #y.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].

w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].

x go: L, x do: [self assert: [false]].!

"09:08:07, 22 czerwca 2017: Image saved"!

x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
self assert: [w = #('' 'abc' 'a' 'bc' 'ab' 'c' 'abc' '') asOrderedCollection]!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
self assert: [w = #('' 'abc' 'a' 'bc' 'ab' 'c' 'abc' '') asOrderedCollection]!

V reset. t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].

a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].

t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].

C % 1 go: C % 2 do: [self assert: [false]].

w := 0.
C % 1 go: C % 1 do: [w := w + 1].
self assert: [w = 1].

x := V @ #x.
y := V @ #y.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].

w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].

x go: L, x do: [self assert: [false]].!

"09:13:35, 22 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\brawo\super.img7'"!

"09:13:47, 22 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\super\grejt.img7'"!

V reset.
x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
self assert: [w = #('' 'abc' 'a' 'bc' 'ab' 'c' 'abc' '') asOrderedCollection]!

t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].

a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].

t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].

C % 1 go: C % 2 do: [self assert: [false]].

w := 0.
C % 1 go: C % 1 do: [w := w + 1].
self assert: [w = 1].

x := V @ #x.
y := V @ #y.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].

w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].

x go: L, x do: [self assert: [false]].!

V reset.!

x:= V @ #x
y= V @ #y!

x:= V @ #x.
y:= V @ #y!

V reset.
x:= V @ #x.
y:= V @ #y.
w:=0.
m:=0.!

x go: y do: [w:=x value. m:=y value].!

x go: y do: [w:=x value. m:=y value].!


p1 := x % 1. 
p2 := 1 @ y.!

w:=0.
m:=0.
x go: y do: [w:=x value. m:=y value].!

V reset.
x:= V @ #x.
y:= V @ #y.
p1 := x % 1. 
p2 := 1 @ y.
w:=0.
m:=0.!

x go: y do: [w:=x value. m:=y value].!

V reset.
x:= V @ #x.
y:= V @ #y.
p1 := x % 1. 
p2 := 1 @ y.
w:=0.
m:=0.!

x go: y do: [w:=x value. m:=y value].!

p1!

V reset.
x:= V @ #x.
y:= V @ #y.
p1 := x % 1. 
p2 := 1 @ y.
w:=0.
m:=0.
p1 go: p2 do: [w:=x value. m:=y value].!

V reset.
x:= V @ #x.
y:= V @ #y.
p1 := x % 1. 
p2 := 1 @ y.
w:=0.
m:=0.!

x:= V @ #x.!

V reset.
x:= V @ #x.
y:= V @ #y.
p1 := x % 1. 
p2 := 1 @ y.
w:=0.
m:=0.!

p1 go: p2 do: [w:=x value. m:=y value].!

V reset.
x:= V @ #x.
y:= V @ #y.
p1 := x % 1. 
p2 := (C  % 1) @ y.
w:=0.
m:=0.!

p1 go: p2 do: [w:=x value. m:=y value].!

p2!

V reset.
x:= V @ #x.
y:= V @ #y.
p1 := x % (C  % 1). 
p2 := (C  % 1) @ y.
w:=0.
m:=0.!

p1 go: p2 do: [w:=x value. m:=y value].!

p1!

p1!

p2 !

p2 !

c :=(C  % 1)!

p2 := c @ y.!

p2 := c @ y.!

p2 := c @ y.!

p2 := c @ y.!

p2 := c @ y.!

p2 !

p2 := c , y.!

p2 := c , y.!

w:=0.
m:=0.
p1 go: p2 do: [w:=x value. m:=y value].!

w!

y!

V reset.
x:= V @ #x.
y:= V @ #y.
p1 := x , (C  % 1). 
p2 := c , y.
w:=0.
m:=0.!

p1 go: p2 do: [w:=x value. m:=y value].!

w!

m!

V reset.
x:= V @ #x.
y:= V @ #y.
p1 := x , y. 
p2 := y , x.
w:=0.
m:=0.!

p1 go: p2 do: [w:=7].!

w!

V reset.
x:= V @ #x.
y:= V @ #y.
p1 := x , (x, y). 
p2 := 1, (y,y).
w:=0.
m:=0.
p1 go: p2 do: [w:=7].!

V reset.
x:= V @ #x.
y:= V @ #y.
p1 := x , (x, y). 
p2 := c, (y,y).
w:=0.
m:=0.!

p1 go: p2 do: [w:=7].!

V reset.
x:= V @ #x.
y:= V @ #y.
p1 := x , (x, y). 
p2 := c, (y,y).
w:=0.
m:=0.
p1 go: p2 do: [w:=x value. m:=y value].!

m!

w!

V reset.
x:= V @ #x.
y:= V @ #y.
p1 := x , (x, y). 
p2 := c, (y,c).
w:=0.
m:=0.
p1 go: p2 do: [w:=x value. m:=y value].!

m!

w!

V reset.
x:= V @ #x.
y:= V @ #y.
p1 := x , (x, y). 
p2 := c, (y,(C % 7)).
w:=0.
m:=0.
p1 go: p2 do: [w:=x value. m:=y value].!

w!

m!

V reset.
x:= V @ #x.
y:= V @ #y.
w:=0.
m:=0.
x go: y do: [w:=x value. m:=y value].


p1 := x , (C  % 1). 
p2 := c , y.
w:=0.
m:=0.
p1 go: p2 do: [w:=x value. m:=y value].


p1 := x , y. 
p2 := y , x.
w:=0.
m:=0.
p1 go: p2 do: [w:=7].


p1 := x , (x, y). 
p2 := c, (y,y).
w:=0.
m:=0.
p1 go: p2 do: [w:=x value. m:=y value].




p1 := x , (x, y). 
p2 := c, (y,c).
w:=0.
m:=0.
p1 go: p2 do: [w:=x value. m:=y value].


p1 := x , (x, y). 
p2 := c, (y,(C % 7)).
w:=0.
m:=0.
p1 go: p2 do: [w:=x value. m:=y value].


!

V reset.
x:= V @ #x.
y:= V @ #y.
w:=0.
m:=0.
x go: y do: [w:=x value. m:=y value].!

p1 := x , (C  % 1). 
p2 := c , y.
w:=0.
m:=0.
p1 go: p2 do: [w:=x value. m:=y value].!

p1 := x , y. 
p2 := y , x.
w:=0.
m:=0.
p1 go: p2 do: [w:=7].
!

p1 := x , (x, y). 
p2 := c, (y,y).
w:=0.
m:=0.
p1 go: p2 do: [w:=x value. m:=y value].!

p1 := x , (x, y). 
p2 := c, (y,c).
w:=0.
m:=0.
p1 go: p2 do: [w:=x value. m:=y value].!

p1 := x , (x, y). 
p2 := c, (y,(C % 7)).
w:=0.
m:=0.
p1 go: p2 do: [w:=x value. m:=y value].!

r:= V @ #r.
z:= V @ #z.
p1 := (((x , z),z),r). 
p1 := (((y , y),r),7). 
w:=0.
m:=0.
p1 go: p2 do: [w:=x value. m:=y value].!

r:= V @ #r.
z:= V @ #z.
p1 := (((x , z),z),r). 
p1 := (((y , y),r),(C % 7)). 
w:=0.
m:=0.
p1 go: p2 do: [w:=x value. m:=y value].
!

m!

w!

p1!

p1!

r:= V @ #r.
z:= V @ #z.
p1 := (((x , z),z),r). 
p2 := (((y , y),r),(C % 7)). 
w:=0.
m:=0.!

p1 go: p2 do: [w:=x value. m:=y value].!

w!

m!

r:= V @ #r.
z:= V @ #z.
p1 := (((x , z),z),r). 
p2 := (((y , y),r),(C % 7)). 
w:=0.
m:=0.
q:=0.
p:=0.
p1 go: p2 do: [w:=x value. m:=y value.  q:=z value.  p:=r value].!

w!

q!

p!

m!

Term comment:
'Type of abstract class. That''s root class for all types of terms.'!
Term comment:
'Type of abstract class. That''s root class for all types of terms. It provides some basic implemenation of methods, that are common for all terms. Mostly these implementation are only mockups and are overrided in subclasses.

'!
Term comment:
'Type of abstract class. That''s root class for all types of terms. It provides some basic implemenation of methods, that are common for all terms. Mostly these implementation are only mockups and are overrided in subclasses.

Instance Variables:
type - keeps information about term type (pair, const, var)
'!
Term comment:
'Type of abstract class. That''s root class for all types of terms. It provides some basic implemenation of methods, that are common for all terms. Mostly these implementation are only mockups and are overrided in subclasses.

Instance Variables:
type - keeps information about term type (pair, const, var)
value - every term could have another value, so it depends on particular term, what can be stored in value'!
Term comment:
'Type of abstract class. That''s root class for all types of terms. It provides some basic implemenation of methods, that are common for all terms. Mostly these implementation are only mockups and are overrided in subclasses.

Instance Variables:
type - keeps information about term type (pair, const, var)
value - every term could have another value, so it depends on particular term, what can be stored in value

Instance methods:
% - '!
Term comment:
'Type of abstract class. That''s root class for all types of terms. It provides some basic implemenation of methods, that are common for all terms. Mostly these implementation are only mockups and are overrided in subclasses.

Instance Variables:
type - keeps information about term type (pair, const, var)
value - every term could have another value, so it depends on particular term, what can be stored in value

Instance methods:
% - that''t shortcut for creating pair with '!
Term comment:
'Type of abstract class. That''s root class for all types of terms. It provides some basic implemenation of methods, that are common for all terms. Mostly these implementation are only mockups and are overrided in subclasses.

Instance Variables:
type - keeps information about term type (pair, const, var)
value - every term could have another value, so it depends on particular term, what can be stored in value

Instance methods:
% value - that''t shortcut for creating pair with self and value as constant
& term - logical and, allows creating list of terms. It returns conjunction type
'!
Term comment:
'Type of abstract class. That''s root class for all types of terms. It provides some basic implemenation of methods, that are common for all terms. Mostly these implementation are only mockups and are overrided in subclasses.

Instance Variables:
type - keeps information about term type (pair, const, var)
value - every term could have another value, so it depends on particular term, what can be stored in value

Instance methods:
% value - that''t shortcut for creating pair with self and value as constant
& term - logical and, allows creating list of terms. It returns conjunction type
, term - creates pair with self and term
'!
Term comment:
'Type of abstract class. That''s root class for all types of terms. It provides some basic implemenation of methods, that are common for all terms. Mostly these implementation are only mockups and are overrided in subclasses.

Instance Variables:
type - keeps information about term type (pair, const, var)
value - every term could have another value, so it depends on particular term, what can be stored in value

Instance methods:
% value - that''t shortcut for creating pair with self and value as constant
& term - logical and, allows creating list of terms. It returns conjunction type
, term - creates pair with self and term
, name - that''t shortcut for creating pair with self and variable name
'!
Term comment:
'Type of abstract class. That''s root class for all types of terms. It provides some basic implemenation of methods, that are common for all terms. Mostly these implementation are only mockups and are overrided in subclasses.

Instance Variables:
type - keeps information about term type (pair, const, var)
value - every term could have another value, so it depends on particular term, what can be stored in value

Instance methods:
% value - that''t shortcut for creating pair with self and value as constant
& term - logical and, allows creating list of terms. It returns conjunction type
, term - creates pair with self and term
@ name - that''t shortcut for creating pair with self and variable name
anonim: dict - needed in second part of task. It replace orginal vars in term with corrospending vars from dict. It works as in PROLOG. During process of goal unification, orginal variables should be replaced with new vars (like _123). In my soultion anonim vars are generated by V and has names from first unused number (as name).
'!
Term comment:
'Type of abstract class. That''s root class for all types of terms. It provides some basic implemenation of methods, that are common for all terms. Mostly these implementation are only mockups and are overrided in subclasses.

Instance Variables:
type - keeps information about term type (pair, const, var)
value - every term could have another value, so it depends on particular term, what can be stored in value

Instance methods:
% value - that''t shortcut for creating pair with self and value as constant
& term - logical and, allows creating list of terms. It returns conjunction type
, term - creates pair with self and term
@ name - that''t shortcut for creating pair with self and variable name
anonim: dict - needed in second part of task. It replace orginal vars in term with corrospending vars from dict. It works as in PROLOG. During process of goal unification, orginal variables should be replaced with new vars (like _123). In my soultion anonim vars are generated by V and has names from first unused number (as name).
cmp : t - overriding custom default comparision (==). Implemenation depends on term.
eval - initialized values in some cases should be replaced by their values, so that''s what eval is doing
getVarsList - get all vars that occurs in terms (it extract vars recurively from pairs)
go: tern do  block- unificate self with term and if unifciation is possible, execute block



'!
Term comment:
'Type of abstract class. That''s root class for all types of terms. It provides some basic implemenation of methods, that are common for all terms. Mostly these implementation are only mockups and are overrided in subclasses.

Instance Variables:
type - keeps information about term type (pair, const, var)
value - every term could have another value, so it depends on particular term, what can be stored in value

Instance methods:
% value - that''t shortcut for creating pair with self and value as constant
& term - logical and, allows creating list of terms. It returns conjunction type
, term - creates pair with self and term
@ name - that''t shortcut for creating pair with self and variable name
anonim: dict - needed in second part of task. It replace orginal vars in term with corrospending vars from dict. It works as in PROLOG. During process of goal unification, orginal variables should be replaced with new vars (like _123). In my soultion anonim vars are generated by V and has names from first unused number (as name).
cmp : t - overriding custom default comparision (==). Implemenation depends on term.
eval - initialized values in some cases should be replaced by their values, so that''s what eval is doing
getVarsList - get all vars that occurs in terms (it extract vars recurively from pairs)
go: tern do  block- unificate self with term and if unifciation is possible, execute block
value - interpretation of value - depends on term type



'!
C comment:
'Class reprents Constant values factory. Object are terms of type const.'!
C comment:
'Class reprents Constant values factory. Object are terms of type const. Value is field inherited from Term class ans keeps value of const.

Type of abstract class. That''s root class for all types of terms. It provides some basic implemenation of methods, that are common for all terms. Mostly these implementation are only mockups and are overrided in subclasses.

Instance methods:
anonim: dict - needed in second part of task. It replace orginal vars in term with corrospending vars from dict. It works as in PROLOG. During process of goal unification, orginal variables should be replaced with new vars (like _123). In my soultion anonim vars are generated by V and has names from first unused number (as name).
cmp : t - overriding custom default comparision (==). Implemenation depends on term.
eval - initialized values in some cases should be replaced by their values, so that''s what eval is doing
getVarsList - get all vars that occurs in terms (it extract vars recurively from pairs)
go: tern do  block- unificate self with term and if unifciation is possible, execute block
value - interpretation of value - depends on term type'!
C comment:
'Class reprents Constant values factory. Object are terms of type const. Value is field inherited from Term class ans keeps value of const.

Type of abstract class. That''s root class for all types of terms. It provides some basic implemenation of methods, that are common for all terms. Mostly these implementation are only mockups and are overrided in subclasses.

Instance methods:
anonim: dict - vars isn''t variable so it doesn''t change value
cmp : t - overriding custom default comparision (==). Implemenation depends on term.
eval - initialized values in some cases should be replaced by their values, so that''s what eval is doing
getVarsList - get all vars that occurs in terms (it extract vars recurively from pairs)
go: tern do  block- unificate self with term and if unifciation is possible, execute block
value - interpretation of value - depends on term type'!
C comment:
'Class reprents Constant values factory. Object are terms of type const. Value is field inherited from Term class ans keeps value of const.

Type of abstract class. That''s root class for all types of terms. It provides some basic implemenation of methods, that are common for all terms. Mostly these implementation are only mockups and are overrided in subclasses.

Instance methods:
anonim: dict - vars isn''t variable so it doesn''t change value
eval - similar to anonim
getVarsList - empty array
go: tern do  block- unificate self with term and if unifciation is possible, execute block
value - interpretation of value - depends on term type'!
C comment:
'Class reprents Constant values factory. Object are terms of type const. Value is field inherited from Term class ans keeps value of const. Interpretation of const is value  simply value.

Instance methods:
anonim: dict - vars isn''t variable so it doesn''t change value
eval - similar to anonim
cmp: term - if term is const and yours and term values are the same, than consts are equal.
getVarsList - empty array
type: value - interpretation of value - depends on term type'!
C comment:
'Class reprents Constant values factory. Object are terms of type const. Value is field inherited from Term class ans keeps value of const. Interpretation of const is value  simply value.

Instance methods:
anonim: dict - vars isn''t variable so it doesn''t change value
eval - similar to anonim
cmp: term - if term is const and yours and term values are the same, than consts are equal.
getVarsList - empty array
type: value - inits fields of object'!
C comment:
'Class reprents Constant values factory. Object are terms of type const. Value is field inherited from Term class ans keeps value of const. Interpretation of const is value  simply value.

Class methods:
% - C is Const values factor, so it creates new constant

Instance methods:
anonim: dict - vars isn''t variable so it doesn''t change value
eval - similar to anonim
cmp: term - if term is const and yours and term values are the same, than consts are equal.
getVarsList - empty array
type: value - inits fields of object'!
"10:23:30, 22 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\komentarze\better.img7'"!

"10:23:35, 22 czerwca 2017: Image saved"!

Pair comment:
'Class reprents pair of terms (Pair(car,cdr)). Interpretation of pair is pair created from car and cdr interpretations.  

Some methods are self explanatory, so the only one interesting thins is that car means first value from pair and cdr means second value.
Methods that are makeing some evaluation (like eval, getVarsList) are returining recurive computation for car and cdr.'!
V comment:
'Class reprents Variables factory. Object are terms of type var. Value is field inherited from Term class ans keeps value of var. Interpretation of var is value, but befor assigning value to vars it is nil.


Class methods:
@ name - V is Vars factory, so it creates new variable if variable with name doesn''t exists and in case it was already createg @ returns that variable.

Instance variables:
addr - name of var
refers - set of another vars, that refers to self. It is needed in case when we unify: x = y and both vars doesn''t have any concrete value. So if after unficiation vars points at another vars, that doesn''t have concreate value, than value is nil. Information about x =y is only included in refers. When assigining value to var, that have vars on refers list, value should be assigined to every var on refers (it work recurively). So if x = y = z = q, and after some step
y = 1, than x = 1, y =1 , z = 1, q = 1 and refers aren''t up to date any more. The process of passing value is implemented in is:'!
!V methodsFor!
anonim: dict
	^(dict at: self)"replace with value assigned to self addr"! !
!V categoriesFor: #anonim:!public! !

!V methodsFor!
anonim: dict
	"replace with value assigned to self addr"
	^(dict at: self)! !
!V categoriesFor: #anonim:!public! !

!V methodsFor!
canBind
	" The same meaning as isUninitialized, but it was used in other semtanic context"
	(value == nil) ifTrue: [^true] ifFalse: [false]! !
!V categoriesFor: #canBind!public! !

!V methodsFor!
canBind
	" The same meaning as isUninitialized, but it was used in other semtanic context"
	(value == nil) ifTrue: [^true] ifFalse: [false]! !
!V categoriesFor: #canBind!public! !

!V methodsFor!
hardReset
	" At the contrary to zeros, it clean refers"
	self zeros.
	refers := Set new.! !
!V categoriesFor: #hardReset!public! !

!V methodsFor!
is: v
	| list |
	(v isMemberOf: V) ifTrue: [^refers add: v].
	((value == nil) not) ifTrue:[ ((value cmp: v ) not) ifTrue: [^Error] ifFalse: [^self]].
	list := v getVarsList.
	((list indexOf: self) > 0) ifTrue: [^Error].
	value := v.
	refers do: [:el | el is: v]." Pass value to another vars in chains, that point on each other"
	"refers := Set new."


! !
!V categoriesFor: #is:!public! !

!V methodsFor!
is: v
	| list |
	(v isMemberOf: V) ifTrue: [^refers add: v].
	((value == nil) not) ifTrue:[ ((value cmp: v ) not) ifTrue: [^Error] ifFalse: [^self]].
	list := v getVarsList.
	((list indexOf: self) > 0) ifTrue: [^Error].
	value := v.
	refers do: [:el | el is: v]." Pass value to another vars in chains, that point on each other"
	"refers := Set new."


! !
!V categoriesFor: #is:!public! !

!V methodsFor!
val
	" Raw value - not interpreatation"
	^value! !
!V categoriesFor: #val!public! !

!V methodsFor!
val
	" Raw value - not interpretation"
	^value! !
!V categoriesFor: #val!public! !

!V methodsFor!
value
	" Interpreatation of value"
	^ value value! !
!V categoriesFor: #value!public! !

!V methodsFor!
value
	" Interpretation of value"
	^ value value! !
!V categoriesFor: #value!public! !

V comment:
'Class reprents Variables factory. Object are terms of type var. Value is field inherited from Term class ans keeps value of var. Interpretation of var is value, but befor assigning value to vars it is nil.


Class methods:
@ name - V is Vars factory, so it creates new variable if variable with name doesn''t exists and in case it was already createg @ returns that variable.
reset - reset state of V as factory
FreeVar - used in second part - it returns first free vars, that can be used as king of anonimous variable - it choose first unused (as name) number.
delete: num - frees number of anonim var


Instance variables:
addr - name of var
refers - set of another vars, that refers to self. It is needed in case when we unify: x = y and both vars doesn''t have any concrete value. So if after unficiation vars points at another vars, that doesn''t have concreate value, than value is nil. Information about x =y is only included in refers. When assigining value to var, that have vars on refers list, value should be assigined to every var on refers (it work recurively). So if x = y = z = q, and after some step
y = 1, than x = 1, y =1 , z = 1, q = 1 and refers aren''t up to date any more. The process of passing value is implemented in is:
	







'!
!V class methodsFor!
FreeVar
	| v |
	(UsedVars == nil) ifTrue: [UsedVars := Set new. Index:=0].
	[(UsedVars includes: Index) ] whileTrue: [Index := Index + 1]. " Look for first free numer for name"
	v := V @ Index.
	Index := Index + 1.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
FreeVar
	| v |
	(UsedVars == nil) ifTrue: [UsedVars := Set new. Index:=0].
	[(UsedVars includes: Index) ] whileTrue: [Index := Index + 1]. " Look for first free numer for name"
	v := V @ Index.
	Index := Index + 1.
	^v.! !
!V class categoriesFor: #FreeVar!public! !

!V class methodsFor!
FreeVar
	| v |
	(UsedVars == nil) ifTrue: [UsedVars := Set new. Index:=0].
	[(UsedVars includes: Index) ] whileTrue: [Index := Index + 1]. " Look for first free numer for name"
	v := V @ Index.
	Index := Index + 1. " Counter of first free number - kinf of heuristic"
	^v.! !
!V class categoriesFor: #FreeVar!public! !

!Term methodsFor!
go: t do: action
	" Heart of first part of task - it starts process of unification"
	| m p ans recover|
	m := Matcher new.
	p := Pair new.
	p car: self cdr: t.
	ans := m iterate: p.
	(ans == Error) ifFalse:
		[action value].
	recover := self getVarsList , t getVarsList.
	recover do: [ :x | x  zeros]
	
	! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
go: t do: action
	" Heart of first part of task - it starts process of unification"
	| m p ans recover|
	m := Matcher new. " Worker that will do work od unification"
	p := Pair new.
	p car: self cdr: t.
	ans := m iterate: p.
	(ans == Error) ifFalse:
		[action value].
	recover := self getVarsList , t getVarsList.
	recover do: [ :x | x  zeros]
	
	! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
go: t do: action
	" Heart of first part of task - it starts process of unification"
	| m p ans recover|
	m := Matcher new. " Worker that will do work od unification"
	p := Pair new.
	p car: self cdr: t. " car first term cdr second term to unify" 
	ans := m iterate: p.
	(ans == Error) ifFalse:
		[action value].
	recover := self getVarsList , t getVarsList.
	recover do: [ :x | x  zeros]
	
	! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
go: t do: action
	" Heart of first part of task - it starts process of unification"
	| m p ans recover|
	m := Matcher new. " Worker that will do work od unification"
	p := Pair new.
	p car: self cdr: t. " car first term cdr second term to unify" 
	ans := m iterate: p. " Loop of unification"
	(ans == Error) ifFalse:
		[action value]. " If success that execute block"
	recover := self getVarsList , t getVarsList.
	recover do: [ :x | x  zeros]
	
	! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
go: t do: action
	" Heart of first part of task - it starts process of unification"
	| m p ans recover|
	m := Matcher new. " Worker that will do work od unification"
	p := Pair new.
	p car: self cdr: t. " car first term cdr second term to unify" 
	ans := m iterate: p. " Loop of unification"
	(ans == Error) ifFalse:
		[action value]. " If success that execute block"
	recover := self getVarsList , t getVarsList." Recover initial values of vars"
	recover do: [ :x | x  zeros]
	
	! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
go: t do: action
	" Heart of first part of task - it starts process of unification"
	| m p ans recover|
	m := Matcher new. " Worker that will do work od unification"
	p := Pair new.
	p car: self cdr: t. " car first term cdr second term to unify" 
	ans := m iterate: p. " Loop of unification"
	(ans == Error) ifFalse:
		[action value]. " If success that execute block"
	" Recover initial values of vars"
	recover := self getVarsList , t getVarsList.
	recover do: [ :x | x  zeros]
	
	! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
go: t do: action
	" Heart of first part of task - it starts process of unification"
	| m p ans recover|
	m := Matcher new. " Worker that will do work od unification"
	p := Pair new.
	p car: self cdr: t. " car first term cdr second term to unify" 
	ans := m iterate: p. " Loop of unification"
	(ans == Error) ifFalse:
		[action value]. " If success that execute block"
	"Recover initial values of vars"
	recover := self getVarsList , t getVarsList.
	recover do: [ :x | x  zeros]
	
	! !
!Term categoriesFor: #go:do:!public! !

!Term methodsFor!
go: t do: action
	" Heart of first part of task - it starts process of unification"
	| m p ans recover|
	m := Matcher new. " Worker that will do work od unification"
	p := Pair new.
	p car: self cdr: t. " car first term cdr second term to unify" 
	ans := m iterate: p. " Loop of unification"
	(ans == Error) ifFalse:
		[action value]. " If success that execute block"
	"Recover initial values of vars"
	recover := self getVarsList , t getVarsList.
	recover do: [ :x | x  zeros]
	
	! !
!Term categoriesFor: #go:do:!public! !

Matcher comment:
'Object created for every unification process. It encapsulate most work.'!
Matcher comment:
'Object created for every unification process. It encapsulates most of work.

'!
Matcher comment:
'Object created for every unification process. It encapsulates most of work.

Object methods:
chooseAction -> given two terms '!
Matcher comment:
'Object created for every unification process. It encapsulates most of work.

Object methods:
chooseAction -> given two terms it tries to unify them.
'!
"10:46:08, 22 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\dalejdalej\better.img7'"!

!Matcher categoriesFor: #makePairs:snd:!private! !

!Matcher categoriesFor: #transformTerms:!private! !

!Matcher categoriesFor: #chooseAction:!private! !

!Matcher methodsFor!
chooseAction: terms
	| tmp fst snd err1 err2|
	tmp := self transformTerms: terms.
	fst := tmp car.
	snd := tmp cdr.
	" In fst and snd there are two terms to unify"
	((fst isMemberOf: V) & ((snd isMemberOf: V))) ifTrue: [err1 := fst is: snd. err2:= snd is: fst.  ((err1 == Error) | (err2 == Error)) ifTrue: [^Error]. ^Set new]. " var = var"
	(fst cmp: snd) ifTrue: [^Set new]. " term1 is identical to term2"
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error]. " pair == const -> cannot unify"
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error]. "const == pair -> cannot unify"
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd].
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			err1:= snd is: fst. (err1 == Error) ifTrue: [^Error]. ^Set new
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			err1:= fst is: snd. (err1 == Error) ifTrue: [^Error]. ^Set new
		].
! !
!Matcher categoriesFor: #chooseAction:!private! !

!Matcher methodsFor!
chooseAction: terms
	| tmp fst snd err1 err2|
	tmp := self transformTerms: terms.
	fst := tmp car.
	snd := tmp cdr.
	" In fst and snd there are two terms to unify"
	((fst isMemberOf: V) & ((snd isMemberOf: V))) ifTrue: [err1 := fst is: snd. err2:= snd is: fst.  ((err1 == Error) | (err2 == Error)) ifTrue: [^Error]. ^Set new]. " var = var"
	(fst cmp: snd) ifTrue: [^Set new]. " term1 is identical to term2"
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error]. " pair == const -> cannot unify"
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error]. "const == pair -> cannot unify"
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd]. " take terms from pair and try to unify them separeted"
	" assign value to pair"
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			err1:= snd is: fst. (err1 == Error) ifTrue: [^Error]. ^Set new
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			err1:= fst is: snd. (err1 == Error) ifTrue: [^Error]. ^Set new
		].
! !
!Matcher categoriesFor: #chooseAction:!private! !

!Matcher methodsFor!
chooseAction: terms
	| tmp fst snd err1 err2|
	tmp := self transformTerms: terms.
	fst := tmp car.
	snd := tmp cdr.
	" In fst and snd there are two terms to unify"
	((fst isMemberOf: V) & ((snd isMemberOf: V))) ifTrue: [err1 := fst is: snd. err2:= snd is: fst.  ((err1 == Error) | (err2 == Error)) ifTrue: [^Error]. ^Set new]. " var = var"
	(fst cmp: snd) ifTrue: [^Set new]. " term1 is identical to term2"
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error]. " pair == const -> cannot unify"
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error]. "const == pair -> cannot unify"
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd]. " take terms from pair and try to unify them separeted"
	" assign value to pair"
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			err1:= snd is: fst. (err1 == Error) ifTrue: [^Error]. ^Set new
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			err1:= fst is: snd. (err1 == Error) ifTrue: [^Error]. ^Set new
		].
! !
!Matcher categoriesFor: #chooseAction:!private! !

!Matcher methodsFor!
chooseAction: terms
	| tmp fst snd err1 err2|
	" Simulates elseif"
	tmp := self transformTerms: terms.
	fst := tmp car.
	snd := tmp cdr.
	" In fst and snd there are two terms to unify"
	((fst isMemberOf: V) & ((snd isMemberOf: V))) ifTrue: [err1 := fst is: snd. err2:= snd is: fst.  ((err1 == Error) | (err2 == Error)) ifTrue: [^Error]. ^Set new]. " var = var"
	(fst cmp: snd) ifTrue: [^Set new]. " term1 is identical to term2"
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error]. " pair == const -> cannot unify"
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error]. "const == pair -> cannot unify"
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd]. " take terms from pair and try to unify them separeted"
	" assign value to pair"
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			err1:= snd is: fst. (err1 == Error) ifTrue: [^Error]. ^Set new
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			err1:= fst is: snd. (err1 == Error) ifTrue: [^Error]. ^Set new
		].
! !
!Matcher categoriesFor: #chooseAction:!private! !

!Matcher methodsFor!
chooseAction: terms
	| tmp fst snd err1 err2|
	" Simulates elseifs"
	tmp := self transformTerms: terms.
	fst := tmp car.
	snd := tmp cdr.
	" In fst and snd there are two terms to unify"
	((fst isMemberOf: V) & ((snd isMemberOf: V))) ifTrue: [err1 := fst is: snd. err2:= snd is: fst.  ((err1 == Error) | (err2 == Error)) ifTrue: [^Error]. ^Set new]. " var = var"
	(fst cmp: snd) ifTrue: [^Set new]. " term1 is identical to term2"
	((fst isMemberOf: Pair) & ((snd isMemberOf: C))) ifTrue: [^Error]. " pair == const -> cannot unify"
	((snd isMemberOf: Pair) & ((fst isMemberOf: C) )) ifTrue: [^Error]. "const == pair -> cannot unify"
	((fst isMemberOf: Pair) & (snd isMemberOf: Pair)) ifTrue: [^self makePairs: fst snd: snd]. " take terms from pair and try to unify them separeted"
	" assign value to pair"
	(((fst isMemberOf: V) not) & (snd isMemberOf: V)) ifTrue: 
		[
			err1:= snd is: fst. (err1 == Error) ifTrue: [^Error]. ^Set new
		].
	(((snd isMemberOf: V) not) & (fst isMemberOf: V)) ifTrue: 
		[
			err1:= fst is: snd. (err1 == Error) ifTrue: [^Error]. ^Set new
		].
! !
!Matcher categoriesFor: #chooseAction:!private! !

!Matcher methodsFor!
iterate: what
	container := Set new.
	container add: what. " Current set of terms to unify"
	[container isEmpty not] whileTrue: 
		[
			| tmp addition |
			tmp := container anyOne.
			addition := self chooseAction: tmp.
			container remove: tmp.
			((addition isMemberOf: Matcher) | (addition == Error) ) ifTrue: [^Error].
			container addAll: addition
		].
	^container! !
!Matcher categoriesFor: #iterate:!public! !

!Matcher methodsFor!
iterate: what
	container := Set new.
	container add: what. " Current set of terms to unify"
	[container isEmpty not] whileTrue: 
		[
			| tmp addition |
			tmp := container anyOne.
			addition := self chooseAction: tmp.
			container remove: tmp.
			((addition isMemberOf: Matcher) | (addition == Error) ) ifTrue: [^Error].
			container addAll: addition
		].
	^container! !
!Matcher categoriesFor: #iterate:!public! !

!Matcher methodsFor!
iterate: what
	container := Set new.
	container add: what. " Current set of terms to unify"
	[container isEmpty not] whileTrue: 
		[
			| tmp addition |
			tmp := container anyOne. " Take any term to unify"
			addition := self chooseAction: tmp.
			container remove: tmp.
			((addition isMemberOf: Matcher) | (addition == Error) ) ifTrue: [^Error].
			container addAll: addition" Pair is separetd into terms"
		].
	^container! !
!Matcher categoriesFor: #iterate:!public! !

!Matcher methodsFor!
iterate: what
	container := Set new.
	container add: what. " Current set of terms to unify"
	[container isEmpty not] whileTrue: 
		[
			| tmp addition |
			tmp := container anyOne. " Take any term to unify"
			addition := self chooseAction: tmp. " Try to unify"
			container remove: tmp.
			((addition isMemberOf: Matcher) | (addition == Error) ) ifTrue: [^Error].
			container addAll: addition" Pair is separetd into terms"
		].
	^container! !
!Matcher categoriesFor: #iterate:!public! !

!Matcher methodsFor!
makePairs: t1 snd: t2
	" It extracts terms from two pairs and returns set of that terms"
	| fst1 fst2 snd1 snd2 p1 p2  s|
	fst1 := t1 car.
	fst2 := t2 car.
	snd1 := t1 cdr.
	snd2 := t2 cdr.
	p1 := Pair new car: fst1 cdr: fst2.
	p2 := Pair new car: snd1 cdr: snd2.
	s := Set new.
	s add: p1.
	s add: p2.
	^ s
	
	! !
!Matcher categoriesFor: #makePairs:snd:!private! !

!Matcher methodsFor!
makePairs: t1 snd: t2
	" It extracts terms from two pairs and returns set of that terms"
	| fst1 fst2 snd1 snd2 p1 p2  s|
	fst1 := t1 car.
	fst2 := t2 car.
	snd1 := t1 cdr.
	snd2 := t2 cdr.
	p1 := Pair new car: fst1 cdr: fst2.
	p2 := Pair new car: snd1 cdr: snd2.
	s := Set new.
	s add: p1.
	s add: p2.
	^ s
	
	! !
!Matcher categoriesFor: #makePairs:snd:!private! !

Matcher comment:
'Object created for every unification process. It encapsulates most of work.

Object methods:
chooseAction -> given two terms it tries to unify them.

Privates methods are described in their bodies"'!
Matcher comment:
'Object created for every unification process. It encapsulates most of work.

Object vars:
contatiner - during process of unfication we have to unify all terms from set. The successfull unfication means empty set.

Object methods:
chooseAction -> given two terms it tries to unify them.

Privates methods are described in their bodies"'!
Fitter removeSelector: #xxx: ifAbsent: []!

Prolog comment:
'Prolog interpeter. Stores all rules and facts and is obligated to ask for logic questions (go:do)

'!
Prolog removeSelector: #fitter: ifAbsent: []!

!Prolog methodsFor!
init
	" Called by new"
	database := Database new! !
!Prolog categoriesFor: #init!public! !

!Prolog methodsFor!
fact: a
	" Add new fact"
	database addFact:  a! !
!Prolog categoriesFor: #fact:!public! !

!Prolog methodsFor!
head: h body: b
	" Add rule in form of head :- body"
	| tmp arr|
	tmp := Pair new.
	((b class superclass) == Term) ifTrue: [arr:= Array new:1. arr at:1 put: b]
	ifFalse: [arr:= b terms].
	tmp car: h cdr: arr.
	database addRule: tmp  ! !
!Prolog categoriesFor: #head:body:!public! !

!Prolog methodsFor!
head: h body: b
	" Add rule in form of head :- body"
	| tmp arr|
	tmp := Pair new.
	((b class superclass) == Term) ifTrue: [arr:= Array new:1. arr at:1 put: b]" Only one term in body"
	ifFalse: [arr:= b terms].
	tmp car: h cdr: arr.
	database addRule: tmp  ! !
!Prolog categoriesFor: #head:body:!public! !

!Prolog methodsFor!
head: h body: b
	" Add rule in form of head :- body"
	| tmp arr|
	tmp := Pair new.
	((b class superclass) == Term) ifTrue: [arr:= Array new:1. arr at:1 put: b]" Only one term in body"
	ifFalse: [arr:= b terms]." list of terms"
	tmp car: h cdr: arr.
	database addRule: tmp  ! !
!Prolog categoriesFor: #head:body:!public! !

!Prolog methodsFor!
head: h body: b
	" Add rule in form of head :- body"
	| tmp arr|
	tmp := Pair new.
	((b class superclass) == Term) 	ifTrue: [arr:= Array new:1. arr at:1 put: b]" Only one term in body"
							ifFalse: [arr:= b terms]." list of terms"
	tmp car: h cdr: arr.
	database addRule: tmp! !
!Prolog categoriesFor: #head:body:!public! !

Prolog comment:
'Prolog interpeter. Stores all rules and facts and is obligated to ask for logic questions (go:do)
Prolog objects manages whole processes connected with "prolog" work.

Object methods:
fact: f - add new fact to database, in fact, fact is rule with empty body
head: h body: b - rule addition
go:do - answer the logical question
'!
!C methodsFor!
printString
	(value==nil) ifTrue: [^'_'].
	^value printString! !
!C categoriesFor: #printString!public! !

!V methodsFor!
is: v
	| list |
	(v isMemberOf: V) ifTrue: [^refers add: v].
	((value == nil) not)
			ifTrue:	[
						((value cmp: v ) not) ifTrue: [^Error] ifFalse: [^self]
					].
	list := v getVarsList.
	((list indexOf: self) > 0) ifTrue: [^Error].
	value := v.
	refers do: [:el | el is: v]." Pass value to another vars in chains, that point on each other"
	"refers := Set new."


! !
!V categoriesFor: #is:!public! !

!Matcher methodsFor!
transformTerms: terms
	| term1 term2 t1 t2 tmp |
	term1 := terms car .
	term2 := terms cdr.
	t1 := term1.
	t2 := term2.
	(term1 isMemberOf: V) ifTrue:  
		[
			((term1 isUninitialized) not) ifTrue: [ t1 := term1 val]
		].
	(term2 isMemberOf: V) ifTrue: 
		[
			((term2 isUninitialized) not) ifTrue: [ t2 := term2 val]
		].
	tmp := Pair new.
	tmp car: t1 cdr: t2.
	^tmp! !
!Matcher categoriesFor: #transformTerms:!private! !

!Matcher methodsFor!
transformTerms: terms
	| term1 term2 t1 t2 tmp |
	term1 := terms car .
	term2 := terms cdr.
	t1 := term1.
	t2 := term2.
	(term1 isMemberOf: V) ifTrue:  
		[
			((term1 isUninitialized) not) ifTrue: [ t1 := term1 val]
		].
	(term2 isMemberOf: V) ifTrue: 
		[
			((term2 isUninitialized) not) ifTrue: [ t2 := term2 val]
		].
	tmp := Pair new.
	tmp car: t1 cdr: t2.
	^tmp! !
!Matcher categoriesFor: #transformTerms:!private! !

Database comment:
'Every object represents all konwledge database. It stores fact and rules in the same way. Facty in stored as rule with empty body.'!
Database comment:
'Every object represents all konwledge database. It stores fact and rules in the same way. Facty in stored as rule with empty body.
In addition to storing rules it allows to find unfication with any rules. As in prolog rules as stored in indexed way.'!
!Database methodsFor!
addFact: fact
	| tmp |
	tmp := Pair new.
	tmp car: fact cdr: [].
	self addRule: tmp " Just rule with empty body"! !
!Database categoriesFor: #addFact:!public! !

!Database methodsFor!
find: term index: index
	" Try to find unfication wirh some of rules from database, starting matching from index"
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue:
			[
			  t := (rules at: i) trans.
			  h := t car head. 
			  term go: h do: [work := false. p car: (t car body) cdr: i . ^p].
			  "V delete: t cdr."
			  i := i + 1.
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	" Try to find unfication wirh some of rules from database, starting matching from index"
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue: " Iterate to find match or to prove that that is not matching rule"
			[
			  t := (rules at: i) trans.
			  h := t car head. 
			  " Is there unfication of destination term and particular term from db?"
			  term go: h do: [work := false. p car: (t car body) cdr: i . ^p].
			  "V delete: t cdr."
			  i := i + 1.
			].
	^Error
	! !
!Database categoriesFor: #find:index:!public! !

!Database methodsFor!
find: term index: index
	" Try to find unfication wirh some of rules from database, starting matching from index"
	| len  work i t h p|
	p := Pair new.
	i := index.
	len := rules size.
	work := true.
	[(i <= len) & (work)] whileTrue: " Iterate to find match or to prove that that is not matching rule"
			[
			  t := (rules at: i) trans.
			  h := t car head. 
			  " Is there unfication of destination term and particular term from db?"
			  term go: h do: [work := false. p car: (t car body) cdr: i . ^p].
			  "V delete: t cdr."
			  i := i + 1.
			].
	^Error "no match"
	


! !
!Database categoriesFor: #find:index:!public! !

Database comment:
'Every object represents all konwledge database. It stores fact and rules in the same way. Facty in stored as rule with empty body.
In addition to storing rules it allows to find unfication with any rules(look at find:index:). As in prolog rules as stored in indexed way.'!
Fitter comment:
'It reprents node in tree of prolog searching(encapsulate backtracking etc.)'!
!Fitter categoriesFor: #dbFind!private! !

!Fitter categoriesFor: #createMatchers:!private! !

!Fitter categoriesFor: #loop!private! !

!Fitter categoriesFor: #loop:!private! !

Fitter comment:
'It reprents node in tree of prolog searching(encapsulate backtracking etc.).

It takes rule(probabaly partially matched) and tries to to satisfie goal, based on konwledge from database. It allows backtracking and multiple solution looking by remebering dbIndex(index of last matched rule from db) an by rembering position (pos) it list of goals to satisfy.'!
Fitter comment:
'It reprents node in tree of prolog searching(encapsulate backtracking etc.).

It takes rule(probabaly partially matched) and tries to to satisfie goal, based on konwledge from database. It allows backtracking and multiple solution looking by remebering dbIndex(index of last matched rule from db) an by rembering position (pos) it list of goals to satisfy.

match and match: block (the same for loops) are a little bit different becasue of some rule/conds are just leafs in seraching tree and if satisfy they can execute block.'!
!Fitter methodsFor!
dbFind
	" Try to find next rule that matches with your rule"
	| res maj|
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1.
	^res car.! !
!Fitter categoriesFor: #dbFind!private! !

!Fitter methodsFor!
dbFind
	" Try to find next rule that matches with your rule"
	| res maj|
	maj := rule eval .
	res := database find: maj index: dbIndex.
	(res == Error) ifTrue: [^false].
	dbIndex := res cdr + 1. " Next time look for rules under found"
	^res car.! !
!Fitter categoriesFor: #dbFind!private! !

Fitter comment:
'It reprents node in tree of prolog searching(encapsulate backtracking etc.).

It takes rule(probabaly partially matched) and tries to to satisfie goal, based on konwledge from database. It allows backtracking and multiple solution looking by remebering dbIndex(index of last matched rule from db) an by rembering position (pos) it list of goals to satisfy.

match and match: block (the same for loops) are a little bit different becasue of some rule/conds are just leafs in seraching tree and if satisfy they can execute block.

chg variable is list of vairables that was changed by matcher (unified with some value). That is used for recovering and backtracking.'!
!Fitter methodsFor!
loop
	| ans czy |
	" Try to unify all goals"
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match.
		 (ans == true) ifTrue: [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos) eval) setDatabase: database ] ] ifFalse: [pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!private! !

!Fitter methodsFor!
loop
	| ans czy |
	" Try to unify all goals"
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match.
		 (ans == true) 	ifTrue: [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos) eval) setDatabase: database ] ]
					ifFalse: [pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!private! !

!Fitter methodsFor!
loop
	| ans czy |
	" Try to unify all goals"
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match.
		 (ans == true) 	ifTrue: 	[
							pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos) eval) setDatabase: database ]
							]
					ifFalse:	[pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!private! !

!Fitter methodsFor!
loop
	| ans czy |
	" Try to unify all goals"
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match.
		 (ans == true) 	ifTrue: 	[
								pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos) eval) setDatabase: database ]
							]
					ifFalse:	[pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy! !
!Fitter categoriesFor: #loop!private! !

!Fitter methodsFor!
loop
	| ans czy |
	" Try to unify all goals"
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match.
		 (ans == true) 	ifTrue: 	[
								pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos) eval) setDatabase: database ] " Next rule to satisfy"
							]
					ifFalse:	[pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [czy := false] ifFalse: [czy :=true. pos:= (matchers  size)]. ^czy " All rules are correct. Success!!"! !
!Fitter categoriesFor: #loop!private! !

!Fitter methodsFor!
loop: block
	| ans czy tmp e|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: []] "ifFalse: it allows backtracking, if matcher returns true than try the same matcher"
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos)  eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!private! !

!Fitter methodsFor!
loop: block
	| ans czy|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: []] "ifFalse: it allows backtracking, if matcher returns true than try the same matcher"
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos)  eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!private! !

!Fitter methodsFor!
loop: block
	| ans czy|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. czy := false. pos:=1.].
	(czy == false) ifTrue: [^czy].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: []] "ifFalse: it allows backtracking, if matcher returns true than try the same matcher"
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos)  eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [czy:=false] ifFalse: [ pos:=(matchers size). czy:=true]. ^czy.! !
!Fitter categoriesFor: #loop:!private! !

!Fitter methodsFor!
loop: block
	| ans ret|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. ret := false. pos:=1.].
	(ret == false) ifTrue: [^ret].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: []] "ifFalse: it allows backtracking, if matcher returns true than try the same matcher"
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos)  eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [ret:=false] ifFalse: [ pos:=(matchers size). ret:=true]. ^ret.! !
!Fitter categoriesFor: #loop:!private! !

!Fitter methodsFor!
loop: block
	| ans ret|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. ret := false. pos:=1.].
	(ret == false) ifTrue: [^ret].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: []] "ifFalse: it allows backtracking, if matcher returns true than try the same matcher"
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos)  eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [ret:=false] ifFalse: [ pos:=(matchers size). ret:=true]. ^ret.! !
!Fitter categoriesFor: #loop:!private! !

!Fitter methodsFor!
loop: block
	| ans ret|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. ret := false. pos:=1.].
	(ret == false) ifTrue: [^ret].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: []] "ifFalse: it allows backtracking, if matcher returns true than try the same matcher"
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos)  eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [ret:=false] ifFalse: [ pos:=(matchers size). ret:=true]. ^ret.! !
!Fitter categoriesFor: #loop:!private! !

!Fitter methodsFor!
loop: block
	| ans ret|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. ret := false. pos:=1.].
	(ret == false) ifTrue: [^ret].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: []] "ifFalse: it allows backtracking, if matcher returns true than try the same matcher"
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos)  eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [ret:=false] ifFalse: [ pos:=(matchers size). ret:=true]. ^ret.! !
!Fitter categoriesFor: #loop:!private! !

!Fitter methodsFor!
loop: block
	| ans ret|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. ret := false. pos:=1.].
	(ret == false) ifTrue: [^ret].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: []] "ifFalse: it allows backtracking, if matcher returns true than try the same matcher"
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos)  eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [ret:=false] ifFalse: [ pos:=(matchers size). ret:=true]. ^ret.! !
!Fitter categoriesFor: #loop:!private! !

!Fitter methodsFor!
loop: block
	| ans ret|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. ret := false. pos:=1.].
	(ret == false) ifTrue: [^ret].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: []] "ifFalse: it allows backtracking, if matcher returns true than try the same matcher"
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos)  eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [ret:=false] ifFalse: [ pos:=(matchers size). ret:=true]. ^ret.! !
!Fitter categoriesFor: #loop:!private! !

!Fitter methodsFor!
loop: block
	| ans ret|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. ret := false. pos:=1.].
	(ret == false) ifTrue: [^ret].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: []] "ifFalse: it allows backtracking, if matcher returns true than try the same matcher"
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos)  eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [ret:=false] ifFalse: [ pos:=(matchers size). ret:=true]. ^ret.! !
!Fitter categoriesFor: #loop:!private! !

!Fitter methodsFor!
loop: block
	| ans ret|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. ret := false. pos:=1.].
	(ret == false) ifTrue: [^ret].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: []] "ifFalse: it allows backtracking, if matcher returns true than try the same matcher"
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos)  eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [ret:=false] ifFalse: [ pos:=(matchers size). ret:=true]. ^ret.! !
!Fitter categoriesFor: #loop:!private! !

!Fitter methodsFor!
loop: block
	| ans ret|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. ret := false. pos:=1.].
	(ret == false) ifTrue: [^ret].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: []] "ifFalse: it allows backtracking, if matcher returns true than try the same matcher"
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos)  eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [ret:=false] ifFalse: [ pos:=(matchers size). ret:=true]. ^ret.! !
!Fitter categoriesFor: #loop:!private! !

!Fitter methodsFor!
loop: block
	| ans ret|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. ret := false. pos:=1.].
	(ret == false) ifTrue: [^ret].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: []] "ifFalse: it allows backtracking, if matcher returns true than try the same matcher"
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos)  eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [ret:=false] ifFalse: [ pos:=(matchers size). ret:=true]. ^ret.! !
!Fitter categoriesFor: #loop:!private! !

!Fitter methodsFor!
loop: block
	| ans ret|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. ret := false. pos:=1.].
	(ret == false) ifTrue: [^ret].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: []] "ifFalse: it allows backtracking, if matcher returns true than try the same matcher"
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos)  eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [ret:=false] ifFalse: [ pos:=(matchers size). ret:=true]. ^ret.! !
!Fitter categoriesFor: #loop:!private! !

!Fitter methodsFor!
loop: block
	| ans ret|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. ret := false. pos:=1.].
	(ret == false) ifTrue: [^ret].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: []] "ifFalse: it allows backtracking, if matcher returns true than try the same matcher"
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos)  eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [ret:=false] ifFalse: [ pos:=(matchers size). ret:=true]. ^ret.! !
!Fitter categoriesFor: #loop:!private! !

!Fitter methodsFor!
loop: block
	| ans ret|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. ret := false. pos:=1.].
	(ret == false) ifTrue: [^ret].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: []] "ifFalse: it allows backtracking, if matcher returns true than try the same matcher"
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos)  eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [ret:=false] ifFalse: [ pos:=(matchers size). ret:=true]. ^ret.! !
!Fitter categoriesFor: #loop:!private! !

!Fitter methodsFor!
loop: block
	| ans ret|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. ret := false. pos:=1.].
	(ret == false) ifTrue: [^ret].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: []] "ifFalse: it allows backtracking, if matcher returns true than try the same matcher"
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos)  eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [ret:=false] ifFalse: [ pos:=(matchers size). ret:=true]. ^ret.! !
!Fitter categoriesFor: #loop:!private! !

!Fitter methodsFor!
loop: block
	| ans ret|
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. ret := false. pos:=1.].
	(ret == false) ifTrue: [^ret].
	[(pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  (pos == (matchers size)) 	ifTrue: [ ans := (matchers at: pos)  match: block.  (ans == false) ifTrue: [pos :=pos - 1] ifFalse: []] "ifFalse: it allows backtracking, if matcher returns true than try the same matcher"
							ifFalse:  [
										ans := (matchers at: pos)  match. (ans == false) 
										ifTrue: [pos:=pos- 1]
										ifFalse:  [pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos)  eval) setDatabase: database ] ] 
									].
		].
	(pos < 1) ifTrue: [ret:=false] ifFalse: [ pos:=(matchers size). ret:=true]. ^ret.! !
!Fitter categoriesFor: #loop:!private! !

!Fitter methodsFor!
loop
	| ans ret |
	" Try to unify all goals"
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. ret := false. pos:=1.].
	(ret == false) ifTrue: [^ret].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match.
		 (ans == true) 	ifTrue: 	[
								pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos) eval) setDatabase: database ] " Next rule to satisfy"
							]
					ifFalse:	[pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [ret := false] ifFalse: [ret :=true. pos:= (matchers  size)]. ^ret " All rules are correct. Success!!"! !
!Fitter categoriesFor: #loop!private! !

!Fitter methodsFor!
loop
	| ans ret |
	" Try to unify all goals"
	( matchers == nil) ifTrue: [chg do: [ :x | x  zeros]. chg := Array new. ret := false. pos:=1.].
	(ret == false) ifTrue: [^ret].
	[ (pos>= 1) & (pos <= (matchers size))] whileTrue: 
		[
		  ans := (matchers at: pos) match.
		 (ans == true) 	ifTrue: 	[
								pos :=pos + 1. (pos <= (matchers size)) ifTrue: [ (matchers at: pos) setRule: ( (raw at: pos) eval) setDatabase: database ] " Next rule to satisfy"
							]
					ifFalse:	[pos:= pos - 1] 
		].
	(pos < 1) ifTrue: [ret := false] ifFalse: [ret :=true. pos:= (matchers  size)]. ^ret " All rules are correct. Success!!"! !
!Fitter categoriesFor: #loop!private! !

!Fitter methodsFor!
match
	| ans dbFound  tmp ret|
	ret:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [pos:=1. ret:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [(matchers size == 0) ifTrue: [matchers  := nil]. ret := true. dbFound := false].
	].
	^ret.



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp ret|
	ret:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [pos:=1. ret:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [(matchers size == 0) ifTrue: [matchers  := nil]. ret := true. dbFound := false].
	].
	^ret.



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp ret|
	ret:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [pos:=1. ret:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [(matchers size == 0) ifTrue: [matchers  := nil]. ret := true. dbFound := false].
	].
	^ret.



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp ret|
	ret:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop. 
		(ans == false) 	ifTrue: [	
							tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [pos:=1. ret:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [(matchers size == 0) ifTrue: [matchers  := nil]. ret := true. dbFound := false].
	].
	^ret.



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp ret|
	"  Visible for world method for insisting satisfing goal"
	ret:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop. 
		(ans == false) 	ifTrue: [	
							tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [pos:=1. ret:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [(matchers size == 0) ifTrue: [matchers  := nil]. ret := true. dbFound := false].
	].
	^ret.



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp ret|
	"  Visible for world method for insisting satisfing goal"
	ret:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop. 
		(ans == false) 	ifTrue: [	
							tmp:= rule eval getVarsList. 
							dbFound := self dbFind. "look for rule to match"
							(dbFound == false) ifTrue: [pos:=1. ret:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ).
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [(matchers size == 0) ifTrue: [matchers  := nil]. ret := true. dbFound := false].
	].
	^ret.



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match
	| ans dbFound  tmp ret|
	"  Visible for world method for insisting satisfing goal"
	ret:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop. 
		(ans == false) 	ifTrue: [	
							tmp:= rule eval getVarsList. 
							dbFound := self dbFind. "look for rule to match"
							(dbFound == false) ifTrue: [pos:=1. ret:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ). " which vars was chagned by you"
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [(matchers size == 0) ifTrue: [matchers  := nil]. ret := true. dbFound := false].
	].
	^ret.



	! !
!Fitter categoriesFor: #match!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop: block. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [pos:=1. czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ). " vars chagned by yourself"
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. czy:=true. ^true.].
	].
	^czy.

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound  tmp czy|
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop: block. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [pos:=1. czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ). " vars changed by yourself"
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. czy:=true. ^true.].
	].
	^czy.

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound  tmp czy|
	"  Visible for world method for insisting satisfing goal"
	czy:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop: block. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [pos:=1. czy:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ). " vars changed by yourself"
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. czy:=true. ^true.].
	].
	^czy.

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound  tmp ret|
	"  Visible for world method for insisting satisfing goal"
	ret:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop: block. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [pos:=1. ret:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ). " vars changed by yourself"
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. ret:=true. ^true.].
	].
	^ret.

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound  tmp ret|
	"  Visible for world method for insisting satisfing goal"
	ret:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop: block. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [pos:=1. ret:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ). " vars changed by yourself"
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. ret:=true. ^true.].
	].
	^ret.

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound  tmp ret|
	"  Visible for world method for insisting satisfing goal, it is version with posibility to become leaf and to execeute block"
	ret:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop: block. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [pos:=1. ret:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ). " vars changed by yourself"
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. ret:=true. ^true.].
	].
	^ret.

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Fitter methodsFor!
match:  block
	| ans dbFound  tmp ret|
	"  Visible for world method for insisting satisfing goal, it is version with posibility to become leaf and to execeute block"
	ret:=false.
	dbFound := true.
	[(dbFound == false) not] whileTrue: 
	[	
		ans := self loop: block. 
		(ans == false) 	ifTrue: [	tmp:= rule eval getVarsList. 
							dbFound := self dbFind. 
							(dbFound == false) ifTrue: [pos:=1. ret:=false. ^false]. 
							chg:= tmp difference: (rule eval getVarsList ). " vars changed by yourself"
							self createMatchers: dbFound.
							pos:=1.
						   ]
					ifFalse: [block value. moje do: [ :x | x  zeros]. matchers := nil. ret:=true. ^true.]. " Return true for futher computation"
	].
	^ret.

	
	




	! !
!Fitter categoriesFor: #match:!public! !

!Prolog methodsFor!
go: ask do: action
	 | recover matchers tmp i tab|
	" Answert the goal(ask)"
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask eval.]
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  hardReset ].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | recover matchers tmp i tab|
	" Answert the goal(ask)"
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask eval.] " One term"
	ifFalse: [ tab:= ask terms.].
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  hardReset ].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | recover matchers tmp i tab|
	" Answert the goal(ask)"
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask eval.] " One term"
	ifFalse: [ tab:= ask terms.]. " Conjunction"
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: 
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  hardReset ].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | recover matchers tmp i tab|
	" Answert the goal(ask)"
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask eval.] " One term"
	ifFalse: [ tab:= ask terms.]. " Conjunction"
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: "Try to satify all goals from conjunction"
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: [] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  hardReset ].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | recover matchers tmp i tab|
	" Answert the goal(ask)"
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask eval.] " One term"
	ifFalse: [ tab:= ask terms.]. " Conjunction"
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: "Try to satify all goals from conjunction"
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: ["one value was found, look for another"] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  hardReset ].
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | recover matchers tmp i tab|
	" Answert the goal(ask)"
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask eval.] " One term"
	ifFalse: [ tab:= ask terms.]. " Conjunction"
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: "Try to satify all goals from conjunction"
				[
					| ans|
					(i ==  (matchers size)) 
					ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: ["one value was found, look for another"] ]
					ifFalse:  
					[	
						ans := (matchers at: i) match. 
						(ans == false) 	ifTrue: [i :=i - 1]
									ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
					].
				].
		recover do: [ :x | x  hardReset ]. " recover values"
	




! !
!Prolog categoriesFor: #go:do:!public! !

!Prolog methodsFor!
go: ask do: action
	 | recover matchers tmp i tab|
	" Answert the goal(ask)"
	matchers := Array new.
	((ask class superclass) == Term) ifTrue: [tab:= Array new. tab resize:1. tab at:1 put:ask eval.] " One term"
	ifFalse: [ tab:= ask terms.]. " Conjunction"
	matchers := Array new.
	(tab size > 0) ifTrue: [tab do: [:elem | tmp:= Fitter new. tmp  setRule: (elem eval) setDatabase: database. matchers resize: ((matchers size) + 1). matchers  at: (matchers size) put: tmp ]].
	recover := Array new.
	tab do: [:elem | recover := recover , (elem getVarsList) ].
			i := 1.
			[ (i >= 1) & (i <= (matchers size))] whileTrue: "Try to satify all goals from conjunction"
				[
					| ans|
					(i ==  (matchers size)) 
						ifTrue: [ans := (matchers at: i) match: action. (ans == false) ifTrue: [i :=i - 1]ifFalse: ["one value was found, look for another"] ]
						ifFalse:  
						[	
							ans := (matchers at: i) match. 
							(ans == false) 	ifTrue: [i :=i - 1]
										ifFalse: [i:= i + 1. (i <= (matchers  size)) ifTrue: [(matchers at: i) setRule: ((tab at: i) eval) setDatabase: database ] ] 
						].
				].
		recover do: [ :x | x  hardReset ]. " recover values"
	




! !
!Prolog categoriesFor: #go:do:!public! !

Conjunction comment:
'List of terms ( t1 & t2...) == logical and.'!
V reset.
x:= V @ #x.
y:= V @ #y.
w:=0.
m:=0.
x go: y do: [w:=x value. m:=y value].!

p1 := x , (C  % 1). 
p2 := c , y.
w:=0.
m:=0.
p1 go: p2 do: [w:=x value. m:=y value].!

w!

m!

p1 := x , y. 
p2 := y , x.
w:=0.
m:=0.
p1 go: p2 do: [w:=7].!

w!

p1 := x , (x, y). 
p2 := c, (y,y).
w:=0.
m:=0.
p1 go: p2 do: [w:=x value. m:=y value].!

m!

w!

p1 := x , (x, y). 
p2 := c, (y,c).
w:=0.
m:=0.
p1 go: p2 do: [w:=x value. m:=y value].!

m!

w!

w!

p1 := x , (x, y). 
p2 := c, (y,(C % 7)).
w:=0.
m:=0.
p1 go: p2 do: [w:=x value. m:=y value].!

w!

m!

r:= V @ #r.
z:= V @ #z.
p1 := (((x , z),z),r). 
p2 := (((y , y),r),(C % 7)). 
w:=0.
m:=0.
q:=0.
p:=0.
p1 go: p2 do: [w:=x value. m:=y value.  q:=z value.  p:=r value].!

w!

m!

V reset. t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].

a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].

t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].

C % 1 go: C % 2 do: [self assert: [false]].

w := 0.
C % 1 go: C % 1 do: [w := w + 1].
self assert: [w = 1].

x := V @ #x.
y := V @ #y.
w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].

w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].

w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].

x go: L, x do: [self assert: [false]].!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
self assert: [w = #('' 'abc' 'a' 'bc' 'ab' 'c' 'abc' '') asOrderedCollection]!

V reset. t := L % 1, (V @ 2 % 3).
self assert: [t car car value isNil].
self assert: [t car cdr value = 1].
self assert: [t car value car isNil].
self assert: [t car value cdr = 1].
self assert: [t cdr cdr value = 3].

a := V @ 1.
b := V @ 2.
c := V @ 1.
self assert: [a ~= b].
self assert: [a == c].

t := C % 1 @ #z.
self assert: [t car value = 1].
w := 0.
[t value] on: Error do: [:ex | w := w + 1].
self assert: [w = 1].

C % 1 go: C % 2 do: [self assert: [false]].

w := 0.
C % 1 go: C % 1 do: [w := w + 1].
self assert: [w = 1].


x := V @ #x.
y := V @ #y.

w := 0.
x % 1 go: C % 2, y do:
    [w := w + 1.
    self assert: [x value = 2].
    self assert: [y value = 1]].
self assert: [w = 1].
w := 0.
[x value] on: Error do: [:ex | w := w + 1].
[y value] on: Error do: [:ex | w := w + 1].
self assert: [w = 2].


w := 0.
C % 1 % 2 go: x do:
    [w := w + 1.
    self assert: [x value car = 1].
    self assert: [x cdr value = 2]].
self assert: [w = 1].

w := 0.
x go: C % $a do:
    [w := w + 1.
    x go: C % $b do: [self assert: [false]]].
x go: C % $b do: [w := w + 1].
self assert: [w = 2].


w := 0.
x % 1 go: y, y do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1]].
self assert: [w = 1].

w := 0.
z := V @ #z.
x % 1, x go: y, y, z do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 1].
    self assert: [z value = 1]].
self assert: [w = 1].


x go: L, x do: [self assert: [false]].


"external"
w := 0.
x, y % 1 go: z, x, y do: [
	w := w + 1.
	 self assert: [x value = 1].
	self assert: [y value = 1].
	self assert: [z value = 1]
].
self assert: [w = 1].

x := V @ #x.
y := V @ #y.
w := 0.
x go: y do: [
	x, y go: C % 1 % 1 do: [
	w := 1.
	self assert: [x value = 1].
	self assert: [y value = 1]
]
].

w := 0.
x := V @ #x.
y := V @ #y.
z := V @ #z.
d := V @ #d.
w := 0.
e := 0.
o := 0.
(x, y), (z, y) go: d do: [
	d go: (y, z), (x % 1) do: [
		w := 1.
		self assert: [x value = 1].
		self assert: [y value = 1].
		self assert: [z value = 1].
		self assert: [d value cdr cdr = 1].
		self assert: [d value cdr car = 1].
		self assert: [d value car cdr = 1].
		self assert: [d value car car = 1].

		self assert: [d cdr value cdr = 1].
		self assert: [d cdr value car = 1].
		self assert: [d car value cdr = 1].
		self assert: [d car value car = 1].
		
		self assert: [d cdr cdr value  = 1].
		self assert: [d cdr car value = 1].
		self assert: [d car cdr value = 1].
		self assert: [d car car value = 1].
		
		[x car] on: Error do: [:ex | e := e + 1].
		[x cdr] on: Error do: [:ex | e := e + 1].
	].
	[x value] on: Error do: [:ex | o := o + 1].
	[y value] on: Error do: [:ex | o := o + 1].
	[z value] on: Error do: [:ex | o := o + 1].
	[d value] on: Error do: [:ex | o := o + 1].
].
self assert: [w = 1].
self assert: [e = 2].
self assert: [o = 4].


x := V @ #x.
y := V @ #y.
w := 0.
x go: y do: [
y go: x do: [
x, y go: C % 1 % 2 do: [
w := w + 1.
].
].
].
self assert: [w = 0].


x := C % nil.
self assert: [x value = nil].
self assert: [L value = nil].

 
!

"11:35:02, 22 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mimuw\done\mj348711.img7'"!

"11:35:15, 22 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\mj348711_jipp\mj348711.img7'"!

(Package manager packageNamed: 'mj348711') comment:
'Michal Jaron
nr. 348711

Jezyki i paradygamty programowania, zadanie 4 - small talk.'!
"11:44:27, 22 czerwca 2017: Image saved to 'C:\Users\Micha³\Documents\test_small\mj348711.img7'"!

"11:44:32, 22 czerwca 2017: Image saved"!

"11:47:28, 22 czerwca 2017: Dolphin Smalltalk Professional started"!

"11:49:15, 22 czerwca 2017: Dolphin Smalltalk Professional started"!

"11:50:28, 22 czerwca 2017: Image saved"!

"11:51:27, 22 czerwca 2017: Dolphin Smalltalk Professional started"!

"11:51:56, 22 czerwca 2017: Image saved"!

"11:54:08, 22 czerwca 2017: Dolphin Smalltalk Professional started"!

"11:59:15, 22 czerwca 2017: Dolphin Smalltalk Professional started"!

x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
self assert: [w = #('' 'abc' 'a' 'bc' 'ab' 'c' 'abc' '') asOrderedCollection]!

"12:00:46, 22 czerwca 2017: Dolphin Smalltalk Professional started"!

V reset. x := V @ #x.
t := #(1 2 3) asOrderedCollection.
p := Prolog new.
t do: [:each | p fact: C % each].
w := OrderedCollection new.
p go: x do: [w add: x value].
self assert: [w = t].
w := 0.
p go: (C % 1) & (C % 2) & (C % 3) do: [w := w + 1].
self assert: [w = 1].
w := 0.
p go: (C % 1) & ((C % 2) & (C % 3)) do: [w := w + 1].
self assert: [w = 1].

y := V @ #y.
p := Prolog new
    fact: C % 1 % $a;
    fact: C % 2 % $b;
    head: x, y % $c body: (x % $a) & (y % $b);
    yourself.
w := 0.
p go: x, y % $c do:
    [w := w + 1.
    self assert: [x value = 1].
    self assert: [y value = 2]].
self assert: [w = 1].

z := V @ #z.
p := Prolog new
    fact: x, (y, x) % #member;
    head: x, (y, z) % #member body: x, y % #member;
    yourself.
w := OrderedCollection new.
p go: x, (L % 1 % 2 % 3) % #member do: [w add: x value].
self assert: [w = #(3 2 1) asOrderedCollection].

w := OrderedCollection new.
m := L % 1 % 2 % 3 % 4.
n := L % 0 % 2 % 4 % 6.
p go: (x, m % #member) & (x, n % #member) do: [w add: x value].
self assert: [w = #(4 2) asOrderedCollection].

a := V @ #a.
b := V @ #b.
c := V @ #c.
p fact: L, x, x % #append.
p head: (a, x), b, (c, x) % #append body: a, b, c % #append.
w := OrderedCollection new.
p go: x, y, (L % $c % $b % $a) % #append do:
    [[:q |
    s := OrderedCollection new.
    p go: a, q % #member do: [s add: a value].
    w add: (String withAll: s)]
        value: x;
        value: y].
self assert: [w = #('' 'abc' 'a' 'bc' 'ab' 'c' 'abc' '') asOrderedCollection]!

